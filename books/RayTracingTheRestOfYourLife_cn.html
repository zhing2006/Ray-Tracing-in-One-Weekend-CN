<meta charset="utf-8">
<link rel="icon" type="image/png" href="../favicon.png">
<!-- Markdeep: https://casual-effects.com/markdeep/ -->



                               **Ray Tracing: The Rest of Your Life**
                   [Peter Shirley][], [Trevor David Black][], [Steve Hollasch][]
                                                <br>
                                     Version 4.0.0-alpha.2, 2023-XX-XX
                                                <br>
                      Copyright 2018-2023 Peter Shirley. All rights reserved.



概述
====================================================================================================
在《一周末光线追踪》和《一周末光线追踪》中，你构建了一个“真实”的光线追踪器。

如果你有动力，你可以利用这些书中的源代码和信息来实现任何你想要的视觉效果。
这些源代码为你构建一个小型爱好项目的光线追踪器提供了有意义且稳定的基础。
商业光线追踪器中的大多数视觉效果都依赖于这两本书中描述的技术。然而，如果缺乏数学基础，
你将无法添加越来越复杂的视觉效果，如次表面散射或嵌套介质。在本书中，我假设你要么是一个非常感兴趣的学生，
要么是一个从事与光线追踪相关职业的人。我们将深入探讨创建一个非常严肃的光线追踪器的数学知识。完成后，
你将具备使用和修改许多流行领域中的商业光线追踪器的能力，如电影、电视、产品设计和建筑行业。

在这本简短的书中，我没有涵盖很多内容。例如，有很多种编写蒙特卡洛渲染程序的方法，我只深入介绍了其中一种。
我没有涵盖阴影射线（而是让射线更有可能朝向光源），也没有涵盖双向方法、Metropolis方法或光子映射。
你会在所谓的“严肃光线追踪器”中找到许多这些技术，但它们在这里没有涵盖，因为更重要的是涵盖领域的概念、数学和术语。
我认为这本书是一个深入了解的开始，它将为你提供一些概念、数学和术语，以便你学习这些和其他有趣的技术。

希望你会像我一样对数学感到着迷。

与以前一样，https://in1weekend.blogspot.com/ 上会有进一步的阅读和参考资料。

这些书已经经过格式化，可以直接从浏览器中打印。我们还在“资产”部分包含了每本书的PDF版本。

感谢所有在这个项目中帮助过的人。你可以在本书末尾的致谢部分找到他们的名字。

---

另：从本章的中文化版本开始，Rust代码将不再放入单独的文件，而是直接整合到C++代码片段之下。并像此段文字一样前后用分割线分开。

使用`cargo`创建工程

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    cargo new --name the_test_of_your_life TheRestOfYourLife
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---



一个简单的蒙特卡洛程序
====================================================================================================
让我们从最简单的蒙特卡洛程序开始。如果你对蒙特卡洛程序不熟悉，那么停下来让我给你介绍一下。随机化算法分为两种：
蒙特卡洛算法和拉斯维加斯算法。随机化算法在计算机图形学中随处可见，所以建立一个良好的基础是个不错的主意。
随机化算法在计算过程中使用了一定程度的随机性。拉斯维加斯（LV）随机算法总是能够产生正确的结果，
而蒙特卡洛（MC）算法**可能**会产生正确的结果，但经常会出错！但是对于像光线追踪这样特别复杂的问题，
我们可能并不是非常追求完全准确，而是希望在合理的时间内得到一个答案。拉斯维加斯算法最经典的例子就是**快速排序**算法。
快速排序算法总是能够完成排序，但完成所需的时间是随机的。
另一个很好的拉斯维加斯算法的例子是我们用来选择单位球中随机点的代码：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    inline vec3 random_in_unit_sphere() {
        while (true) {
            auto p = vec3::random(-1,1);
            if (p.length_squared() < 1)
                return p;
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [las-vegas-algo]: <kbd>[vec3.h]</kbd> 一个拉斯维加斯算法]

这段代码最终总会得到一个单位球中的随机点，但我们无法预先知道需要多长时间。可能只需要1次迭代，也可能需要2次、
3次、4次甚至更多次。而蒙特卡洛程序将给出一个统计估计的答案，随着运行时间的增加，这个估计将变得越来越准确。
这意味着在某个时刻，我们可以决定答案已经足够准确，然后停止计算。
简单程序产生嘈杂但越来越好的答案的这种基本特性就是蒙特卡洛的全部内容，
对于像图形学这样不需要极高精度的应用特别有效。


估算π
--------------
蒙特卡洛算法的经典例子就是估算π，所以我们来做这个。有很多方法可以估算π，其中包括了著名的Buffon Needle问题。
我们将进行一个受此方法启发的变体。假设你有一个内切于正方形的圆：

  ![Figure [circ-square]: 用一个圆内切于一个正方形来估算π
  ](../images/fig-3.01-circ-square.jpg)

现在，假设你在正方形内随机选择点。最终落在圆内的随机点的比例应该与圆的面积成比例。
实际上，这个比例应该等于圆的面积与正方形的面积的比值：

  $ \frac{\pi r^2}{(2r)^2} = \frac{\pi}{4} $

<div class='together'>
由于$r$相互抵消，我们可以选择计算上方便的值。让我们选择$r=1$，以原点为中心：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <stdlib.h>

    int main() {
        int N = 100000;
        int inside_circle = 0;
        for (int i = 0; i < N; i++) {
            auto x = random_double(-1,1);
            auto y = random_double(-1,1);
            if (x*x + y*y < 1)
                inside_circle++;
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "Estimate of Pi = " << (4.0 * inside_circle) / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [estpi-1]: <kbd>[pi.cc]</kbd> 估算π]

---
Rust实现

本章开始由于需要编译多个不同的案例，因此先需修改Cargo.toml文件。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ toml
    [package]
    name = "the_rest_of_your_life"
    version = "0.1.0"
    edition = "2021"

    [[bin]]
    name = "pi"
    path = "src/bin/pi.rs"
    test = false

    [dependencies]
    rand = "0"
    stb_image = "0.2"
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

通过`[[bin]]`的方式加入不同的案例，同时为了让不同的案例能共享代码。添加src/lib.rs文件。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub mod vec3;
    pub mod color;
    pub mod ray;
    pub mod hittable;
    pub mod sphere;
    pub mod hittable_list;
    pub mod rtweekend;
    pub mod interval;
    pub mod camera;
    pub mod material;
    pub mod aabb;
    pub mod bvh;
    pub mod texture;
    pub mod rtw_stb_image;
    pub mod perlin;
    pub mod quad;
    pub mod constant_medium;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

现在开始实现pi的计算：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double_range;

    fn main() {
        const N: usize = 100000;
        let mut inside_circle = 0;
        (0..N).for_each(|_| {
            let x = random_double_range(-1.0, 1.0);
            let y = random_double_range(-1.0, 1.0);
            if x * x + y * y < 1.0 {
            inside_circle += 1;
            }
        });
        println!("Estimate of pi: {:.12}", 4.0 * inside_circle as f64 / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

得到的π的答案会因为初始随机种子的不同而在不同的计算机上有所变化。在我的计算机上，
这给出的答案是`Estimate of Pi = 3.143760000000`。

</div>


显示收敛性
--------------------
如果我们将程序修改为无限运行，并且只打印出一个运行时的估计值：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <stdlib.h>

    int main() {
        int inside_circle = 0;
        int runs = 0;
        std::cout << std::fixed << std::setprecision(12);
        while (true) {
            runs++;
            auto x = random_double(-1,1);
            auto y = random_double(-1,1);
            if (x*x + y*y < 1)
                inside_circle++;

            if (runs % 100000 == 0)
                std::cout << "Estimate of Pi = "
                          << (4.0 * inside_circle) / runs
                          << '\n';
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [estpi-2]: <kbd>[pi.cc]</kbd> 估算π，版本2]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double_range;

    fn main() {
        let mut inside_circle = 0;
        let mut runs = 0;
        loop {
            runs += 1;
            let x = random_double_range(-1.0, 1.0);
            let y = random_double_range(-1.0, 1.0);
            if x * x + y * y < 1.0 {
                inside_circle += 1;
            }

            if runs % 100000 == 0 {
                println!("Estimate of pi: {:.12}", 4.0 * inside_circle as f64 / runs as f64);
            }
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---


分层采样（抖动）
-------------------------------
我们很快接近$\pi$，然后慢慢逼近它。这是“收益递减定律”的一个例子，每个样本的帮助都比上一个样本少。
这是蒙特卡洛的最糟糕的部分。我们可以通过对样本进行“分层采样”（通常称为“抖动”）来减轻这种收益递减，
即不再随机采样，而是在一个网格中每个位置取一个样本：

  ![图 [jitter]: 使用抖动点进行采样](../images/fig-3.02-jitter.jpg)

<div class='together'>
这改变了样本生成的方式，但我们需要事先知道要采样多少个样本，因为我们需要知道网格的大小。让我们取一百万个样本，
然后用两种方式进行尝试：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>

    int main() {
        int inside_circle = 0;
        int inside_circle_stratified = 0;
        int sqrt_N = 1000;
        for (int i = 0; i < sqrt_N; i++) {
            for (int j = 0; j < sqrt_N; j++) {
                auto x = random_double(-1,1);
                auto y = random_double(-1,1);
                if (x*x + y*y < 1)
                    inside_circle++;
                x = 2*((i + random_double()) / sqrt_N) - 1;
                y = 2*((j + random_double()) / sqrt_N) - 1;
                if (x*x + y*y < 1)
                    inside_circle_stratified++;
            }
        }

        std::cout << std::fixed << std::setprecision(12);
        std::cout
            << "Regular    Estimate of Pi = "
            << (4.0 * inside_circle) / (sqrt_N*sqrt_N) << '\n'
            << "Stratified Estimate of Pi = "
            << (4.0 * inside_circle_stratified) / (sqrt_N*sqrt_N) << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [estpi-3]: <kbd>[pi.cc]</kbd> 估算π，版本3]

</div>

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::{
        random_double,
        random_double_range,
    };

    fn main() {
        let mut inside_circle = 0;
        let mut inside_circle_stratified = 0;
        const SQRT_N: usize = 1000;
        (0..SQRT_N).for_each(|i| {
            (0..SQRT_N).for_each(|j| {
                let x = random_double_range(-1.0, 1.0);
                let y = random_double_range(-1.0, 1.0);
                if x * x + y * y < 1.0 {
                    inside_circle += 1;
                }
                let x = 2.0 * (i as f64 + random_double()) / SQRT_N as f64 - 1.0;
                let y = 2.0 * (j as f64 + random_double()) / SQRT_N as f64 - 1.0;
                if x * x + y * y < 1.0 {
                    inside_circle_stratified += 1;
                }
            })
        });

        println!("Regular    Estimate of Pi = {:.12}", 4.0 * inside_circle as f64 / (SQRT_N * SQRT_N) as f64);
        println!("Stratified Estimate of Pi = {:.12}", 4.0 * inside_circle_stratified as f64 / (SQRT_N * SQRT_N) as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

<div class='together'>
在我的电脑上，结果如下：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Regular    Estimate of Pi = 3.141184000000
    Stratified Estimate of Pi = 3.141460000000
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

其中π的前12位小数为：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    3.141592653589
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

有趣的是，分层方法不仅更好，而且收敛速度更快！不幸的是，这个优势随着问题的维度增加而减小（例如，
对于3D球体体积版本，差距会更小）。这被称为“维度诅咒”。光线追踪是一个非常高维的算法，每次反射都会增加两个新的维度：
$\phi_o$和$\theta_o$。在本书中，我们不会对输出的反射角进行分层，因为这有点复杂，但目前在这个领域有很多有趣的研究正在进行中。

作为中间步骤，我们将对每个像素位置周围的采样位置进行分层。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include "camera.h"
    #include "color.h"
    #include "hittable_list.h"
    #include "material.h"
    #include "quad.h"
    #include "sphere.h"

    int main() {
        hittable_list world;

        auto red   = make_shared<lambertian>(color(.65, .05, .05));
        auto white = make_shared<lambertian>(color(.73, .73, .73));
        auto green = make_shared<lambertian>(color(.12, .45, .15));
        auto light = make_shared<diffuse_light>(color(15, 15, 15));

        // Cornell box sides
        world.add(make_shared<quad>(point3(555,0,0), vec3(0,0,555), vec3(0,555,0), green));
        world.add(make_shared<quad>(point3(0,0,555), vec3(0,0,-555), vec3(0,555,0), red));
        world.add(make_shared<quad>(point3(0,555,0), vec3(555,0,0), vec3(0,0,555), white));
        world.add(make_shared<quad>(point3(0,0,555), vec3(555,0,0), vec3(0,0,-555), white));
        world.add(make_shared<quad>(point3(555,0,555), vec3(-555,0,0), vec3(0,555,0), white));

        // Light
        world.add(make_shared<quad>(point3(213,554,227), vec3(130,0,0), vec3(0,0,105), light));

        // Box 1
        shared_ptr<hittable> box1 = box(point3(0,0,0), point3(165,330,165), white);
        box1 = make_shared<rotate_y>(box1, 15);
        box1 = make_shared<translate>(box1, vec3(265,0,295));
        world.add(box1);

        // Box 2
        shared_ptr<hittable> box2 = box(point3(0,0,0), point3(165,165,165), white);
        box2 = make_shared<rotate_y>(box2, -18);
        box2 = make_shared<translate>(box2, vec3(130,0,65));
        world.add(box2);

        camera cam;

        cam.aspect_ratio      = 1.0;
        cam.image_width       = 600;
        cam.samples_per_pixel = 64;
        cam.max_depth         = 50;
        cam.background        = color(0,0,0);

        cam.vfov     = 40;
        cam.lookfrom = point3(278, 278, -800);
        cam.lookat   = point3(278, 278, 0);
        cam.vup      = vec3(0, 1, 0);

        cam.defocus_angle = 0;

        cam.render(world, lights);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [estpi-3]: <kbd>[main.cc]</kbd> 在像素内部进行样本分层]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub mod vec3;
    pub mod color;
    pub mod ray;
    pub mod hittable;
    pub mod sphere;
    pub mod hittable_list;
    pub mod rtweekend;
    pub mod interval;
    pub mod camera;
    pub mod material;
    pub mod aabb;
    pub mod bvh;
    pub mod texture;
    pub mod rtw_stb_image;
    pub mod perlin;
    pub mod quad;
    pub mod constant_medium;

    use std::rc::Rc;

    use vec3::{Vec3, Point3};
    use color::Color;
    use hittable_list::HittableList;
    use camera::Camera;
    use material::{
        Material,
        Lambertian,
        DiffuseLight,
    };
    use quad::{
        Quad,
        make_box,
    };
    use hittable::{
        Translate,
        RotateY,
    };

    fn cornell_box() {
        let mut world = HittableList::default();

        let red: Rc<dyn Material> = Rc::new(Lambertian::new(Color::new(0.65, 0.05, 0.05)));
        let white: Rc<dyn Material> = Rc::new(Lambertian::new(Color::new(0.73, 0.73, 0.73)));
        let green: Rc<dyn Material> = Rc::new(Lambertian::new(Color::new(0.12, 0.45, 0.15)));
        let light: Rc<dyn Material> = Rc::new(DiffuseLight::new_with_color(Color::new(15.0, 15.0, 15.0)));

        world.add(Rc::new(
            Quad::new(
                Point3::new(555.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 555.0, 0.0),
                vec3::Vec3::new(0.0, 0.0, 555.0),
                green
            )
        ));
        world.add(Rc::new(
            Quad::new(
                Point3::new(0.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 555.0, 0.0),
                vec3::Vec3::new(0.0, 0.0, 555.0),
                red
            )
        ));
        world.add(Rc::new(
            Quad::new(
                Point3::new(343.0, 554.0, 332.0),
                vec3::Vec3::new(-130.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 0.0, -105.0),
                light
            )
        ));
        world.add(Rc::new(
            Quad::new(
                Point3::new(0.0, 0.0, 0.0),
                vec3::Vec3::new(555.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 0.0, 555.0),
                Rc::clone(&white)
            )
        ));
        world.add(Rc::new(
            Quad::new(
                Point3::new(555.0, 555.0, 555.0),
                vec3::Vec3::new(-555.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 0.0, -555.0),
                Rc::clone(&white)
            )
        ));
        world.add(Rc::new(
            Quad::new(
                Point3::new(0.0, 0.0, 555.0),
                vec3::Vec3::new(555.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 555.0, 0.0),
                Rc::clone(&white)
            )
        ));

        let box1 = make_box(
            Point3::new(0.0, 0.0, 0.0),
            Vec3::new(165.0, 330.0, 165.0),
            Rc::clone(&white)
        );
        let box1 = Rc::new(RotateY::new(box1, 15.0));
        let box1 = Rc::new(Translate::new(box1, vec3::Vec3::new(265.0, 0.0, 295.0)));
        world.add(box1);

        let box2 = make_box(
            Point3::new(0.0, 0.0, 0.0),
            Vec3::new(165.0, 165.0, 165.0),
            Rc::clone(&white)
        );
        let box2 = Rc::new(RotateY::new(box2, -18.0));
        let box2 = Rc::new(Translate::new(box2, vec3::Vec3::new(130.0, 0.0, 65.0)));
        world.add(box2);

        let mut cam = Camera::default();

        cam.aspect_ratio = 1.0;
        cam.image_width = 400;
        cam.samples_per_pixel = 50;
        cam.max_depth = 10;
        cam.background = Color::default();

        cam.vfov = 40.0;
        cam.lookfrom = Point3::new(278.0, 278.0, -800.0);
        cam.lookat = Point3::new(278.0, 278.0, 0.0);
        cam.vup = vec3::Vec3::new(0.0, 1.0, 0.0);

        cam.defocus_angle = 0.0;

        cam.render(&world);
    }

    fn main() {
        cornell_box();
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      public:
        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        void initialize() {
            ...
            sqrt_spp = int(sqrt(samples_per_pixel));
            recip_sqrt_spp = 1.0 / sqrt_spp;
            ...
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        void render(const hittable& world) {
            initialize();

            std::cout << "P3\n" << image_width << ' ' << image_height << "\n255\n";

            for (int j = 0; j < image_height; j++) {
                std::clog << "\rScanlines remaining: " << (image_height - j) << ' ' << std::flush;
                for (int i = 0; i < image_width; i++) {
                    color pixel_color(0,0,0);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
                    for (int s_j = 0; s_j < sqrt_spp; s_j++) {
                        for (int s_i = 0; s_i < sqrt_spp; s_i++) {
                            ray r = get_ray(i, j, s_i, s_j);
                            pixel_color += ray_color(r, max_depth, world);
                        }
                    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
                    write_color(std::cout, pixel_color, samples_per_pixel);
                }
            }

            std::clog << "\rDone.                 \n";
        }
        ...
      private:
        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        ray get_ray(int i, int j, int s_i, int s_j) const {
            // 从相机散焦盘发出一个随机采样的相机光线，该光线经过像素位置附近的随机采样。
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            auto pixel_center = pixel00_loc + (i * pixel_delta_u) + (j * pixel_delta_v);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto pixel_sample = pixel_center + pixel_sample_square(s_i, s_j);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            auto ray_origin = (defocus_angle <= 0) ? center : defocus_disk_sample();
            auto ray_direction = pixel_sample - ray_origin;
            auto ray_time = random_double();

            return ray(ray_origin, ray_direction, ray_time);
        }


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        vec3 pixel_sample_square(int s_i, int s_j) const {
            // 返回位于原点周围的像素正方形内的随机点，给定两个子像素索引。
            auto px = -0.5 + recip_sqrt_spp * (s_i + random_double());
            auto py = -0.5 + recip_sqrt_spp * (s_j + random_double());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            return (px * pixel_delta_u) + (py * pixel_delta_v);
        }

        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        int sqrt_spp;
        double recip_sqrt_spp;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [render-estpi-3]: <kbd>[camera.h]</kbd> 在像素内部进行样本分层（渲染）]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub struct Camera {
        ...
        image_height: usize,    // Rendered image height
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        sqrt_spp: usize,        // Square root of samples per pixel
        recip_sqrt_spp: f64,    // Reciprocal of square root of samples per pixel
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
        center: Point3,         // Camera center
        ...
    }

    impl Default for Camera {
        fn default() -> Self {
            Self {
                ...
                image_height: 0,
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                sqrt_spp: 10.0_f64.sqrt() as usize,
                recip_sqrt_spp: 1.0 / (10.0_f64.sqrt()),
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
                center: Point3::default(),
                ...
            }
        }
    }

    impl Camera {
        pub fn render(&mut self, world: &dyn Hittable) {
            self.initialize();

            println!("P3\n{} {}\n255", self.image_width, self.image_height);
            let stdout = std::io::stdout();

            for j in 0..self.image_height {
                eprintln!("\rScanlines remaining: {}", self.image_height - j);
                for i in 0..self.image_width {
                    let mut pixel_color = Color::default();
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                    for s_j in 0..self.sqrt_spp {
                        for s_i in 0..self.sqrt_spp {
                            let r = self.get_ray(i as i32, j as i32, s_i as i32, s_j as i32);
                            pixel_color += self.ray_color(&r, self.max_depth, world);
                        }
                    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
                    pixel_color.write_color(&mut stdout.lock(), self.samples_per_pixel).unwrap();
                }
            }

            eprintln!("\nDone.");
        }

        fn initialize(&mut self) {
            self.image_height = (self.image_width as f64 / self.aspect_ratio) as usize;
            self.image_height = if self.image_height < 1 { 1 } else { self.image_height };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
            self.sqrt_spp = (self.samples_per_pixel as f64).sqrt() as usize;
            self.recip_sqrt_spp = 1.0 / (self.sqrt_spp as f64);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

            self.center = self.lookfrom;
            ...
        }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn get_ray(&self, i: i32, j: i32, s_i: i32, s_j: i32) -> Ray {
            // Get a randomly sampled camera ray for the pixel at location i,j.
            let pixel_center = self.pixel00_loc + i as f64 * self.pixel_delta_u + j as f64 * self.pixel_delta_v;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
            let pixel_sample = pixel_center + self.pixel_sample_square(s_i, s_j);
            ...
        }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn pixel_sample_square(&self, s_i: i32, s_j: i32) -> Vec3 {
            // Returns a random point in the square surrounding a pixel at the origin.
            let px = -0.5 + self.recip_sqrt_spp * (s_i as f64 + rtweekend::random_double());
            let py = -0.5 + self.recip_sqrt_spp * (s_j as f64 + rtweekend::random_double());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
            px * self.pixel_delta_u + py * self.pixel_delta_v
        }
        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

<div class='together'>
如果我们将没有分层的结果与分层后的结果进行比较：

  ![<span class='num'>图像1：</span> 康奈尔盒，无分层
  ](../images/img-3.01-cornell-no-strat.png class='pixel')

</div>

<div class='together'>
然后，使用分层后的结果：

  ![<span class='num'>图像2：</span> 康奈尔盒，分层
  ](../images/img-3.02-cornell-strat.png class='pixel')

如果你眯起眼睛看，应该能够看到平面边缘和盒子边缘的更清晰的对比度。这种效果在具有更高变化频率的位置更为明显。
高频变化也可以被视为高信息密度。对于我们的康奈尔盒场景，所有的材质都是哑光的，顶部有一个柔和的面光源，
因此只有在物体边缘才有高信息密度的位置。在具有纹理和反射材质的情况下，效果将更加明显。

如果你正在进行单次反射、阴影或某些严格的2D问题，你肯定需要进行分层采样。

</div>


一维蒙特卡洛积分
====================================================================================================
我们的Buffon Needle示例是通过求解圆的面积与内接正方形面积的比值来计算$\pi$的一种方法：

    $$ \frac{\operatorname{area}(\mathit{circle})}{\operatorname{area}(\mathit{square})}
       = \frac{\pi}{4}
    $$

我们在内接正方形中选择了一堆随机点，并计算其中也在单位圆内的点的比例。随着添加更多的点，这个比例会趋近于$\frac{\pi}{4}$。
如果我们不知道圆的面积，仍然可以使用上述比值来求解。我们知道单位圆和内接正方形的面积比是$\frac{\pi}{4}$，
并且我们知道内接正方形的面积是$4r^2$，因此我们可以使用这两个量来得到圆的面积：

    $$ \frac{\operatorname{area}(\mathit{circle})}{\operatorname{area}(\mathit{square})}
       = \frac{\pi}{4}
    $$

    $$ \frac{\operatorname{area}(\mathit{circle})}{(2r)^2} = \frac{\pi}{4} $$

    $$ \operatorname{area}(\mathit{circle}) = \frac{\pi}{4} 4r^2 $$

    $$ \operatorname{area}(\mathit{circle}) = \pi r^2 $$

我们选择半径为$r = 1$的圆，得到：

    $$ \operatorname{area}(\mathit{circle}) = \pi $$

<div class='together'>
我们上面的工作既可以用来求解$\pi$，也可以用来求解圆的面积：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <stdlib.h>

    int main() {
        int N = 100000;
        int inside_circle = 0;
        for (int i = 0; i < N; i++) {
            auto x = random_double(-1,1);
            auto y = random_double(-1,1);
            if (x*x + y*y < 1)
                inside_circle++;
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "Estimated area of unit circle = " << (4.0 * inside_circle) / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [estunitcircle]: <kbd>[pi.cc]</kbd> 估算单位圆的面积]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double_range;

    fn main() {
        const N: usize = 100000;
        let mut inside_circle = 0;
        (0..N).for_each(|_| {
            let x = random_double_range(-1.0, 1.0);
            let y = random_double_range(-1.0, 1.0);
            if x * x + y * y < 1.0 {
                inside_circle += 1;
            }
        });
        println!("Estimated area of unit circle: {:.12}", 4.0 * inside_circle as f64 / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>


期望值
--------------
让我们退后一步，更加一般地思考一下我们的蒙特卡洛算法。

假设我们有以下内容：

1. 一个包含成员 $x_i$ 的值列表 $X$：

    $$ X = (x_0, x_1, ..., x_{N-1})  $$

2. 一个连续函数 $f(x)$，它接受列表中的成员：

    $$ y_i = f(x_i) $$

3. 一个以列表 $X$ 为输入，产生列表 $Y$ 为输出的函数 $F(X)$：

    $$ Y = F(X) $$

4. 输出列表 $Y$ 的成员为 $y_i$：

    $$ Y = (y_0, y_1, ..., y_{N-1}) = (f(x_0), f(x_1), ..., f(x_{N-1})) $$

如果我们假设上述所有条件成立，那么我们可以通过以下方式求解列表 $Y$ 的算术平均值，即平均值：

    $$ \operatorname{average}(Y) = E[Y] = \frac{1}{N} \sum_{i=0}^{N-1} y_i $$
    $$ = \frac{1}{N} \sum_{i=0}^{N-1} f(x_i) $$
    $$ = E[F(X)] $$

其中 $E[Y]$ 被称为 $Y$ 的**期望值**。如果 $x_i$ 的值是从连续区间 $[a,b]$ 中随机选择的，
使得对于所有的 $i$，$ a \leq x_i \leq b $，
那么 $E[F(X)]$ 将近似于连续函数 $f(x')$ 在相同区间 $ a \leq x' \leq b $ 上的平均值。

    $$ E[f(x') | a \leq x' \leq b] \approx E[F(X) | X =
        \{\small x_i | a \leq x_i \leq b \normalsize \} ] $$
    $$ \approx E[Y = \{\small y_i = f(x_i) | a \leq x_i \leq b \normalsize \} ] $$

    $$ \approx \frac{1}{N} \sum_{i=0}^{N-1} f(x_i) $$

如果我们取样本数 $N$ 并将 $N$ 趋近于无穷大，那么我们得到以下结果：

    $$ E[f(x') | a \leq x' \leq b]  = \lim_{N \to \infty} \frac{1}{N} \sum_{i=0}^{N-1} f(x_i) $$

在连续区间 $[a,b]$ 内，连续函数 $f(x')$ 的期望值可以通过在该区间内求和无限多个随机点来完全表示。
随着这些点的数量趋近于无穷大，输出的平均值趋近于准确答案。这就是蒙特卡洛算法。

随机取样并不是求解区间上的期望值的唯一方法。我们还可以选择采样点的位置。如果我们在区间 $[a,b]$ 上有 $N$ 个样本点，
我们可以选择等间距地分布这些点：

    $$ x_i = a + i \Delta x $$
    $$ \Delta x = \frac{b - a}{N} $$

然后求解它们的期望值：

    $$ E[f(x') | a \leq x' \leq b] \approx \frac{1}{N} \sum_{i=0}^{N-1} f(x_i)
        \Big|_{x_i = a + i \Delta x} $$
    $$ E[f(x') | a \leq x' \leq b] \approx \frac{\Delta x}{b - a} \sum_{i=0}^{N-1} f(x_i)
        \Big|_{x_i = a + i \Delta x} $$
    $$ E[f(x') | a \leq x' \leq b] \approx \frac{1}{b - a} \sum_{i=0}^{N-1} f(x_i) \Delta x
        \Big|_{x_i = a + i \Delta x} $$

将 $N$ 趋近于无穷大：

    $$ E[f(x') | a \leq x' \leq b] = \lim_{N \to \infty} \frac{1}{b - a} \sum_{i=0}^{N-1}
        f(x_i) \Delta x \Big|_{x_i = a + i \Delta x} $$

这当然就是一个常规的积分：

    $$ E[f(x') | a \leq x' \leq b] = \frac{1}{b - a} \int_{a}^{b} f(x) dx $$

如果你还记得你的微积分课程，函数的积分就是该区间下曲线下的面积：

    $$ \operatorname{area}(f(x), a, b) = \int_{a}^{b} f(x) dx $$

因此，区间上的平均值与该区间中曲线下的面积密切相关。

    $$  E[f(x) | a \leq x \leq b] = \frac{1}{b - a} \cdot \operatorname{area}(f(x), a, b) $$

函数的积分和蒙特卡洛采样都可以用来求解特定区间上的平均值。虽然积分通过对区间的无限多个无穷小切片求和来求解平均值，
但蒙特卡洛算法通过求解区间内不断增加的随机采样点的总和来近似相同的平均值。
计算落在对象内部的点的数量并不是衡量其平均值或面积的唯一方法。积分也是一种常用的数学工具。
如果问题存在闭合形式，积分通常是最自然和清晰的表达方式。

我认为一些例子会有所帮助。


积分 x²
---------------
让我们来看一个经典的积分：

    $$ I = \int_{0}^{2} x^2 dx $$

我们可以使用积分来求解：

    $$ I = \frac{1}{3} x^3 \Big|_{0}^{2} $$
    $$ I = \frac{1}{3} (2^3 - 0^3) $$
    $$ I = \frac{8}{3} $$

或者，我们可以使用蒙特卡洛方法来求解积分。在计算机科学的符号表示中，我们可以写成：

    $$ I = \operatorname{area}( x^2, 0, 2 ) $$

我们还可以写成：

    $$  E[f(x) | a \leq x \leq b] = \frac{1}{b - a} \cdot \operatorname{area}(f(x), a, b) $$
    $$ \operatorname{average}(x^2, 0, 2) = \frac{1}{2 - 0} \cdot \operatorname{area}( x^2, 0, 2 ) $$
    $$ \operatorname{average}(x^2, 0, 2) = \frac{1}{2 - 0} \cdot I $$
    $$ I = 2 \cdot \operatorname{average}(x^2, 0, 2) $$

<div class='together'>
蒙特卡洛方法的实现：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <stdlib.h>

    int main() {
        int a = 0;
        int b = 2;
        int N = 1000000;
        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            auto x = random_double(a, b);
            sum += x*x;
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "I = " << (b - a) * (sum / N) << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-xsq-1]: <kbd>[integrate_x_sq.cc]</kbd> 积分 x^2]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double_range;

    fn main() {
        const A: f64 = 0.0;
        const B: f64 = 2.0;
        const N: usize = 1000000;
        let mut sum = 0.0;
        (0..N).for_each(|_| {
            let x = random_double_range(A, B);
            sum += x * x;
        });
        println!("I = {:.12}", (B - A) * sum / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
正如预期的那样，这个方法得到的结果与积分得到的准确答案大致相同，即 $I = 8/3$。你可能会指出这个例子并说，
实际上积分比蒙特卡洛方法要简单得多。对于函数 $f(x) = x^2$ 来说，这可能是正确的，但存在许多函数，
对于这些函数来说，使用蒙特卡洛方法求解可能比积分更简单，比如 $f(x) = sin^5(x)$。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        for (int i = 0; i < N; i++) {
            auto x = random_double(a, b);
            sum += pow(sin(x), 5.0);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-sin5]: 积分 sin^5]

</div>

<div class='together'>
我们还可以使用蒙特卡洛算法来处理无法进行解析积分的函数，比如 $f(x) = \ln(\sin(x))$。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    for (int i = 0; i < N; i++) {
        auto x = random_double(a, b);
        sum += log(sin(x));
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-ln-sin]: 积分 ln(sin)]

</div>

在图形学中，我们经常遇到一些可以明确写出但具有复杂解析积分的函数，或者经常遇到一些可以进行计算但无法明确写出的函数，
而且我们经常会遇到一些只能以概率方式进行评估的函数。第一、二本书中的 `ray_color` 函数就是一个只能以概率方式确定的函数的例子。
我们无法知道从任意给定位置在所有方向上能看到什么颜色，但我们可以统计估计从一个特定位置、一个特定方向上能看到的颜色。


密度函数
------------------
我们在前两本书中编写的`ray_color`函数，虽然简洁优雅，但存在一个相当**严重**的问题。小的光源会产生太多的噪点。
这是因为我们的均匀采样，而没有足够频繁地对这些光源进行采样。只有当光线向它们散射时，才会对光源进行采样，
但对于小的光源或远离的光源，这种情况可能不太可能发生。如果背景颜色是黑色，那么场景中真正的光源只来自于实际放置在场景中的灯光。
在表面上，可能有两条相交的光线，一条随机反射到光源，一条没有。反射到光源的光线将呈现出非常明亮的颜色。
反射到其他地方的光线将呈现出非常暗的颜色。这两种强度应该位于中间某处。如果我们将这两条光线都引导向光源，
我们可以减轻这个问题，但这将导致场景过于明亮。

对于给定的光线，我们通常从相机开始，穿过场景，最终到达光源。但是想象一下，如果我们从光源开始追踪同样的光线，
穿过场景，最终到达相机。这条光线将以较高的强度开始，并且在场景中的每次反弹中逐渐失去能量。
最终，它将到达相机，经过各种表面的反射后变暗并着色。现在，想象一下，如果这条光线被迫尽快朝相机反弹，
它将显得过于明亮，因为它没有经过连续的反弹而变暗。这类似于向光源发送更多的随机样本。
这将在很大程度上解决我们在亮像素旁边有暗像素的问题，但这将使得**所有**像素都变亮。

我们可以通过降低这些样本的权重来消除这种不准确性，以调整过采样的影响。我们如何进行这种调整呢？
首先，我们需要了解**概率密度函数**的概念。但要理解**概率密度函数**的概念，我们首先需要知道什么是**密度函数**。

**密度函数**只是直方图的连续版本。下面是来自维基百科直方图页面的一个示例直方图：

  ![Figure [histogram]: 直方图示例](../images/fig-3.03-histogram.jpg)

如果我们的数据源中有更多的项，那么每个项的频率会增加，但每个箱子的数量保持不变。
如果我们将数据分成更多的箱子，我们将有更多的箱子，但每个箱子中的每个项的频率会降低。
如果我们将箱子的数量提高到无穷大，我们将有无限多个零频率的箱子。为了解决这个问题，
我们将用**离散密度函数**替换我们的直方图，**离散密度函数**与**离散函数**的区别在于，
它将y轴归一化为总数的分数或百分比，即密度，而不是每个箱子的总计数。从**离散函数**转换为**离散密度函数**非常简单：

    $$ \text{第i个箱子的密度} = \frac{\text{第i个箱子中的项数}}
                                      {\text{总项数}} $$

一旦我们有了**离散密度函数**，我们就可以通过将离散值转换为连续值来将其转换为**密度函数**。

    $$ \text{箱子密度} = \frac{(\text{高度在}H\text{和}H'\text{之间的树的比例})}
                            {(H-H')} $$

因此，**密度函数**是一个连续的直方图，其中所有的值都相对于总数进行了归一化。
如果我们想要知道特定树的高度，我们可以创建一个**概率函数**，告诉我们我们的树在特定箱子中的可能性有多大。

    $$ \text{第i个箱子的概率} = \frac{\text{第i个箱子中的项数}}
                                          {\text{总项数}} $$

如果我们将我们的**概率函数**和（连续的）**密度函数**结合起来，我们可以将其解释为树高度的统计预测器：

    $$ \text{随机树的高度在} H \text{和} H' \text{之间的概率} =
        \text{箱子密度}\cdot(H-H') $$

事实上，通过这个连续的概率函数，我们现在可以说任何给定的树的高度有多大可能落在任意跨越多个箱子的范围内。
这就是**概率密度函数**（以下简称**PDF**）。简而言之，**PDF**是一个连续函数，可以进行积分，以确定一个积分上的结果有多大可能性。


构建一个概率密度函数（PDF）
-------------------
让我们创建一个PDF并通过实例来建立直觉。我们将使用以下函数：

  ![Figure [linear-pdf]: A linear PDF](../images/fig-3.04-linear-pdf.jpg)

这个函数是做什么的呢？我们知道，PDF只是一个连续函数，用于定义任意值范围的可能性。这个函数$p(r)$在0到2之间受限，
并且在该区间上线性增加。
因此，如果我们将这个函数作为PDF来生成一个随机数，那么接近零的数字出现的概率将小于接近二的数字出现的概率。

PDF $p(r)$是一个线性函数，从$r=0$开始，单调递增到$r=2$时达到最高点$p(2)$。$p(2)$的值是多少？$p(r)$的值是多少？
也许$p(2)$等于2？PDF从0线性增加到2，所以猜测$p(2)$的值为2似乎是合理的。至少看起来它不可能是0。

请记住，PDF是一个概率函数。我们将PDF限制在范围[0,2]内。PDF表示概率密度函数，用于表示概率列表的连续密度函数。
如果我们知道列表中的所有内容都包含在0和2之间，我们可以说在0和2之间获得值的概率为100%。因此，曲线下的面积必须等于1：

    $$ \operatorname{area}(p(r), 0, 2) = 1 $$

所有线性函数都可以表示为一个常数项乘以一个变量。

    $$ p(r) = C \cdot r $$

我们需要解出$C$的值。我们可以使用积分来逆推。

    $$ 1 = \operatorname{area}(p(r), 0, 2) $$
    $$ = \int_{0}^{2} C \cdot r dr $$
    $$ = C \cdot \int_{0}^{2} r dr $$
    $$ = C \cdot \frac{r^2}{2} \Big|_{0}^{2} $$
    $$ = C ( \frac{2^2}{2} - \frac{0}{2} ) $$
    $$ C = \frac{1}{2} $$

这给出了$p(r) = r/2$的PDF。就像直方图一样，我们可以对区域进行求和（积分）以确定$r$在某个区间$[x_0,x_1]$内的概率：

    $$ \operatorname{Probability} (r | x_0 \leq r \leq x_1 )
       = \operatorname{area}(p(r), x_0, x_1)
    $$

    $$ \operatorname{Probability} (r | x_0 \leq r \leq x_1 ) = \int_{x_0}^{x_1}  \frac{r}{2} dr $$

为了确认你的理解，你可以对区域$r=0$到$r=2$进行积分，你应该得到一个概率为1。

在研究了足够长时间的PDF之后，你可能会开始将PDF称为变量$r$取值为$x$的概率，即$p(r=x)$。但请不要这样做。
对于连续函数来说，变量取特定值的概率总是为零。PDF只能告诉你变量落在给定区间内的概率。
如果你检查的区间是一个单一的值，那么PDF将始终返回零概率，因为它的“bin”是无限细的（宽度为零）。
以下是这个事实的一个简单数学证明：

    $$ \operatorname{Probability} (r = x) = \int_{x}^{x}  p(r) dr $$
    $$ = P(r) \Big|_{x}^{x} $$
    $$ = P(x) - P(x) $$
    $$ = 0 $$

计算围绕$x$的区域的概率可能不为零：

    $$ \operatorname{Probability} (r | x - \Delta x < r < x + \Delta x ) =
         \operatorname{area}(p(r), x - \Delta x, x + \Delta x) $$
    $$ = P(x + \Delta x) - P(x - \Delta x) $$


选择样本
--------------------
如果我们有一个关心的函数的概率密度函数（PDF），那么我们就知道函数返回一个值落在任意区间内的概率。
我们可以利用这一点来确定我们应该采样的位置。记住，我们最初的目标是确定如何采样场景，以避免在非常亮的像素旁边出现非常暗的像素。
如果我们有场景的概率密度函数，我们可以在不使图像过度亮的情况下，通过概率地将样本导向光源。
我们已经说过，如果我们将样本导向光源，那么图像将变得不准确地过亮。
我们需要找出如何在不引入这种不准确性的情况下导向样本，稍后会解释这一点，但现在我们将专注于在有PDF的情况下生成样本。
我们如何使用PDF生成随机数？为此，我们需要一些更多的工具。不要担心，这不会无休止地进行下去！

<div class='together'>
我们的随机数生成器`random_double()`生成一个介于0和1之间的随机双精度数。该数生成器在0和1之间均匀分布，因此0和1之间的任何数的概率相等。
如果我们的PDF在一个区域上是均匀的，比如$[0,10]$，那么我们可以通过以下方式轻松地生成这个均匀PDF的完美样本：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    10.0 * random_double()
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

这是一个简单的情况，但我们关心的绝大多数情况都是非均匀的。我们需要找到一种方法将均匀随机数生成器转换为非均匀随机数生成器，其中分布由PDF定义。
我们假设存在一个函数$f(d)$，它接受均匀输入并产生由PDF加权的非均匀分布。我们只需要找到一种方法来解出$f(d)$。

对于上面给定的PDF，其中$p(r) = \frac{r}{2}$，随机样本的概率在2附近要高于0。在1.8和2.0之间获得一个数字的概率要比在0.0和0.2之间获得一个数字的概率大。
如果我们暂时放下数学帽子，戴上计算机科学帽子，也许我们可以找到一种巧妙的方法来划分PDF。
我们知道在2附近的概率要高于0附近的概率，但是哪个值将概率分成一半？
哪个值使得随机数有50%的概率高于它，有50%的概率低于它？哪个$x$满足以下方程：

    $$ 50\% = \int_{0}^{x}  \frac{r}{2} dr  = \int_{x}^{2}  \frac{r}{2} dr $$

解得：

    $$ 0.5 = \frac{r^2}{4} \Big|_{0}^{x} $$
    $$ 0.5 = \frac{x^2}{4} $$
    $$ x^2 = 2 $$
    $$ x = \sqrt{2} $$

作为一个粗略的近似，我们可以创建一个函数`f(d)`，它以`double d = random_double()`作为输入。如果`d`小于（或等于）0.5，
它会在$[0,\sqrt{2}]$范围内生成一个均匀数，如果`d`大于0.5，它会在$[\sqrt{2}, 2]$范围内生成一个均匀数。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    double f(double d)
    {
        if (d <= 0.5)
            return sqrt(2.0) * random_double();
        else
            return sqrt(2.0) + (2 - sqrt(2.0)) * random_double();
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [crude-approx]: 一个粗略的、一阶近似的非均匀PDF]

<div class='together'>
虽然我们最初的随机数生成器是从0到1均匀分布的：

   ![图 [uniform-dist]: 均匀分布](../images/fig-3.05-uniform-dist.jpg)

</div>

<div class='together'>
我们的新的、粗略的$\frac{r}{2}$的近似是非均匀的（但只是近似）：

    ![图 [approx-f]: r/2的非均匀分布](../images/fig-3.06-nonuniform-dist.jpg)

</div>

我们已经对上面的积分有了解析解，所以我们可以很容易地解出50%的值。但我们也可以通过实验解出这个50%的值。
对于那些我们无法或不想解析求解积分的函数，我们可以得到一个接近真实值的实验结果。让我们来看一个函数：

    $$ p(x) = e^{\frac{-x}{2 \pi}} sin^2(x) $$

<div class='together'>
它看起来有点像这样：

    ![图 [exp-sin2]: 我们不想解析求解的函数](../images/fig-3.07-exp-sin2.jpg)

</div>

<div class='together'>
此时，您应该熟悉如何实验性地求解曲线下的面积。我们将使用现有的代码，并稍作修改，以获得50%值的估计。我们想要解决的是给出半个总面积的$x$值。
当我们沿着解决N个样本的总和时，我们还将每个单独的样本与其`p(x)`值一起存储。在解决了总和之后，我们将对样本进行排序，并将它们相加，直到达到总和的一半。
例如，从$0$到$2\pi$：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <algorithm>
    #include <vector>
    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <cmath>
    #include <stdlib.h>

    struct sample {
        double x;
        double p_x;
    };

    bool compare_by_x(const sample& a, const sample& b) {
        return a.x < b.x;
    }

    int main() {
        unsigned int N = 10000;
        double sum = 0.0;

        // iterate through all of our samples
        std::vector<sample> samples;
        for (unsigned int i = 0; i < N; i++) {
            // Get the area under the curve
            auto x = random_double(0, 2*pi);
            auto sin_x = sin(x);
            auto p_x = exp(-x / (2*pi)) * sin_x * sin_x;
            sum += p_x;
            // store this sample
            sample this_sample = {x, p_x};
            samples.push_back(this_sample);
        }

        // Sort the samples by x
        std::sort(samples.begin(), samples.end(), compare_by_x);

        // Find out the sample at which we have half of our area
        double half_sum = sum / 2.0;
        double halfway_point = 0.0;
        double accum = 0.0;
        for (unsigned int i = 0; i < N; i++){
            accum += samples[i].p_x;
            if (accum >= half_sum) {
                halfway_point = samples[i].x;
                break;
            }
        }

        std::cout << std::fixed << std::setprecision(12);
        std::cout << "Average = " << sum / N << '\n';
        std::cout << "Area under curve = " << 2 * pi * sum / N << '\n';
        std::cout << "Halfway = " << halfway_point << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [est-halfway]: <kbd>[estimate_halfway.cc]</kbd> 估计函数的50%点]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::{
        random_double_range, self,
    };

    struct Sample {
        pub x: f64,
        pub p_x: f64,
    }

    fn compare_by_x(a: &Sample, b: &Sample) -> std::cmp::Ordering {
        a.x.partial_cmp(&b.x).unwrap()
    }

    fn main() {
        const N: usize = 10000;
        let mut sum = 0.0;

        // iterate through all of our samples
        let mut samples = Vec::new();
        (0..N).for_each(|_| {
            // Get the area under the curve
            let x = random_double_range(0.0, 2.0 * rtweekend::PI);
            let sin_x = x.sin();
            let p_x = (-x / (2.0 * rtweekend::PI)).exp() * sin_x * sin_x;
            sum += p_x;
            // store this sample
            samples.push(Sample { x, p_x });
        });

        // Sort the samples by x
        samples.sort_by(compare_by_x);

        // Find out the sample at which we have half of our area
        let half_sum = sum / 2.0;
        let mut halfway_point = 0.0;
        let mut accum = 0.0;
        for sample in samples.iter() {
            accum += sample.p_x;
            if accum >= half_sum {
                halfway_point = sample.x;
                break;
            }
        }

        println!("Average = {:.12}", sum / N as f64);
        println!("Area under curve = {:.12}", 2.0 * rtweekend::PI * sum / N as f64);
        println!("Halfway = {:.12}", halfway_point);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
这段代码片段与之前的代码相比并没有太大的不同。我们仍然解决了一个区间（从0到$2\pi$）上的总和。
只是这一次，我们还通过输入和输出将所有样本存储和排序。
我们使用这些样本来确定它们在整个区间上的子总和达到总和的一半的点。一旦我们知道前$j$个样本的总和达到总和的一半，
我们就知道第$j$个$x$大致对应于我们的中点：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Average = 0.314686555791
    Area under curve = 1.977233943713
    Halfway = 2.016002314977
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

如果您解出从$0$到$2.016$和从$2.016$到$2\pi$的积分，您应该得到几乎完全相同的结果。

我们有一种方法来解决将PDF分成一半的中点。如果我们愿意，我们可以使用这个方法创建一个嵌套的二进制分区的PDF：

  1. 解决PDF的中点
  2. 递归进入较小的一半，重复步骤1
  3. 递归进入较大的一半，重复步骤1

在一个合理的深度停止，比如6-10。正如您可以想象的那样，这可能非常耗费计算资源。上面的代码的计算瓶颈可能是对样本进行排序。
一个朴素的排序算法的算法复杂度可能是$\mathcal{O}(\mathbf{n^2})$时间，这是非常昂贵的。
幸运的是，标准库中包含的排序算法通常更接近$\mathcal{O}(\mathbf{n\log{}n})$时间，但这仍然可能非常昂贵，特别是对于数百万或数十亿个样本。
但这将产生相当不错的非均匀分布的非均匀数。这种分而治之的方法用于生成非均匀分布在实践中相当常见，尽管有比简单的二进制分区更高效的方法。
如果您有一个任意函数作为分布的PDF，您将需要研究_梅特罗波利斯-哈斯廷斯算法_。


近似分布
---------------------------
在建立一些概念的过程中，我们进行了大量的数学推导和工作。现在让我们回到最初的概率密度函数（PDF）。
对于没有明确概率的区间，我们假设概率密度函数为零。因此，对于本章开头的例子，$p(r) = 0$，对于 $r \notin [0,2]$。
我们可以将 $p(r)$ 用分段函数的形式重新表示：

    $$ p(r)=\begin{cases}
            0           & r < 0           \\
            \frac{r}{2} & 0 \leq r \leq 2 \\
            0           & 2 < r           \\
       \end{cases}
    $$

如果你考虑一下我们在前一节中要做的事情，很多数学都围绕着从零开始的**累积**面积（或**累积**概率）展开。
对于函数

    $$ f(x) = e^{\frac{-x}{2 \pi}} sin^2(x)  $$

我们关心的是从 $0$ 到 $2\pi$（100%）的累积概率和从 $0$ 到 $2.016$（50%）的累积概率。
我们可以将这个概念推广到一个重要的术语，即**累积分布函数**（CDF），定义如下：

    $$ P(x) =  \int_{-\infty}^{x}  p(x') dx' $$

或者，

    $$ P(x) = \operatorname{area}(p(x'), -\infty, x) $$

它表示从$-\infty$开始的**累积**概率量。我们将积分中的变量从 $x$ 改为 $x'$，是因为根据微积分规则，
如果你不确定它的含义，不用担心，你可以将它视为相同的。如果我们对上述积分进行计算，我们得到分段函数 $P(r)$：

    $$ P(r)=\begin{cases}
           0             & r < 0           \\
           \frac{r^2}{4} & 0 \leq r \leq 2 \\
           1             & 2 < r           \\
       \end{cases}
    $$

**概率密度函数**（PDF）是解释一个数字区间被选择的可能性的概率函数。
**累积分布函数**（CDF）是解释比其输入更小的所有数字被选择的分布函数。
要从 PDF 得到 CDF，你需要从 $-\infty$ 积分到 $x$，但要从 CDF 得到 PDF，你只需要取导数：

    $$ p(x) = \frac{d}{dx}P(x) $$

如果我们在 $r = 1.0$ 处评估 CDF $P(r)$，我们得到：

    $$ P(1.0) = \frac{1}{4} $$

这表示**从我们的 PDF 中随机选择的变量有 25% 的概率小于等于 1.0**。
我们想要一个函数 $f(d)$，它接受一个介于 0 和 1 之间的均匀分布（即 `f(random_double())`），
并根据具有 CDF $P(x) = \frac{x^2}{4}$ 的分布返回一个随机值。
我们还不知道函数 $f(d)$ 的解析形式，但我们知道它返回的结果中有 25% 应该小于 1.0，75% 应该大于 1.0。
同样地，我们知道其中 50% 应该小于 $\sqrt{2}$，50% 应该大于 $\sqrt{2}$。
如果 $f(d)$ 单调递增，那么我们期望 $f(0.25) = 1.0$，$f(0.5) = \sqrt{2}$。
这可以推广到找出每个可能输入的 $f(d)$：

    $$ f(P(x)) = x $$

让我们取一些更多的样本：

    $$ P(0.0) = 0 $$
    $$ P(0.5) = \frac{1}{16} $$
    $$ P(1.0) = \frac{1}{4} $$
    $$ P(1.5) = \frac{9}{16} $$
    $$ P(2.0) = 1 $$

因此，函数 $f()$ 的取值为

    $$ f(P(0.0)) = f(0) = 0 $$
    $$ f(P(0.5)) = f(\frac{1}{16}) = 0.5 $$
    $$ f(P(1.0)) = f(\frac{1}{4}) = 1.0 $$
    $$ f(P(1.5)) = f(\frac{9}{16}) = 1.5 $$
    $$ f(P(2.0)) = f(1) = 2.0 $$

我们可以使用这些中间值并在它们之间进行插值来近似 $f(d)$：

    ![Figure [approx f]: 近似非均匀分布 f()](../images/fig-3.08-approx-f.jpg)

如果你无法解析求解 PDF，那么你也无法解析求解 CDF。毕竟，CDF 只是 PDF 的积分。
然而，你仍然可以创建一个近似 PDF 的分布。如果你从你想要得到 PDF 的随机函数中取一堆样本，
你可以通过获取样本的直方图然后转换为 PDF 来近似 PDF。或者，你可以像上面那样对所有样本进行排序。

仔细观察等式：

    $$ f(P(x)) = x $$

这意味着 $f()$ 只是撤销了 $P()$ 的操作。因此，$f()$ 是反函数：

    $$ f(d) = P^{-1}(x) $$

对于我们的目的，如果我们有 PDF $p()$ 和累积分布函数 $P()$，我们可以使用这个"反函数"和一个随机数来得到我们想要的结果：

    $$ f(d) = P^{-1} (\operatorname{random_double}()) $$

对于我们的 PDF $p(r) = \frac{r}{2}$ 和相应的 $P(r)$，我们需要计算 $P(r)$ 的反函数。如果我们有

    $$ y = \frac{r^2}{4} $$

我们通过解关于 $y$ 的方程来得到反函数：

    $$ r = \sqrt{4y} $$

这意味着我们的 CDF 的反函数定义为

    $$ P^{-1}(r) = \sqrt{4y} $$

因此，我们的具有密度 $p(r)$ 的随机数生成器可以使用以下公式创建：

    $$ f(d) = \sqrt{4\cdot\operatorname{random_double}()} $$

请注意，这个公式的取值范围是从 0 到 2，与我们的期望一致，如果我们检查我们的工作，
我们将 `random_double()` 替换为 $1/4$ 得到 1，也将其替换为 $1/2$ 得到 $\sqrt{2}$，正如我们所期望的那样。


重要性采样
--------------------
现在你应该对如何使用分析概率密度函数（PDF）生成具有该分布的随机数有了相当好的理解。
我们回到最初的积分问题，并尝试使用几个不同的PDF来更好地理解：

    $$ I = \int_{0}^{2} x^2 dx $$

<div class='together'>
上次我们尝试解决这个积分时，我们使用了蒙特卡洛方法，从区间$[0, 2]$均匀采样。当时我们并不知道，
但我们隐式地使用了一个在$[0, 2]$范围内均匀分布的PDF。这意味着我们使用的PDF是$1/2$，
对应的累积分布函数（CDF）是$P(x) = x/2$，因此$f(d) = 2d$。有了这个信息，我们可以将这个均匀分布的PDF显式地表示出来：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <stdlib.h>


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
    double f(double d) {
        return 2.0 * d;
    }

    double pdf(double x) {
        return 0.5;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

    int main() {
        int N = 1000000;
        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto x = f(random_double());
            sum += x*x / pdf(x);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        }
        std::cout << std::fixed << std::setprecision(12);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        std::cout << "I = " << sum / N << '\n';
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-xsq-2]: <kbd>[integrate_x_sq.cc]</kbd> $x^2$的显式均匀分布PDF]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double;

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
    fn f(d: f64) -> f64 {
        2.0 * d
    }

    fn pdf(_x: f64) -> f64 {
        0.5
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

    fn main() {
        const N: usize = 1000000;
        let mut sum = 0.0;
        (0..N).for_each(|_| {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
            let x = f(random_double());
            sum += x * x / pdf(x);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
        });
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        println!("I = {:.12}", sum / N as f64);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

有几个重要的事情需要强调。每个$x$的值代表分布$[0, 2]$中的一个样本点。我们使用函数$f$从该分布中随机选择样本。
以前，我们将区间上的平均值（`sum / N`）乘以区间的长度（`b - a`）来得到最终答案。但在这里，我们不需要乘以区间长度，
也就是说，我们不再需要将平均值乘以2。

我们需要考虑到$x$的PDF的非均匀性。如果不考虑这种非均匀性，将会在场景中引入偏差。事实上，
这种偏差是我们图像过亮的原因——如果我们考虑到非均匀性，我们将得到准确的结果。PDF会将样本“引导”到分布的特定部分，
这将使我们更快地收敛，但代价是引入偏差。为了消除这种偏差，我们需要在采样频率较高的地方降低权重，在采样频率较低的地方增加权重。
对于我们的新的非均匀随机数生成器，PDF定义了我们在特定部分采样的多少。因此，权重函数应该与$1/\mathit{pdf}$成比例。
实际上，它确切地等于$1/\mathit{pdf}$。这就是为什么我们将`x*x`除以`pdf(x)`的原因。

我们可以尝试使用线性PDF $p(r) = \frac{r}{2}$ 来解决这个积分问题，我们已经能够求解其CDF和逆函数。
为此，我们只需要将函数$f = \sqrt{4d}$和PDF $pdf = \frac{x}{2}$ 替换掉。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
    double f(double d) {
        return sqrt(4.0 * d);
    }

    double pdf(double x) {
        return x / 2.0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

    int main() {
        int N = 1000000;
        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            auto x = f(random_double());
            sum += x*x / pdf(x);
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "I = " << sum / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-xsq-3]: <kbd>[integrate_x_sq.cc]</kbd> 使用线性PDF积分$x^2$]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double;

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
    fn f(d: f64) -> f64 {
        (4.0 * d).sqrt()
    }

    fn pdf(x: f64) -> f64 {
        x / 2.0
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

    fn main() {
        const N: usize = 1000000;
        let mut sum = 0.0;
        (0..N).for_each(|_| {
            let x = f(random_double());
            sum += x * x / pdf(x);
        });
        println!("I = {:.12}", sum / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果你比较了均匀PDF和线性PDF的运行结果，你可能会发现线性PDF收敛得更快。如果你仔细思考一下，线性PDF可能更好地逼近了二次函数，
所以你会期望它收敛得更快。如果是这样的话，那么我们应该尝试使PDF与被积函数匹配，将PDF变成一个二次函数：

    $$ p(r)=\begin{cases}
            0           & r < 0           \\
            C \cdot r^2 & 0 \leq r \leq 2 \\
            0           & 2 < r           \\
       \end{cases}
    $$

像线性PDF一样，我们通过在区间上积分使得常数$C$等于1：

    $$ 1 = \int_{0}^{2} C \cdot r^2 dr $$
    $$ = C \cdot \int_{0}^{2} r^2 dr $$
    $$ = C \cdot \frac{r^3}{3} \Big|_{0}^{2} $$
    $$ = C ( \frac{2^3}{3} - \frac{0}{3} ) $$
    $$ C = \frac{3}{8} $$

这给出了：

    $$ p(r)=\begin{cases}
            0           & r < 0           \\
            \frac{3}{8} r^2 & 0 \leq r \leq 2 \\
            0           & 2 < r           \\
       \end{cases}
    $$

并且我们得到相应的CDF：

    $$ P(r) = \frac{r^3}{8} $$

以及

    $$ P^{-1}(x) = f(d) = 8d^\frac{1}{3} $$

<div class='together'>
对于只有一个样本的情况，我们有：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
    double f(double d) {
        return 8.0 * pow(d, 1.0/3.0);
    }

    double pdf(double x) {
        return (3.0/8.0) * x*x;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

    int main() {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        int N = 1;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            auto x = f(random_double()));
            sum += x*x / pdf(x);
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "I = " << sum / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-xsq-5]: <kbd>[integrate_x_sq.cc]</kbd> 积分$x^2$，最终版本]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double;

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
    fn f(d: f64) -> f64 {
        8.0 * d.powf(1.0 / 3.0)
    }

    fn pdf(x: f64) -> f64 {
        3.0 / 8.0 * x * x
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

    fn main() {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        const N: usize = 1;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
        let mut sum = 0.0;
        (0..N).for_each(|_| {
            let x = f(random_double());
            sum += x * x / pdf(x);
        });
        println!("I = {:.12}", sum / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

这总是返回精确的答案。说实话，这感觉有点像魔法。

</div>

非均匀PDF会将更多的样本引导到PDF较大的部分，而较少的样本引导到PDF较小的部分。通过这种采样，我们预期在PDF较大的部分噪声较少，
在PDF较小的部分噪声较多。如果我们选择一个在场景中噪声较大的部分具有较高PDF值的PDF，并且在场景中噪声较小的部分具有较低PDF值的PDF，
我们将能够用较少的样本减少场景的总噪声。这意味着我们将能够比使用均匀PDF更快地收敛到正确的场景。
实际上，我们将样本引导到更重要的分布部分。这就是为什么通常将使用精心选择的非均匀PDF称为**重要性采样**。

在所有给定的示例中，我们始终收敛到了正确的答案$8/3$。当使用均匀PDF和“正确”的PDF（即$f(d)=8d^{\frac{1}{3}}$）时，我们得到了相同的答案。
虽然它们都收敛到了相同的答案，但均匀PDF需要更长的时间。毕竟，我们只需要从与积分完全匹配的PDF中获得一个样本。
这是有道理的，因为我们选择更频繁地采样分布的重要部分，而均匀PDF只是均匀地采样整个分布，没有考虑到重要性。

实际上，你创建的任何PDF都将最终收敛到正确的答案。这只是蒙特卡洛算法的又一个强大之处。
即使是我们通过求解50%的值并将分布分为两半的朴素PDF：$[0, \sqrt{2}]$和$[\sqrt{2}, 2]$。那个PDF也会收敛。
希望你对为什么这个PDF会比纯均匀PDF收敛得更快有直观的理解，但比线性PDF（即$f(d) = \sqrt{4d}$）收敛得更慢。

完美的重要性采样只有在我们已经知道答案时才可能实现（我们通过解析地积分$p$得到了$P$），但这是一个很好的练习，以确保我们的代码工作正常。

让我们回顾一下蒙特卡洛光线追踪器的主要概念：

  1. 你有一个在某个区域$[a,b]$上的$f(x)$的积分
  2. 你选择一个在$[a,b]$上非零且非负的PDF $p$
  3. 你对大量的$\frac{f(r)}{p(r)}$取平均值，其中$r$是具有PDF $p$的随机数。

任何选择的PDF $p$都将最终收敛到正确的答案，但$P$越接近$f$，收敛速度就越快。



在球面上的蒙特卡洛积分
====================================================================================================
在一维蒙特卡洛积分章节中，我们从均匀随机数开始，然后逐渐在整个章节中构建了更加复杂的产生随机数的方法，
最终形成了概率密度函数（PDF）的直觉，并学会如何使用PDF生成任意分布的随机数。

在扩展到多个维度时，所有在该章节中介绍的概念仍然适用。在接下来的内容中，我们可能需要从二维、三维甚至更高维空间中选择一个点，
然后通过一个任意的PDF对该选择进行加权。在光线追踪中，一个重要的情况是生成一个随机方向。
在前两本书中，我们通过创建一个随机向量，并在其超出单位球时将其拒绝，来生成一个随机方向。
我们重复这个过程，直到找到一个落在单位球内的随机向量。对该向量进行归一化，就得到了落在单位球上的点，从而表示一个随机方向。
这个生成样本在不符合所需空间的情况下拒绝它们的过程被称为**拒绝方法**，在文献中随处可见。
上一章介绍的方法被称为**反演方法**，因为我们反演了一个PDF。

3D空间中的每个方向都有一个与之关联的单位球上的点，并且可以通过求解从原点到该关联点的向量来生成它。
你可以将选择一个随机方向看作是选择一个受限制的二维平面上的随机点：通过将单位球映射到笛卡尔坐标系而创建的平面。
之前的方法仍然适用，但现在我们可能会在两个维度上定义一个PDF。假设我们想要在单位球的表面上进行积分：

  $$ f(\theta, \phi) = cos^2(\theta) $$

使用蒙特卡洛积分，我们只需要对 $\cos^2(\theta) / p(r)$ 进行采样，其中 $p(r)$ 现在只是 $p(direction)$。
但在这种情况下，什么是“direction”呢？我们可以基于极坐标来定义它，因此 $p$ 将是关于 $\theta$ 和 $\phi$ 的函数 $p(\theta, \phi)$。
你选择使用哪种坐标系并不重要。无论你选择哪种方式，记住PDF必须在整个表面上积分为1，并且PDF表示了被采样方向的**相对概率**。
回想一下，我们有一个用于在单位球上生成均匀随机样本的 `vec3` 函数（`random_unit_vector()`）。这些均匀样本的PDF是什么？
作为单位球上的均匀密度，它是球体的 $1/\mathit{area}$，即 $1/(4\pi)$。
如果被积函数是 $\cos^2(\theta)$，其中 $\theta$ 是与 $z$ 轴的夹角：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    double f(const vec3& d) {
        auto cosine_squared = d.z()*d.z();
        return cosine_squared;
    }

    double pdf(const vec3& d) {
        return 1 / (4*pi);
    }

    int main() {
        int N = 1000000;
        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            vec3 d = random_unit_vector();
            auto f_d = f(d);
            sum += f_d / pdf(d);
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "I = " << sum / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [main-sphereimp]: <kbd>[sphere_importance.cc]</kbd>
    在单位球上生成重要采样点]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend;
    use the_rest_of_your_life::vec3::{self, Vec3};

    fn f(d: Vec3) -> f64 {
        d.z() * d.z()
    }

    fn pdf(_d: Vec3) -> f64 {
        1.0 / (4.0 * rtweekend::PI)
    }

    fn main() {
        const N: usize = 1000000;
        let mut sum = 0.0;
        (0..N).for_each(|_| {
            let d = vec3::random_unit_vector();
            let f_d = f(d);
            sum += f_d / pdf(d);
        });
        println!("I = {:.12}", sum / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

解析解是 $\frac{4}{3} \pi$ -- 如果你还记得足够的高级数学知识，可以验证一下！上面的代码就得到了这个结果。
关键点在于所有的积分、概率和其他一切都是在单位球上进行的。在3D中表示单个方向的方式是它在单位球上的关联点。
在3D中表示一系列方向的方式是这些方向穿过的单位球上的面积。无论你称之为方向、面积还是**立体角**，它们都是同一个东西。
立体角通常是文献中使用的术语。你在一维中有弧度（r）中的 $\theta$，在二维中有立体弧度（sr）中的 $\theta$ 和 $\phi$
（单位球是一个三维对象，但其表面只有两个维度）。立体角只是角度的二维扩展。如果你对二维角度感到熟悉，那太好了！
如果不熟悉，就像我一样，想象一下一组方向在单位球上经过的区域。立体角 $\omega$ 和单位球上的投影面积 $A$ 是相同的。

  ![图 [solid-angle]: 球体的立体角/投影面积
  ](../images/fig-3.09-solid-angle.jpg)

现在让我们继续解决我们要解决的光传输方程。



光散射
====================================================================================================
在本章中，我们不会实际编写任何代码。我们只是为下一章中的大型光照变化做准备。
我们前两本书中的光线追踪程序在与表面或体积相互作用时会散射光线。光线散射是模拟光在场景中传播的最常用模型。
这可以自然地以概率方式建模。在建模光线的概率散射时有许多要考虑的因素。

反射率
-------
首先，光是否被吸收？

光被散射的概率：$A$

光被吸收的概率：$1-A$

这里的$A$代表**反射率**，在拉丁语中意为**白度**。反射率在某些学科中是一个精确的技术术语，但在所有情况下，它被用来定义某种形式的**分数反射率**。
这个**分数反射率**（或反射率）会随着颜色的变化而变化，而且（如我们为玻璃材质实现的那样）还可以随着入射方向（入射光线的方向）的变化而变化。
停下来回想一下，当我们模拟光的传播时，我们所做的就是模拟光子在空间中的运动。
如果你还记得高中物理，你应该记得每个光子都有一个与普朗克常数相关联的唯一能量和波长：

$$ E = \frac{hc}{\lambda} $$

每个单独的光子都有一点点能量，但当你把足够多的光子加在一起时，你就得到了渲染中的所有照明效果。
光子与表面或体积（或实际上与光子可以相互作用的任何东西）的吸收或散射是由物体的反射率在概率上决定的。
反射率可能会因为某些物体更有可能吸收某些波长而与颜色有关。

在大多数基于物理的渲染器中，我们会使用预定义的特定波长集合来表示光的颜色，而不是RGB。
例如，我们会用在300nm、350nm、400nm、...、700nm处进行采样的方式来替代我们的三刺激值RGB渲染器。
通过将R、G和B视为波长的特定代数混合物，其中R主要是红色波长，G主要是绿色波长，B主要是蓝色波长，我们可以扩展我们的直觉。
这是人类视觉系统的近似表示，人类视觉系统具有3组独特的色感受器，称为**锥体**，每个色感受器对不同的波长代数混合物敏感，
大致对应于RGB，但被称为长、中、短锥体（名称是根据每个锥体敏感的波长而命名的，而不是锥体的长度）。
就像颜色可以在RGB颜色空间中通过它们的强度来表示一样，颜色也可以在_LMS颜色空间_（长、中、短）中通过每组锥体的兴奋程度来表示（长、中、短）。

散射
-----------
如果光线发生散射，它将具有我们可以描述为固定角度上的概率密度函数（PDF）的方向分布。我将其称为**散射PDF**：$\operatorname{pScatter}()$。
散射PDF将随着出射方向的变化而变化：$\operatorname{pScatter}(\omega_o)$。散射PDF也可以随着**入射方向**的变化而变化：
$\operatorname{pScatter}(\omega_i, \omega_o)$。当你观察道路上的反射时，你会看到它随着观察角度（入射角）接近接近时变得像镜子一样。
散射PDF可以随着光的波长变化：$\operatorname{pScatter}(\omega_i, \omega_o, \lambda)$。一个很好的例子是棱镜将白光折射成彩虹。
最后，散射PDF还可以依赖于散射位置：$\operatorname{pScatter}(\mathbf{x}, \omega_i, \omega_o, \lambda)$。
$\mathbf{x}$只是散射位置的数学表示：$\mathbf{x} = (x, y, z)$。
物体的反射率也可以依赖于这些量：$A(\mathbf{x}, \omega_i, \omega_o, \lambda)$。

表面的颜色是通过在入射方向上对这些项进行单位半球积分来确定的：

$$ \operatorname{Color}_o(\mathbf{x}, \omega_o, \lambda) = \int_{\omega_i}
    A(\mathbf{x}, \omega_i, \omega_o, \lambda) \cdot
    \operatorname{pScatter}(\mathbf{x}, \omega_i, \omega_o, \lambda) \cdot
    \operatorname{Color}_i(\mathbf{x}, \omega_i, \lambda) $$

我们添加了一个$\operatorname{Color}_i$项。散射PDF和物体表面的反射率充当了对照点上的光的滤波器。因此，我们需要解决照射在该点上的光。
这是一个递归算法，也是我们的`ray_color`函数返回当前对象的颜色乘以下一条光线的颜色的原因。

散射PDF
-------------------
如果我们应用蒙特卡洛的基本公式，我们得到以下的统计估计：

$$ \operatorname{Color}_o(\mathbf{x}, \omega_o, \lambda) \approx \sum
    \frac{A(\, \ldots \,) \cdot
    \operatorname{pScatter}(\, \ldots \,) \cdot
    \operatorname{Color}_i(\, \ldots \,)}
    {p(\mathbf{x}, \omega_i, \omega_o, \lambda)} $$

其中$p(\mathbf{x}, \omega_i, \omega_o, \lambda)$是我们随机生成的任何出射方向的PDF。

对于Lambertian表面，我们已经隐式地为$pScatter(\, \ldots \,)$是余弦密度的特殊情况实现了这个公式。
Lambertian表面的$\operatorname{pScatter}(\, \ldots \,)$与$\cos(\theta_o)$成正比，其中$\theta_o$是相对于表面法线的角度。
让我们再次解决$C$：

$$ \operatorname{pScatter}(\mathbf{x}, \omega_i, \omega_o, \lambda) = C \cdot \cos(\theta_o) $$

所有二维PDF在整个表面上都需要积分为1（记住$\operatorname{pScatter}$是一个PDF）。
我们设置$\operatorname{pScatter}(\theta_o < 0) = 0$，这样我们就不会在地平线以下进行散射。

$$ 1 = \int_{0}^{2 \pi} \int_{0}^{\pi / 2} C \cdot cos(\theta) dA $$

要在半球上进行积分，记住在球坐标中：

$$ dA = \sin(\theta) d\theta d\phi $$

所以：

$$ 1 = C \cdot \int_{0}^{2 \pi} \int_{0}^{\pi / 2} cos(\theta) sin(\theta) d\theta d\phi $$
$$ 1 = C \cdot 2 \pi \frac{1}{2} $$
$$ 1 = C \cdot \pi $$
$$ C = \frac{1}{\pi} $$

$\cos(\theta_o)$在半球上的积分是$\pi$，所以我们需要通过$\frac{1}{\pi}$进行归一化。
散射PDF $\operatorname{pScatter}$ 只依赖于出射方向（$\omega_o$），所以我们将简化其表示为$\operatorname{pScatter}(\omega_o)$。
将所有这些放在一起，我们得到Lambertian表面的散射PDF：

$$ \operatorname{pScatter}(\omega_o) = \frac{\cos(\theta_o)}{\pi} $$

我们将假设$p(\mathbf{x}, \omega_i, \omega_o, \lambda)$等于散射PDF：

$$ p(\omega_o) = \operatorname{pScatter}(\omega_o) = \frac{\cos(\theta_o)}{\pi} $$

分子和分母相互抵消，我们得到：

$$ \operatorname{Color}_o(\mathbf{x}, \omega_o, \lambda) \approx \sum
    A(\, \ldots \,) \cdot
    \operatorname{Color}_i(\, \ldots \,) $$

<div class='together'>
这正是我们最初的`ray_color()`函数中的内容！

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        return attenuation * ray_color(scattered, depth-1, world);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

上面的处理稍微有些非标准，因为我希望相同的数学方法适用于表面和体积。如果你阅读文献，你会看到反射由**双向反射分布函数**（BRDF）定义。
它与我们的术语非常简单地相关：

$$ BRDF(\omega_i, \omega_o, \lambda) = \frac{A(\mathbf{x}, \omega_i, \omega_o, \lambda) \cdot
    \operatorname{pScatter}(\mathbf{x}, \omega_i, \omega_o, \lambda)}{\cos(\theta_o)} $$

因此，例如对于Lambertian表面，$BRDF = A / \pi$。我们的术语和BRDF之间的转换很容易。对于参与介质（体积），
我们的反射率通常称为**散射反射率**，我们的散射PDF通常称为**相位函数**。

我们在这里所做的一切只是概述了材质的Lambertian散射的PDF。然而，我们需要进行泛化，
以便我们可以在重要的方向上发送额外的光线，例如朝向光源的方向。



重要性采样的实验
====================================================================================================
在接下来的几章中，我们的目标是通过向光源发送大量额外的光线来减少图像的噪点。
假设我们可以使用一个概率密度函数（PDF）$\operatorname{pLight}(\omega_o)$向光源发送大量光线。
同时，假设我们有一个与$\operatorname{pScatter}$相关的PDF，记作$\operatorname{pSurface}(\omega_o)$。
关于PDF的一个很好的特性是，你可以使用它们的线性组合形成混合密度，这些混合密度也是PDF。例如，最简单的情况是：

$$ p(\omega_o) = \frac{1}{2} \operatorname{pSurface}(\omega_o) +  \frac{1}{2} \operatorname{pLight}(\omega_o) $$

只要权重是正的并且加起来等于一，任何这样的PDF混合都是一个PDF。请记住，我们可以使用任何PDF：**所有的PDF最终都会收敛到正确的答案**。
因此，我们的目标是找出如何使得乘积

$$ \operatorname{pScatter}(\mathbf{x}, \omega_i, \omega_o) \cdot \operatorname{Color}_i(\mathbf{x}, \omega_i) $$

最大的地方，对应的PDF也会更大。对于漫反射表面来说，这主要是猜测$\operatorname{Color}_i(\mathbf{x}, \omega_i)$最大的位置，
也就是猜测光线来自哪个方向。

对于镜面材质，$\operatorname{pScatter}()$只在一个方向附近非常大，所以$\operatorname{pScatter}()$更重要。
事实上，大多数渲染器都将镜面作为一种特殊情况处理，并将$\operatorname{pScatter}()/p()$隐含在内——我们的代码目前也是这样做的。


回到康奈尔盒
-----------------------------
让我们调整一些康奈尔盒的参数：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    int main() {
        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        cam.samples_per_pixel = 100;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [cornell-box]: <kbd>[main.cc]</kbd> 康奈尔盒，重构]

<div class='together'>
在我的Macbook的一个核心上，我的代码在600×600的分辨率下在15分钟内生成了以下图像：

  ![<span class='num'>图像 3:</span> 康奈尔盒，重构
  ](../images/img-3.03-cornell-refactor1.jpg class='pixel')

</div>

我们的目标是减少噪点。我们将通过构建一个PDF来实现这一目标，该PDF会向光源发送更多的光线。

首先，让我们修改代码，以便明确地对某个PDF进行采样，然后进行归一化。
记住蒙特卡洛的基本原理：$\int f(x) \approx \sum f(r)/p(r)$。对于Lambertian材质，
让我们像现在一样进行采样：$p(\omega_o) = \cos(\theta_o) / \pi$。

<div class='together'>
我们修改基类`material`以启用这种重要性采样：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class material {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        virtual double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered)
        const {
            return 0;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-material]: <kbd>[material.h]</kbd>
    material类，添加重要性采样]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub trait Material {
        fn scatter(&self, r_in: &Ray, rec: &HitRecord, attenuation: &mut Color, scattered: &mut Ray) -> bool;
        fn emitted(&self, _u: f64, _v: f64, _p: vec3::Point3) -> Color {
            Color::new(0.0, 0.0, 0.0)
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn scattering_pdf(&self, _r_in: &Ray, _rec: &HitRecord, _scattered: &Ray) -> f64 {
            0.0
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
Lambertian材质变为：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class lambertian : public material {
      public:
        lambertian(const color& a) : albedo(make_shared<solid_color>(a)) {}
        lambertian(shared_ptr<texture> a) : albedo(a) {}

        bool scatter(const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered)
        const override {
            auto scatter_direction = rec.normal + random_unit_vector();

            // Catch degenerate scatter direction
            if (scatter_direction.near_zero())
                scatter_direction = rec.normal;

            scattered = ray(rec.p, scatter_direction, r_in.time());
            attenuation = albedo->value(rec.u, rec.v, rec.p);
            return true;
        }


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered) const {
            auto cos_theta = dot(rec.normal, unit_vector(scattered.direction()));
            return cos_theta < 0 ? 0 : cos_theta/pi;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

      private:
        shared_ptr<texture> albedo;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-lambertian-impsample]: <kbd>[material.h]</kbd>
    Lambertian材质，修改为重要性采样]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Material for Lambertian {
        fn scatter(&self, r_in: &Ray, rec: &HitRecord, attenuation: &mut Color, scattered: &mut Ray) -> bool {
            let mut scatter_direction = rec.normal + vec3::random_unit_vector();

            // 捕捉退化的散射方向
            if scatter_direction.near_zero() {
                scatter_direction = rec.normal;
            }

            *scattered = Ray::new_with_time(rec.p, scatter_direction, r_in.time());
            *attenuation = self.albedo.value(rec.u, rec.v, rec.p);
            true
        }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn scattering_pdf(&self, _r_in: &Ray, rec: &HitRecord, scattered: &Ray) -> f64 {
            let cos_theta = vec3::dot(rec.normal, vec3::unit_vector(scattered.direction()));
            if cos_theta < 0.0 {
                0.0
            } else {
                cos_theta / rtweekend::PI
            }
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
`camera::ray_color`函数进行了一些小修改：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world) const {
            hit_record rec;

            // 如果我们超过了光线反弹限制，就不再收集光线。
            if (depth <= 0)
                return color(0,0,0);

            // 如果光线没有击中了世界中的任何东西，则返回背景颜色。
            if (!world.hit(r, interval(0.001, infinity), rec))
                return background;

            ray scattered;
            color attenuation;
            color color_from_emission = rec.mat->emitted(rec.u, rec.v, rec.p);

            if (!rec.mat->scatter(r, rec, attenuation, scattered))
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);
            double pdf = scattering_pdf;

            color color_from_scatter =
                (attenuation * scattering_pdf * ray_color(scattered, depth-1, world)) / pdf;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            return color_from_emission + color_from_scatter;
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-impsample]: <kbd>[camera.h]</kbd>
    ray_color函数，修改为重要性采样]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Camera {
        ...

        fn ray_color(&self, r: &Ray, depth: usize, world: &dyn Hittable) -> Color {
            let mut rec = HitRecord::default();

            // 如果我们超过了光线反弹限制，就不再收集光线。
            if depth == 0 {
                return Color::default();
            }

            // 如果光线没有击中了世界中的任何东西，则返回背景颜色。
            if !world.hit(r, &Interval::new(0.001, rtweekend::INFINITY), &mut rec) {
                return self.background;
            }

            if let Some(mat) = rec.mat.clone() {
                let mut scattered = Ray::default();
                let mut attenuation = Color::default();
                let color_from_emission = mat.emitted(rec.u, rec.v, rec.p);
                if !mat.scatter(r, &rec, &mut attenuation, &mut scattered) {
                    return color_from_emission;
                }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                let scattering_pdf = mat.scattering_pdf(r, &rec, &scattered);
                let pdf = scattering_pdf;

                let color_from_scatter = (attenuation * scattering_pdf * self.ray_color(&scattered,  depth - 1, world)) / pdf;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

                color_from_emission + color_from_scatter
            } else {
                Color::default()
            }
        }

        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

你应该得到完全相同的图像。这是有道理的，因为`ray_color`的散射部分乘以了`scattering_pdf / pdf`，
而由于`pdf`等于`scattering_pdf`，所以相当于乘以了1。


使用均匀概率密度函数（PDF）而不是完美匹配
----------------------------------------------
现在，为了体验一下，让我们尝试使用不同的采样PDF。我们仍然将反射光线按照Lambertian（$\cos(\theta_o)$）进行加权，
保持散射PDF不变，但是我们将在分母中使用不同的PDF。我们将使用均匀分布的PDF来对半球进行采样，因此我们将分母设置为$1/2\pi$。
这仍然会收敛到正确的答案，因为我们只是改变了PDF，但由于PDF现在不再完全匹配真实分布，收敛所需的时间会更长。
这意味着对于相同数量的样本，图像会更加嘈杂：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world) const {
            hit_record rec;

            // 如果超过了光线反射次数的限制，不再收集光线。
            if (depth <= 0)
                return color(0,0,0);

            // 如果光线没有击中任何物体，返回背景颜色。
            if (!world.hit(r, interval(0.001, infinity), rec))
                return background;

            ray scattered;
            color attenuation;
            color color_from_emission = rec.mat->emitted(rec.u, rec.v, rec.p);

            if (!rec.mat->scatter(r, rec, attenuation, scattered))
                return color_from_emission;

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            double pdf = 1 / (2*pi);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            color color_from_scatter =
                (attenuation * scattering_pdf * ray_color(scattered, depth-1, world)) / pdf;

            return color_from_emission + color_from_scatter;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-uniform]: <kbd>[camera.h]</kbd>
    ray_color函数，现在分母中使用均匀PDF]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Camera {
        ...

        fn ray_color(&self, r: &Ray, depth: usize, world: &dyn Hittable) -> Color {
            let mut rec = HitRecord::default();

            // 如果我们超过了光线反弹限制，就不再收集光线。
            if depth == 0 {
                return Color::default();
            }

            // 如果光线没有击中了世界中的任何东西，则返回背景颜色。
            if !world.hit(r, &Interval::new(0.001, rtweekend::INFINITY), &mut rec) {
                return self.background;
            }

            if let Some(mat) = rec.mat.clone() {
                let mut scattered = Ray::default();
                let mut attenuation = Color::default();
                let color_from_emission = mat.emitted(rec.u, rec.v, rec.p);
                if !mat.scatter(r, &rec, &mut attenuation, &mut scattered) {
                    return color_from_emission;
                }

                let scattering_pdf = mat.scattering_pdf(r, &rec, &scattered);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                let pdf = 1.0 / (2.0 * rtweekend::PI);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

                let color_from_scatter = (attenuation * scattering_pdf * self.ray_color(&scattered,  depth - 1, world)) / pdf;

                color_from_emission + color_from_scatter
            } else {
                Color::default()
            }
        }

        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

你应该得到与之前非常相似的结果，只是稍微更嘈杂一些，可能很难看清楚。

  ![<span class='num'>图像 4:</span> Cornell 盒子，使用不完美的PDF
  ](../images/img-3.04-cornell-refactor2.jpg class='pixel')

确保将PDF返回到散射PDF。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            ...

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            double pdf = scattering_pdf;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-return]: <kbd>[camera.h]</kbd> 将PDF返回到与散射PDF相同的值]


随机半球采样
---------------------------
为了确认我们的理解，让我们尝试一种不同的散射分布。对于这个例子，我们将尝试重复第一本书中的均匀半球散射。
这种技术没有问题，但我们不再将物体视为Lambertian材质。Lambertian是一种特定类型的漫反射材质，需要一个$\cos(\theta_o)$的散射分布。
均匀半球散射是一种不同的漫反射材质。如果我们保持材质不变，但改变概率密度函数（PDF），就像在上一节中所做的那样，我们仍然会收敛到相同的答案，
但我们的收敛可能需要更多或更少的样本。然而，如果我们改变材质，我们将从根本上改变渲染结果，算法将收敛到一个不同的答案。
因此，当我们用均匀半球漫反射替换Lambertian漫反射时，我们应该期望渲染结果在**实质上**有所不同。我们将调整散射方向和散射PDF：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class lambertian : public material {
      public:
        lambertian(const color& a) : albedo(make_shared<solid_color>(a)) {}
        lambertian(shared_ptr<texture> a) : albedo(a) {}

        bool scatter(const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered)
        const override {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto scatter_direction = random_on_hemisphere(rec.normal);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            // Catch degenerate scatter direction
            if (scatter_direction.near_zero())
                scatter_direction = rec.normal;

            scattered = ray(rec.p, scatter_direction, r_in.time());
            attenuation = albedo->value(rec.u, rec.v, rec.p);
            return true;
        }


        double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered) const {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            return 1 / (2*pi);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        }

        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [scatter-mod]: <kbd>[material.h]</kbd> 修改后的PDF和scatter函数]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Material for Lambertian {
        fn scatter(&self, r_in: &Ray, rec: &HitRecord, attenuation: &mut Color, scattered: &mut Ray) -> bool {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
            let mut scatter_direction = vec3::random_on_hemisphere(rec.normal);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

            // 捕捉退化的散射方向
            if scatter_direction.near_zero() {
                scatter_direction = rec.normal;
            }

            *scattered = Ray::new_with_time(rec.p, scatter_direction, r_in.time());
            *attenuation = self.albedo.value(rec.u, rec.v, rec.p);
            true
        }

        fn scattering_pdf(&self, _r_in: &Ray, _rec: &HitRecord, _scattered: &Ray) -> f64 {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
            1.0 / (2.0 * rtweekend::PI)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

这种新的漫反射材质实际上只是散射PDF为$p(\omega_o) = \frac{1}{2\pi}$。因此，我们的均匀PDF虽然不完全匹配Lambertian漫反射，
但却完全匹配我们的均匀半球漫反射。在渲染时，我们应该得到一个略有不同的图像。

  ![<span class='num'>图像 5:</span> Cornell盒子，使用均匀半球采样
  ](../images/img-3.04-cornell-refactor2.jpg class='pixel')

它与我们之前的图片非常接近，但存在着不仅仅是噪声的差异。高盒子的正面颜色更加均匀。如果你不确定材质的最佳采样模式是什么，
假设一个均匀的PDF是相当合理的，虽然收敛速度可能较慢，但不会破坏你的渲染。也就是说，如果你不确定材质的正确采样模式，
你选择的PDF不会是你最大的担忧，因为选择错误的散射函数将会破坏你的渲染。至少它会产生一个不正确的结果。
你可能会发现自己在蒙特卡洛程序中遇到最难找到的错误之一——产生一个看起来合理的图像的错误！你不会知道这个错误是在第一个版本的程序中，
还是在第二个版本中，或者两者都有问题！

让我们构建一些基础设施来解决这个问题。



生成随机方向
====================================================================================================
在本章和下两章中，我们将加深对蒙特卡洛方法的理解和工具的使用。

相对于Z轴的随机方向
-----------------------------------------
首先，让我们弄清楚如何生成随机方向。我们已经有了使用拒绝方法生成随机方向的方法，所以让我们使用反演方法创建一个方法。
为了简化问题，假设$z$轴是表面法线，$\theta$是与法线的角度。本章我们将以$z$轴为基准进行设置，下一章我们将把其转换为表面法线向量。
我们只处理关于$z$轴旋转对称的分布。因此，$p(\omega) = f(\theta)$。

给定一个在球面上的方向概率密度函数（其中$p(\omega) = f(\theta)$），$\theta$和$\phi$的一维概率密度函数为：

    $$ a(\phi) = \frac{1}{2\pi} $$
    $$ b(\theta) = 2\pi f(\theta)\sin(\theta) $$

对于均匀分布的随机数$r_1$和$r_2$，我们求解$\theta$和$\phi$的累积分布函数（CDF），以便可以反演CDF来得到随机数生成器。

    $$ r_1 = \int_{0}^{\phi} a(\phi') d\phi' $$
    $$ = \int_{0}^{\phi} \frac{1}{2\pi} d\phi' $$
    $$ = \frac{\phi}{2\pi} $$

反演求解$\phi$：

    $$ \phi = 2 \pi \cdot r_1 $$

这应该符合你的直觉。要生成一个随机的$\phi$值，你可以在区间[0,1]内取一个均匀随机数，并乘以$2\pi$以覆盖所有可能的$\phi$值范围，即[0，$2\pi$]。
对于随机的$\theta$值，你可能没有完全形成直觉，所以让我们通过数学推导来帮助你进行设置。我们像之前一样将$\phi$表示为$\phi'$，将$\theta$表示为$\theta'$。
对于$\theta$，我们有：

    $$ r_2 = \int_{0}^{\theta} b(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} 2 \pi f(\theta') \sin(\theta') d\theta' $$

让我们尝试一些不同的$f()$函数。首先，让我们尝试在球面上均匀分布的情况。单位球的面积是$4\pi$，所以在单位球上的均匀分布$p(\omega) = \frac{1}{4\pi}$。

    $$ r_2 = \int_{0}^{\theta} 2 \pi \frac{1}{4\pi} \sin(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} \frac{1}{2} \sin(\theta') d\theta' $$
    $$ = \frac{-\cos(\theta)}{2} - \frac{-\cos(0)}{2} $$
    $$ = \frac{1 - \cos(\theta)}{2} $$

求解$\cos(\theta)$：

    $$ \cos(\theta) = 1 - 2 r_2 $$

我们不求解$\theta$，因为我们可能只需要知道$\cos(\theta)$，而不想要不必要的$\arccos()$调用。

为了生成指向$(\theta,\phi)$的单位向量方向，我们将其转换为笛卡尔坐标：

    $$ x = \cos(\phi) \cdot \sin(\theta) $$
    $$ y = \sin(\phi) \cdot \sin(\theta) $$
    $$ z = \cos(\theta) $$

利用恒等式$\cos^2 + \sin^2 = 1$，我们得到以下关系（以随机数$(r_1,r_2)$表示）：

    $$ x = \cos(2\pi \cdot r_1)\sqrt{1 - (1-2 r_2)^2} $$
    $$ y = \sin(2\pi \cdot r_1)\sqrt{1 - (1-2 r_2)^2} $$
    $$ z = 1 - 2  r_2 $$

稍微简化一下，$(1 - 2 r_2)^2 = 1 - 4r_2 + 4r_2^2$，所以：

    $$ x = \cos(2 \pi r_1) \cdot 2 \sqrt{r_2(1 - r_2)} $$
    $$ y = \sin(2 \pi r_1) \cdot 2 \sqrt{r_2(1 - r_2)} $$
    $$ z = 1 - 2 r_2 $$

<div class='together'>
我们可以输出其中一些结果：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <math.h>

    int main() {
        for (int i = 0; i < 200; i++) {
            auto r1 = random_double();
            auto r2 = random_double();
            auto x = cos(2*pi*r1)*2*sqrt(r2*(1-r2));
            auto y = sin(2*pi*r1)*2*sqrt(r2*(1-r2));
            auto z = 1 - 2*r2;
            std::cout << x << " " << y << " " << z << '\n';
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [rand-unit-sphere-plot]: <kbd>[sphere_plot.cc]</kbd> 在单位球上生成随机点]

</div>

<div class='together'>
并在plot.ly上免费绘制它们（一个支持3D散点图的优秀网站）：

  ![Figure [rand-pts-sphere]: 在单位球上的随机点
  ](../images/fig-3.10-rand-pts-sphere.jpg)

在plot.ly网站上，你可以旋转它并观察到它看起来是均匀分布的。

</div>


均匀采样半球
------------------------------
现在让我们推导均匀分布在半球上的情况。在半球上的密度均匀意味着$p(\omega) = f(\theta) = \frac{1}{2\pi}$。只需更改$\theta$方程中的常数即可：

    $$ r_2 = \int_{0}^{\theta} b(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} 2 \pi f(\theta') \sin(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} 2 \pi \frac{1}{2\pi} \sin(\theta') d\theta' $$
    $$ \ldots $$
    $$ \cos(\theta) = 1 - \cos^2(\theta) $$

这意味着$\cos(\theta)$的取值范围是从1到0，因此$\theta$的取值范围是从0到$\pi/2$，这意味着没有方向会低于地平线。
我们不再绘制它，而是求解具有已知解的二维积分。让我们对半球上的$\cos^3(\theta)$进行积分（只是选择一个具有已知解的任意函数）。
首先，我们将手动求解积分：

    $$ \int_\omega \cos^3(\theta) dA $$
    $$ = \int_{0}^{2 \pi} \int_{0}^{\pi /2} \cos^3(\theta) \sin(\theta) d\theta d\phi $$
    $$ = 2 \pi \int_{0}^{\pi/2} \cos^3(\theta) \sin(\theta) d\theta = \frac{\pi}{2} $$

<div class='together'>
现在我们来进行重要性采样的积分。$p(\omega) = \frac{1}{2\pi}$，所以我们平均$f()/p() = \cos^3(\theta) / \frac{1}{2\pi}$，我们可以测试一下：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>

    double f(double r2) {
        // auto x = cos(2*pi*r1)*2*sqrt(r2*(1-r2));
        // auto y = sin(2*pi*r1)*2*sqrt(r2*(1-r2));
        auto z = 1 - r2;
        double cos_theta = z;
        return cos_theta*cos_theta*cos_theta;
    }

    double pdf() {
        return 1.0 / (2.0*pi);
    }

    int main() {
        int N = 1000000;

        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            auto r2 = random_double();
            sum += f(r2) / pdf();
        }

        std::cout << std::fixed << std::setprecision(12);
        std::cout << "PI/2 = " << pi / 2.0 << '\n';
        std::cout << "Estimate = " << sum / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [cos-cubed]: <kbd>[cos_cubed.cc]</kbd> 使用$cos^3(x)$进行积分]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend;

    fn f(r2: f64) -> f64 {
        let z = 1.0 - r2;
        let cos_theta = z;
        cos_theta * cos_theta * cos_theta
    }

    fn pdf() -> f64 {
        1.0 / (2.0 * rtweekend::PI)
    }

    fn main() {
        const N: usize = 1000000;

        let mut sum = 0.0;
        (0..N).for_each(|_| {
            let r2 = rtweekend::random_double();
            sum += f(r2) / pdf();
        });

        println!("PI/2 = {:.12}", rtweekend::PI / 2.0);
        println!("Estimate = {:.12}", sum / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>


余弦采样半球
------------------------------
我们现在继续尝试解决余弦立方在地平线上的问题，但我们将把PDF更改为生成具有$p(\omega) =  f(\theta) = \cos(\theta) / \pi$的方向。

    $$ r_2 = \int_{0}^{\theta} b(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} 2 \pi f(\theta') \sin(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} 2 \pi \frac{\cos(\theta')}{\pi} \sin(\theta') d\theta' $$
    $$ = 1 - \cos^2(\theta) $$

因此，

    $$ \cos(\theta) = \sqrt{1 - r_2} $$

我们可以通过注意到

    $$ z = \cos(\theta) = \sqrt{1 - r_2} $$
    $$ x = \cos(\phi) \sin(\theta) = \cos(2 \pi r_1) \sqrt{1 - z^2} = \cos(2 \pi r_1) \sqrt{r_2} $$
    $$ y = \sin(\phi) \sin(\theta) = \sin(2 \pi r_1) \sqrt{1 - z^2} = \sin(2 \pi r_1) \sqrt{r_2} $$

来节省一些代数计算。

<div class='together'>
这是一个根据这个PDF加权生成随机向量的函数：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    inline vec3 random_cosine_direction() {
        auto r1 = random_double();
        auto r2 = random_double();

        auto phi = 2*pi*r1;
        auto x = cos(phi)*sqrt(r2);
        auto y = sin(phi)*sqrt(r2);
        auto z = sqrt(1-r2);

        return vec3(x, y, z);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [random-cosine-direction]: <kbd>[vec3.h]</kbd>
    生成余弦分布方向的随机向量的实用函数]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub fn random_cosine_direction() -> Vec3 {
        let r1 = random_double();
        let r2 = random_double();

        let phi = 2.0 * rtweekend::PI * r1;
        let x = phi.cos() * r2.sqrt();
        let y = phi.sin() * r2.sqrt();
        let z = (1.0 - r2).sqrt();

        Vec3::new(x, y, z)
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>

    double f(const vec3& d) {
        auto cos_theta = d.z();
        return cos_theta*cos_theta*cos_theta;
    }

    double pdf(const vec3& d) {
        return d.z() / pi;
    }

    int main() {
        int N = 1000000;

        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            vec3 d = random_cosine_direction();
            sum += f(d) / pdf(d);
        }

        std::cout << std::fixed << std::setprecision(12);
        std::cout << "PI/2 = " << pi / 2.0 << '\n';
        std::cout << "Estimate = " << sum / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [cos-density]: <kbd>[cos_density.cc]</kbd> 使用余弦密度函数进行积分]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend;
    use the_rest_of_your_life::vec3::{self, Vec3};

    fn f(d: Vec3) -> f64 {
        let cos_theta = d.z();
        cos_theta * cos_theta * cos_theta
    }

    fn pdf(d: Vec3) -> f64 {
        d.z() / rtweekend::PI
    }

    fn main() {
        const N: usize = 1000000;

        let mut sum = 0.0;
        (0..N).for_each(|_| {
            let d = vec3::random_cosine_direction();
            sum += f(d) / pdf(d);
        });

        println!("PI/2 = {:.12}", rtweekend::PI / 2.0);
        println!("Estimate = {:.12}", sum / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

我们可以在需要时生成其他密度函数。这个`random_cosine_direction()`函数生成一个按$\cos(\theta)$加权的随机方向，
其中$\theta$是与$z$轴的角度。



正交规范基（Orthonormal Bases）
====================================================================================================
在上一章中，我们开发了一些方法来生成相对于$z$轴的随机方向。如果我们想要能够在任意表面上产生反射，我们需要将其更加普遍化：
并非所有法线都与$z$轴完全对齐。因此，在本章中，我们将推广我们的方法，使其支持任意表面法线向量。

相对坐标系
---------------------
正交规范基（ONB）是三个相互正交的单位向量的集合，是坐标系的严格子类型。笛卡尔坐标系的$xyz$轴就是正交规范基的一个例子。
我们所有的渲染结果都是场景中对象的相对位置和方向在相机的图像平面上的投影的结果。相机和对象必须使用相同的坐标系描述，
以便在图像平面上进行投影是有意义的，否则相机无法正确地渲染对象。要么将相机重新定义为对象的坐标系，要么将对象重新定义为相机的坐标系。
最好是从相同的坐标系开始，这样就不需要重新定义。只要相机和场景在相同的坐标系中描述，一切都很好。正交规范基定义了空间中的距离和方向的表示方式，
但仅有正交规范基是不够的。对象和相机需要通过它们相对于一个相互定义的位置的位移来描述。这个位置就是场景的原点$\mathbf{O}$；
它代表了所有物体的宇宙中心。

假设我们有一个原点$\mathbf{O}$和笛卡尔单位向量$\mathbf{x}$、$\mathbf{y}$和$\mathbf{z}$。当我们说一个位置是(3,-2,7)时，
我们实际上是在说：

    $$ \text{位置是 } \mathbf{O} + 3\mathbf{x} - 2\mathbf{y} + 7\mathbf{z} $$

如果我们想要在另一个以原点$\mathbf{O}'$和基向量$\mathbf{u}$、$\mathbf{v}$和$\mathbf{w}$为坐标系中测量坐标，
我们只需要找到数字$(u,v,w)$，使得：

    $$ \text{位置是 } \mathbf{O}' + u\mathbf{u} + v\mathbf{v} + w\mathbf{w} $$


生成正交规范基
--------------------------------
如果你学习计算机图形学课程，会花很多时间讲解坐标系和4×4坐标变换矩阵。请注意，这是非常重要的内容！但是在本书中，我们不需要它，
我们可以不用它。我们需要的是根据表面法线向量$\mathbf{n}$生成具有一定分布的随机方向。对于这个过程，我们不需要一个起点，
因为方向是相对的，没有特定的起点。首先，我们需要两个余切向量，它们都垂直于$\mathbf{n}$，并且彼此也垂直。

一些3D对象模型会为每个顶点提供一个或多个余切向量。如果我们的模型只有一个余切向量，那么生成正交规范基的过程就不是一件简单的事情。
假设我们有任意一个非零长度且与$\mathbf{n}$不平行的向量$\mathbf{a}$。我们可以通过使用叉乘的性质$\mathbf{n} \times \mathbf{a}$
垂直于$\mathbf{n}$和$\mathbf{a}$来得到垂直于$\mathbf{n}$的向量$\mathbf{s}$和$\mathbf{t}$：

    $$ \mathbf{s} = \operatorname{unit_vector}(\mathbf{n} \times \mathbf{a}) $$

    $$ \mathbf{t} = \mathbf{n} \times \mathbf{s} $$

<div class='together'>
这一切都很好，但问题是当我们加载模型时，可能不会给我们一个$\mathbf{a}$，而且我们当前的程序也没有生成一个的方法。
如果我们继续选择一个任意的$\mathbf{a}$作为初始向量，可能会得到一个与$\mathbf{n}$平行的$\mathbf{a}$。
因此，一种常见的方法是选择一个任意的轴，并检查它是否与$\mathbf{n}$平行（我们假设$\mathbf{n}$的长度为1），
如果是，则选择另一个轴：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (fabs(n.x()) > 0.9)
        a = vec3(0, 1, 0)
    else
        a = vec3(1, 0, 0)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

<div class='together'>
然后我们进行叉乘得到$\mathbf{s}$和$\mathbf{t}$

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    vec3 s = unit_vector(cross(n, a));
    vec3 t = cross(n, s);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

注意，我们不需要对$\mathbf{t}$进行单位化。由于$\mathbf{n}$和$\mathbf{s}$都是单位向量，它们的叉乘$\mathbf{t}$也将是单位向量。
一旦我们有了$\mathbf{s}$、$\mathbf{t}$和$\mathbf{n}$的正交规范基，并且我们有一个相对于$z$轴的随机$(x,y,z)$，
我们可以通过以下方式得到相对于$\mathbf{n}$的向量：

    $$ \text{随机向量} = x \mathbf{s} + y \mathbf{t} + z \mathbf{n} $$

如果你还记得，我们在相机中使用了类似的数学方法来产生光线。你可以将其看作是对相机的自然坐标系的改变。


ONB类
--------------
我们是否应该为ONB创建一个类，还是仅使用实用函数就足够了？我不确定，但让我们创建一个类，因为它实际上并不比实用函数更复杂：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #ifndef ONB_H
    #define ONB_H

    #include "rtweekend.h"

    class onb {
      public:
        onb() {}

        vec3 operator[](int i) const { return axis[i]; }
        vec3& operator[](int i) { return axis[i]; }

        vec3 u() const { return axis[0]; }
        vec3 v() const { return axis[1]; }
        vec3 w() const { return axis[2]; }

        vec3 local(double a, double b, double c) const {
            return a*u() + b*v() + c*w();
        }

        vec3 local(const vec3& a) const {
            return a.x()*u() + a.y()*v() + a.z()*w();
        }

        void build_from_w(const vec3& w) {
            vec3 unit_w = unit_vector(w);
            vec3 a = (fabs(unit_w.x()) > 0.9) ? vec3(0,1,0) : vec3(1,0,0);
            vec3 v = unit_vector(cross(unit_w, a));
            vec3 u = cross(unit_w, v);
            axis[0] = u;
            axis[1] = v;
            axis[2] = unit_w;
        }

      public:
        vec3 axis[3];
    };


    #endif
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-onb]: <kbd>[onb.h]</kbd> 正交基类]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use std::ops::{
        Index,
        IndexMut,
    };

    use super::vec3::{self, Vec3};

    #[derive(Default)]
    pub struct Onb {
        pub axis: [Vec3; 3],
    }

    impl Onb {
        pub fn u(&self) -> Vec3 {
            self.axis[0]
        }
        pub fn v(&self) -> Vec3 {
            self.axis[1]
        }
        pub fn w(&self) -> Vec3 {
            self.axis[2]
        }

        pub fn local(&self, a: f64, b: f64, c: f64) -> Vec3 {
            a * self.u() + b * self.v() + c * self.w()
        }
        pub fn local_v(&self, a: Vec3) -> Vec3 {
            a.x() * self.u() + a.y() * self.v() + a.z() * self.w()
        }

        pub fn new_from_w(w: Vec3) -> Self {
            let unit_w = vec3::unit_vector(w);
            let a = if unit_w.x().abs() > 0.9 {
                Vec3::new(0.0, 1.0, 0.0)
            } else {
                Vec3::new(1.0, 0.0, 0.0)
            };
            let v = vec3::unit_vector(vec3::cross(unit_w, a));
            let u = vec3::cross(unit_w, v);
            Self { axis: [u, v, unit_w] }
        }
    }

    impl Index<usize> for Onb {
        type Output = Vec3;

        fn index(&self, i: usize) -> &Self::Output {
            &self.axis[i]
        }
    }

    impl IndexMut<usize> for Onb {
        fn index_mut(&mut self, i: usize) -> &mut Self::Output {
            &mut self.axis[i]
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

<div class='together'>
我们可以使用这个类来重写我们的Lambertian材质：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class lambertian : public material {
      public:
        ...

        bool scatter(
            const ray& r_in, const hit_record& rec, color& alb, ray& scattered, double& pdf
        ) const override {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            onb uvw;
            uvw.build_from_w(rec.normal);
            auto scatter_direction = uvw.local(random_cosine_direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            scattered = ray(rec.p, unit_vector(scatter_direction), r_in.time());
            alb = albedo->value(rec.u, rec.v, rec.p);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            pdf = dot(uvw.w(), scattered.direction()) / pi;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            return true;
        }

        ...
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [scatter-onb]: <kbd>[material.h]</kbd> Scatter函数，使用正交基]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Material for Lambertian {
        fn scatter(&self, r_in: &Ray, rec: &HitRecord, attenuation: &mut Color, scattered: &mut Ray, pdf: &mut f64) -> bool {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
            let uvw = Onb::new_from_w(rec.normal);
            let mut scatter_direction = uvw.local_v(vec3::random_cosine_direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

            // 捕捉退化的散射方向
            if scatter_direction.near_zero() {
                scatter_direction = rec.normal;
            }

            *scattered = Ray::new_with_time(rec.p, scatter_direction, r_in.time());
            *attenuation = self.albedo.value(rec.u, rec.v, rec.p);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
            *pdf = vec3::dot(uvw.w(), scattered.direction()) / rtweekend::PI;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
            true
        }
        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

<div class='together'>
这将产生以下结果：

  ![<span class='num'>图像 6：</span> Cornell 盒子，使用正交基 scatter 函数
  ](../images/img-3.06-cornell-ortho.jpg class='pixel')

</div>

<div class='together'>
让我们消除一些噪音。

但首先，让我们快速更新`isotropic`材质：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class isotropic : public material {
      public:
        isotropic(const color& c) : albedo(make_shared<solid_color>(c)) {}
        isotropic(shared_ptr<texture> a) : albedo(a) {}


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        bool scatter(
            const ray& r_in, const hit_record& rec, color& alb, ray& scattered, double& pdf
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        ) const override {
            scattered = ray(rec.p, random_unit_vector(), r_in.time());
            attenuation = albedo->value(rec.u, rec.v, rec.p);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            pdf = 1 / (4 * pi);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            return true;
        }


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered)
        const override {
            return 1 / (4 * pi);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

      private:
        shared_ptr<texture> albedo;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-isotropic-impsample]: <kbd>[material.h]</kbd>
    各向同性材质，用于重要性采样的修改]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Material for Isotropic {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn scatter(&self, r_in: &Ray, rec: &HitRecord, attenuation: &mut Color, scattered: &mut Ray, pdf: &mut f64) -> bool {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
            *scattered = Ray::new_with_time(rec.p, vec3::random_unit_vector(), r_in.time());
            *attenuation = self.albedo.value(rec.u, rec.v, rec.p);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
            *pdf = 1.0 / (4.0 * rtweekend::PI);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
            true
        }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn scattering_pdf(&self, _r_in: &Ray, _rec: &HitRecord, _scattered: &Ray) -> f64 {
            1.0 / (4.0 * rtweekend::PI)
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>



直接采样光源
====================================================================================================
在所有方向上均匀采样的问题在于，光源被采样的概率与任意或不重要的方向相同。我们可以使用阴影射线来解决任意给定点的直接光照问题。
相反，我将使用一个PDF来发送更多的射线到光源。然后，我们可以改变该PDF，以便在任何方向上发送更多的射线。

选择一个指向光源的随机方向非常简单；只需在光源上选择一个随机点，并向该方向发送一条射线。但我们需要知道PDF，即$p(\omega)$，
以确保我们的渲染不会产生偏差。但这个PDF是什么呢？

获取光源的PDF
---------------------------
对于一个表面积为$A$的光源，如果我们在光源上均匀采样，表面上的PDF就是$\frac{1}{A}$。如果将光源的整个表面投影到单位球上，
整个表面在单位球上占据了多大的面积？幸运的是，有一个简单的对应关系，如下图所示：

  ![图 [shape-onto-pdf]：光源形状投影到PDF上](../images/fig-3.11-shape-onto-pdf.jpg)

如果我们在光源上观察一个小面积$dA$，采样它的概率是$\operatorname{p_q}(q) \cdot dA$。在球上，采样小面积$d\omega$的概率是
$\operatorname{p}(\omega) \cdot d\omega$。$d\omega$和$dA$之间存在几何关系：

    $$ d\omega = \frac{dA \cdot \cos(\theta)}{\operatorname{distance}^2(p,q)} $$

由于采样$d\omega$和$dA$的概率必须相同，因此

    $$ \operatorname{p}(\omega) \cdot d\omega = \operatorname{p_q}(q) \cdot dA $$
    $$ \operatorname{p}(\omega)
       \cdot \frac{dA \cdot \cos(\theta)}{\operatorname{distance}^2(p,q)}
       = \operatorname{p_q}(q) \cdot dA $$

我们知道，如果在光源上均匀采样，表面上的PDF是$\frac{1}{A}$：

    $$ \operatorname{p_q}(q) = \frac{1}{A} $$
    $$ \operatorname{p}(\omega) \cdot \frac{dA \cdot \cos(\theta)}{\operatorname{distance}^2(p,q)}
       =  \frac{dA}{A} $$

因此

    $$ \operatorname{p}(\omega) = \frac{\operatorname{distance}^2(p,q)}{\cos(\theta) \cdot A} $$


光源采样
---------------
我们可以在`ray_color()`函数中以非常硬编码的方式对光源进行采样，以检查我们是否正确理解了数学和概念：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        color ray_color(const ray& r, int depth, const hittable& world) const {
            hit_record rec;

            // 如果超过了射线反射次数的限制，不再收集光线。
            if (depth <= 0)
                return color(0,0,0);

            // 如果射线没有击中任何物体，返回背景颜色。
            if (!world.hit(r, interval(0.001, infinity), rec))
                return background;

            ray scattered;
            color attenuation;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            double pdf;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            color color_from_emission = rec.mat->emitted(rec.u, rec.v, rec.p);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            if (!rec.mat->scatter(r, rec, attenuation, scattered, pdf))
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto on_light = point3(random_double(213,343), 554, random_double(227,332));
            auto to_light = on_light - rec.p;
            auto distance_squared = to_light.length_squared();
            to_light = unit_vector(to_light);

            if (dot(to_light, rec.normal) < 0)
                return color_from_emission;

            double light_area = (343-213)*(332-227);
            auto light_cosine = fabs(to_light.y());
            if (light_cosine < 0.000001)
                return color_from_emission;

            pdf = distance_squared / (light_cosine * light_area);
            scattered = ray(rec.p, to_light, r.time());

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            color color_from_scatter =
                (attenuation * scattering_pdf * ray_color(scattered, depth-1, world)) / pdf;

            return color_from_emission + color_from_scatter;
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-lights]: <kbd>[camera.h]</kbd> 光源采样的射线颜色]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Camera {
        fn ray_color(&self, r: &Ray, depth: usize, world: &dyn Hittable) -> Color {
            ...
            if let Some(mat) = rec.mat.clone() {
                let mut scattered = Ray::default();
                let mut attenuation = Color::default();
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                let mut pdf = 0.0;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
                let color_from_emission = mat.emitted(rec.u, rec.v, rec.p);
                if !mat.scatter(r, &rec, &mut attenuation, &mut scattered, &mut pdf) {
                    return color_from_emission;
                }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                let on_light = Point3::new(rtweekend::random_double_range(213.0, 343.0), 554.0, rtweekend::random_double_range(227.0, 332.0));
                let to_light = on_light - rec.p;
                let distance_squared = to_light.length_squared();
                let to_light = vec3::unit_vector(to_light);

                if vec3::dot(to_light, rec.normal) < 0.0 {
                    return color_from_emission;
                }

                let light_area = (343.0 - 213.0) * (332.0 - 227.0);
                let light_cosine = to_light.y().abs();
                if light_cosine < 0.000001 {
                    return color_from_emission;
                }

                pdf = distance_squared / (light_cosine * light_area);
                scattered = Ray::new_with_time(rec.p, to_light, r.time());

                let scattering_pdf = mat.scattering_pdf(r, &rec, &scattered);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

                let color_from_scatter = (attenuation * scattering_pdf * self.ray_color(&scattered,  depth - 1, world)) / pdf;

                color_from_emission + color_from_scatter
            } else {
                Color::default()
            }
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

<div class='together'>
使用每个像素10个样本，得到的结果如下：

  ![<span class='num'>图像 7：</span> Cornell 盒子，仅采样光源，每个像素10个样本](../images/img-3.07-cornell-sample-light.jpg class='pixel')

这大致符合我们只采样光源的预期，所以看起来这个方法是有效的。

</div>


切换到单向光源
----------------------------------
天花板上光源周围的噪点是因为光源是双面的，光源和天花板之间有一个小空间。我们可能希望光源只向下发射光线。
我们可以通过让hittable的emitted成员函数接收额外的信息来实现：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class material {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        virtual color emitted(
            const ray& r_in, const hit_record& rec, double u, double v, const point3& p
        ) const {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            return color(0,0,0);
        }
        ...
    };

    class diffuse_light : public material {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        color emitted(const ray& r_in, const hit_record& rec, double u, double v, const point3& p)
        const override {
            if (!rec.front_face)
                return color(0,0,0);
            return emit->value(u, v, p);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        ...
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [emitted-directional]: <kbd>[material.h]</kbd> 材质发射光线，单向]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub trait Material {
        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn emitted(&self, _r_in: &Ray, _rec: &HitRecord, _u: f64, _v: f64, _p: vec3::Point3) -> Color {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
            Color::new(0.0, 0.0, 0.0)
        }
        ...
    }
    ...
    impl Material for DiffuseLight {
        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn emitted(&self, _r_in: &Ray, rec: &HitRecord, u: f64, v: f64, p: vec3::Point3) -> Color {
            if rec.front_face {
                self.emit.value(u, v, p)
            } else {
                Color::default()
            }
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

<div class='together'>
这样我们就得到了：

  ![<span class='num'>图像 8：</span> Cornell 盒子，光源只向下发射光线](../images/img-3.08-cornell-lightdown.jpg class='pixel')

</div>



混合密度
====================================================================================================
我们已经使用了与$\cos(\theta)$相关的概率密度函数（PDF），以及与光线采样相关的PDF。我们希望有一个将它们结合起来的PDF。

PDF类
-------------
我们已经在很多代码中使用了PDF。现在是一个很好的时机来确定我们如何规范使用PDF。
我们已经知道我们将有一个用于表面的PDF和一个用于光线的PDF，所以让我们创建一个`pdf`基类。到目前为止，我们有一个`pdf()`函数，
它接受一个方向并返回该方向上的PDF分布值。到目前为止，这个值一直是$1/4\pi$、$1/2\pi$和$\cos(\theta)/\pi$中的一个。
在我们的一些示例中，我们使用了与PDF的分布不同的分布来生成随机方向。我们在章节Playing with Importance Sampling中详细讨论了这个问题。
一般来说，如果我们知道随机方向的分布，我们应该使用具有相同分布的PDF。这将导致最快的收敛速度。基于这一点，我们将创建一个`pdf`类，
负责生成随机方向并确定PDF的值。

根据这一点，任何`pdf`类都应该负责：

  1. 返回一个按照内部PDF分布加权的随机方向，以及
  2. 返回该方向上的相应PDF分布值。

<div class='together'>
这在$\operatorname{pSurface}$和$\operatorname{pLight}$中的具体实现方式有所不同，但这正是类层次结构的用途所在！
抽象类中应该放什么并不明显，所以我的方法是贪心地希望最小的接口能够工作，对于`pdf`来说，这意味着：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #ifndef PDF_H
    #define PDF_H

    #include "rtweekend.h"

    #include "onb.h"


    class pdf {
      public:
        virtual ~pdf() {}

        virtual double value(const vec3& direction) const = 0;
        virtual vec3 generate() const = 0;
    };

    #endif
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-pdf]: <kbd>[pdf.h]</kbd> 抽象的pdf类]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use super::vec3::Vec3;

    pub trait Pdf {
        fn value(&self, direction: Vec3) -> f64;
        fn generate(&self) -> Vec3;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
通过完善子类，我们将看到是否需要向`pdf`添加其他内容。首先，我们将创建一个在单位球上均匀分布的密度：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class sphere_pdf : public pdf {
      public:
        sphere_pdf() { }

        double value(const vec3& direction) const override {
            return 1/ (4 * pi);
        }

        vec3 generate() const override {
            return random_unit_vector();
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-uni-pdf]: <kbd>[pdf.h]</kbd> 均匀分布的uniform_pdf类]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub struct SpherePdf;

    impl Pdf for SpherePdf {
        fn value(&self, _direction: Vec3) -> f64 {
            1.0 / (4.0 * rtweekend::PI)
        }

        fn generate(&self) -> Vec3 {
            vec3::random_unit_vector()
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
接下来，让我们尝试一种余弦分布：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class cosine_pdf : public pdf {
      public:
        cosine_pdf(const vec3& w) { uvw.build_from_w(w); }

        double value(const vec3& direction) const override {
            auto cosine_theta = dot(unit_vector(direction), uvw.w());
            return fmax(0, cosine_theta/pi);
        }

        vec3 generate() const override {
            return uvw.local(random_cosine_direction());
        }

      private:
        onb uvw;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-cos-pdf]: <kbd>[pdf.h]</kbd> 余弦分布的cosine_pdf类]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub struct CosinePdf {
        uvw: Onb,
    }

    impl CosinePdf {
        pub fn new(w: Vec3) -> Self {
            Self {
                uvw: Onb::new_from_w(w),
            }
        }
    }

    impl Pdf for CosinePdf {
        fn value(&self, direction: Vec3) -> f64 {
            let cosine_theta = vec3::dot(vec3::unit_vector(direction), self.uvw.w());
            0.0_f64.max(cosine_theta / rtweekend::PI)
        }

        fn generate(&self) -> Vec3 {
            self.uvw.local_v(vec3::random_cosine_direction())
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
我们可以在`ray_color()`函数中尝试这个余弦PDF：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world) const {
            hit_record rec;

            // 如果超过了光线反射次数的限制，不再收集光线。
            if (depth <= 0)
                return color(0,0,0);

            // 如果光线没有击中任何物体，返回背景颜色。
            if (!world.hit(r, interval(0.001, infinity), rec))
                return background;

            ray scattered;
            color attenuation;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            double pdf_val;
            color color_from_emission = rec.mat->emitted(r, rec, rec.u, rec.v, rec.p);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            if (!rec.mat->scatter(r, rec, attenuation, scattered, pdf_val))
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            cosine_pdf surface_pdf(rec.normal);
            scattered = ray(rec.p, surface_pdf.generate(), r.time());
            pdf_val = surface_pdf.value(scattered.direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);

            color color_from_scatter =
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
                (attenuation * scattering_pdf * ray_color(scattered, depth-1, world)) / pdf_val;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            return color_from_emission + color_from_scatter;
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-cos-pdf]: <kbd>[camera.h]</kbd> ray_color函数，使用余弦pdf]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Camera {
        ...
        fn ray_color(&self, r: &Ray, depth: usize, world: &dyn Hittable) -> Color {
            ...

            if let Some(mat) = rec.mat.clone() {
                let mut scattered = Ray::default();
                let mut attenuation = Color::default();
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                let mut pdf = 0.0;
                let color_from_emission = mat.emitted(r, &rec, rec.u, rec.v, rec.p);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
                if !mat.scatter(r, &rec, &mut attenuation, &mut scattered, &mut pdf) {
                    return color_from_emission;
                }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                let surface_pdf = CosinePdf::new(rec.normal);
                scattered = Ray::new_with_time(rec.p, surface_pdf.generate(), r.time());
                pdf = surface_pdf.value(scattered.direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

                let scattering_pdf = mat.scattering_pdf(r, &rec, &scattered);

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                let color_from_scatter = (attenuation * scattering_pdf * self.ray_color(&scattered,  depth - 1, world)) / pdf;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

                color_from_emission + color_from_scatter
            } else {
              Color::default()
            }
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
这将得到一个完全匹配的结果，所以到目前为止，我们只是将一些计算移到了`cosine_pdf`类中：

  ![<span class='num'>图像 9：</span>带有余弦密度PDF的康奈尔盒子](../images/img-3.09-cornell-cos-pdf.jpg class='pixel')

</div>


朝可击中物体的方向进行采样
---------------------------------------
现在我们可以尝试朝着`hittable`（如光源）进行方向采样。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    ...
    #include "hittable_list.h"
    ...
    class hittable_pdf : public pdf {
      public:
        hittable_pdf(const hittable& _objects, const point3& _origin)
          : objects(_objects), origin(_origin)
        {}

        double value(const vec3& direction) const override {
            return objects.pdf_value(origin, direction);
        }

        vec3 generate() const override {
            return objects.random(origin);
        }

      private:
        const hittable& objects;
        point3 origin;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-hittable-pdf]: <kbd>[pdf.h]</kbd> hittable_pdf 类]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub struct HittablePdf<'a> {
        pub objects: &'a dyn Hittable,
        pub origin: Point3,
    }

    impl<'a> HittablePdf<'a> {
        pub fn new(objects: &'a dyn Hittable, origin: Point3) -> Self {
            Self {
                objects,
                origin,
            }
        }
    }

    impl Pdf for HittablePdf<'_> {
        fn value(&self, direction: Vec3) -> f64 {
            self.objects.pdf_value(self.origin, direction)
        }

        fn generate(&self) -> Vec3 {
            self.objects.random(self.origin)
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

如果我们想要对光源进行采样，我们需要`hittable`来回答一些它尚未具备接口的查询。
上面的代码假设`hittable`类中存在两个尚未实现的函数：`pdf_value()`和`random()`。
我们需要添加这些函数以使程序能够编译。我们可以遍历所有的`hittable`子类并添加这些函数，但那样会很麻烦，
所以我们只需在`hittable`基类中添加两个简单的函数。这会破坏我们之前的纯抽象实现，但可以节省工作量。
如果你想要一个纯抽象的`hittable`接口类，可以将这些函数一直写到子类。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class hittable {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        virtual double pdf_value(const point3& origin, const vec3& direction) const {
            return 0.0;
        }

        virtual vec3 random(const point3& origin) const {
            return vec3(1, 0, 0);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [hittable-plus2]: <kbd>[hittable.h]</kbd> hittable 类，带有两个新方法]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub trait Hittable {
        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn pdf_value(&self, _origin: Point3, _direction: Vec3) -> f64 {
            0.0
        }
        fn random(&self, _origin: Point3) -> Vec3 {
            Vec3::new(1.0, 0.0, 0.0)
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

<div class='together'>
然后我们修改`quad`来实现这些函数：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class quad : public hittable {
      public:
        quad(const point3& _Q, const vec3& _u, const vec3& _v, shared_ptr<material> m)
          : Q(_Q), u(_u), v(_v), mat(m)
        {
            auto n = cross(u, v);
            normal = unit_vector(n);
            D = dot(normal, Q);
            w = n / dot(n,n);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            area = n.length();
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            set_bounding_box();
        }
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double pdf_value(const point3& origin, const vec3& direction) const override {
            hit_record rec;
            if (!this->hit(ray(origin, direction), interval(0.001, infinity), rec))
                return 0;

            auto distance_squared = rec.t * rec.t * direction.length_squared();
            auto cosine = fabs(dot(direction, rec.normal) / direction.length());

            return distance_squared / (cosine * area);
        }

        vec3 random(const point3& origin) const override {
            auto p = plane_origin + (random_double() * axis_A) + (random_double() * axis_B);
            return p - origin;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

      private:
        point3 Q;
        vec3 u, v;
        vec3 w;
        shared_ptr<material> mat;
        aabb bbox;
        vec3 normal;
        double D;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double area;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [quad-pdf]: <kbd>[quad.h]</kbd> 带有 PDF 的 quad]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub struct Quad {
        q: Point3,
        u: Vec3,
        v: Vec3,
        w: Vec3,
        normal: Vec3,
        d: f64,
        mat: Rc<dyn Material>,
        bbox: Aabb,
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        area: f64,
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    }

    impl Quad {
        pub fn new(q: Point3, u: Vec3, v: Vec3, mat: Rc<dyn Material>) -> Self {
            let n = vec3::cross(u, v);
            let normal = vec3::unit_vector(n);
            Self {
                q,
                u,
                v,
                w: n / vec3::dot(n, n),
                normal,
                d: vec3::dot(normal, q),
                mat,
                bbox: Aabb::new_with_point(
                &q, &(q + u + v)
                ),
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                area: n.length(),
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
            }
        }
        ...
    }

    impl Hittable for Quad {
        ...

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn pdf_value(&self, origin: Point3, direction: Vec3) -> f64 {
            let mut rec = HitRecord::default();
            if !self.hit(&Ray::new(origin, direction), &Interval::new(0.0001, f64::INFINITY), &mut rec) {
              return 0.0;
            }

            let distance_squared = rec.t * rec.t * direction.length_squared();
            let cosine = (vec3::dot(direction, rec.normal) / direction.length()).abs();

            distance_squared / (cosine * self.area)
        }

        fn random(&self, origin: Point3) -> Vec3 {
            let p = self.q + (rtweekend::random_double() * self.u) + (rtweekend::random_double() * self.v);
            return p - origin;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

我们只需要在`quad`中添加`pdf_value()`和`random()`，因为我们使用它来重要性采样光源，而我们场景中唯一的光源就是一个`quad`。
如果你想要其他光源几何体，或者想要在其他对象上使用 PDF，你需要为相应的类实现上述函数。

<div class='together'>
在相机的`render()`函数中添加一个`lights`参数：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      public:
        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        void render(const hittable& world, const hittable& lights) {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            initialize();

            std::cout << "P3\n" << image_width << ' ' << image_height << "\n255\n";

            int sqrt_spp = int(sqrt(samples_per_pixel));
            for (int j = 0; j < image_height; j++) {
                std::clog << "\rScanlines remaining: " << (image_height - j) << ' ' << std::flush;
                for (int i = 0; i < image_width; i++) {
                    color pixel_color(0,0,0);
                    for (int s_j = 0; s_j < sqrt_spp; s_j++) {
                        for (int s_i = 0; s_i < sqrt_spp; s_i++) {
                            ray r = get_ray(i, j, s_i, s_j);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
                            pixel_color += ray_color(r, max_depth, world, lights);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
                        }
                    }
                    write_color(std::cout, pixel_color, samples_per_pixel);
                }
            }

            std::clog << "\rDone.                 \n";
        }

        ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world, const hittable& lights)
        const {
            ...

            ray scattered;
            color attenuation;
            double pdf_val;
            color color_from_emission = rec.mat->emitted(r, rec, rec.u, rec.v, rec.p);

            if (!rec.mat->scatter(r, rec, attenuation, scattered, pdf_val))
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            hittable_pdf light_pdf(light_ptr, rec.p);
            scattered = ray(rec.p, light_pdf.generate(), r.time());
            pdf_val = light_pdf.value(scattered.direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            color sample_color = ray_color(scattered, depth-1, world, lights);
            color color_from_scatter = (attenuation * scattering_pdf * sample_color) / pdf_val;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            return color_from_emission + color_from_scatter;
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-lights]: <kbd>[camera.h]</kbd> ray_color 函数带有光源 PDF]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Camera {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        pub fn render(&mut self, world: &dyn Hittable, lights: &dyn Hittable) {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
            self.initialize();

            println!("P3\n{} {}\n255", self.image_width, self.image_height);
            let stdout = std::io::stdout();

            for j in 0..self.image_height {
                eprintln!("\rScanlines remaining: {}", self.image_height - j);
                for i in 0..self.image_width {
                    let mut pixel_color = Color::default();
                    for s_j in 0..self.sqrt_spp {
                        for s_i in 0..self.sqrt_spp {
                            let r = self.get_ray(i as i32, j as i32, s_i as i32, s_j as i32);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                            pixel_color += self.ray_color(&r, self.max_depth, world, lights);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
                        }
                    }
                    pixel_color.write_color(&mut stdout.lock(), self.samples_per_pixel).unwrap();
                }
            }

            eprintln!("\nDone.");
        }
        ...

        fn ray_color(&self, r: &Ray, depth: usize, world: &dyn Hittable, lights: &dyn Hittable) -> Color {
            ...

            if let Some(mat) = rec.mat.clone() {
                let mut scattered = Ray::default();
                let mut attenuation = Color::default();
                let mut pdf = 0.0;
                let color_from_emission = mat.emitted(r, &rec, rec.u, rec.v, rec.p);
                if !mat.scatter(r, &rec, &mut attenuation, &mut scattered, &mut pdf) {
                    return color_from_emission;
                }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                let light_pdf = HittablePdf::new(lights, rec.p);
                let scattered = Ray::new_with_time(rec.p, light_pdf.generate(), r.time());
                let pdf = light_pdf.value(scattered.direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

                let scattering_pdf = mat.scattering_pdf(r, &rec, &scattered);

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                let sample_color = self.ray_color(&scattered, depth - 1, world, lights);
                let color_from_scatter = (attenuation * scattering_pdf * sample_color) / pdf;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

                color_from_emission + color_from_scatter
            } else {
                Color::default()
            }
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
在天花板中央创建一个光源：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    int main() {
        ...

        // Box 2
        shared_ptr<hittable> box2 = box(point3(0,0,0), point3(165,165,165), white);
        box2 = make_shared<rotate_y>(box2, -18);
        box2 = make_shared<translate>(box2, vec3(130,0,65));
        world.add(box2);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        // Light Sources
        hittable_list lights;
        auto m = shared_ptr<material>();
        lights.add(make_shared<quad>(point3(343,554,332), vec3(-130,0,0), vec3(0,0,-105), m));
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        camera cam;
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        cam.render(world, lights);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-hittable-pdf]: <kbd>[main.cc]</kbd> 向 Cornell 盒子添加光源]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    fn main() {
        ...
        // Light Sources.
        let mut lights = HittableList::default();
        lights.add(Rc::new(
            Quad::new(
                Point3::new(343.0, 554.0, 332.0),
                vec3::Vec3::new(-130.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 0.0, -105.0),
                Rc::clone(&light),
            )
        ));

        let mut cam = Camera::default();
        ...

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        cam.render(&world, &lights);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
使用每像素10个样本，我们得到：

  ![<span class='num'>图像 10:</span> Cornell 盒子，对可击中光源进行采样，每像素10个样本
  ](../images/img-3.10-hittable-light.jpg class='pixel')

</div>


混合概率密度函数（Mixture PDF）类
----------------------
在Playing with Importance Sampling一节中简要提到过，我们可以创建任意概率密度函数（PDF）的线性混合，
形成也是PDF的混合密度。任意PDF的加权平均也是一个PDF。只要权重是正数且加起来等于1，我们就得到了一个新的PDF。

  $ \operatorname{pMixture}() = w_0 p_0() + w_1 p_1() + w_2 p_2() + \ldots + w_{n-1} p_{n-1}() $

  $ 1 = w_0 + w_1 + w_2 + \ldots + w_{n-1} $

例如，我们可以简单地对两个密度进行平均：

  $ \operatorname{pMixture}(\omega_o)
     = \frac{1}{2} \operatorname{pSurface}(\omega_o) + \frac{1}{2} \operatorname{pLight}(\omega_o)
  $

<div class='together'>
我们如何在代码中实现这个过程呢？有一个非常重要的细节使得这并不像人们期望的那么简单。
生成混合PDF的随机方向很简单：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (random_double() < 0.5)
        根据pSurface选择方向
    else
        根据pLight选择方向
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

但是解决$\operatorname{pMixture}$的PDF值稍微有些微妙。我们不能简单地：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (方向来自pSurface)
        获取pSurface的PDF值
    else
        获取pLight的PDF值
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<div class='together'>
首先，弄清楚随机方向来自哪个PDF可能并不是一件简单的事情。我们没有任何方法让`generate()`告诉`value()`原始的`random_double()`是什么，
所以我们无法简单地判断随机方向来自哪个PDF。如果我们认为上述代码是正确的，我们将不得不反向解决问题，找出方向可能来自哪个PDF。
这听起来确实像一场噩梦，但幸运的是我们不需要这样做。有一些方向既可以由$\operatorname{pLight}$生成，也可以由$\operatorname{pSurface}$生成。
我们只需要解决随机方向的$\operatorname{pSurface}$和$\operatorname{pLight}$的PDF值，然后使用PDF混合权重来计算该方向的总PDF值即可。
混合密度类实际上非常简单：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class mixture_pdf : public pdf {
      public:
        mixture_pdf(shared_ptr<pdf> p0, shared_ptr<pdf> p1) {
            p[0] = p0;
            p[1] = p1;
        }

        double value(const vec3& direction) const override {
            return 0.5 * p[0]->value(direction) + 0.5 *p[1]->value(direction);
        }

        vec3 generate() const override {
            if (random_double() < 0.5)
                return p[0]->generate();
            else
                return p[1]->generate();
        }

      private:
        shared_ptr<pdf> p[2];
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-mixturep-df]: <kbd>[pdf.h]</kbd> mixture_pdf类]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub struct MixturePdf<'a> {
        pub p: [&'a dyn Pdf; 2],
    }

    impl<'a> MixturePdf<'a> {
        pub fn new(p0: &'a dyn Pdf, p1: &'a dyn Pdf) -> Self {
            Self {
                p: [p0, p1],
            }
        }
    }

    impl Pdf for MixturePdf<'_> {
        fn value(&self, direction: Vec3) -> f64 {
            0.5 * self.p[0].value(direction) + 0.5 * self.p[1].value(direction)
        }

        fn generate(&self) -> Vec3 {
            if rtweekend::random_double_range(0.0, 1.0) < 0.5 {
                self.p[0].generate()
            } else {
                self.p[1].generate()
            }
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
现在我们想要对余弦采样和光源采样进行混合密度。我们可以将其插入到`ray_color()`中：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world, const hittable& lights)
        const {
            ...

            if (!rec.mat->scatter(r, rec, attenuation, scattered, pdf_val))
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto p0 = make_shared<hittable_pdf>(light_ptr, rec.p);
            auto p1 = make_shared<cosine_pdf>(rec.normal);
            mixture_pdf mixed_pdf(p0, p1);

            scattered = ray(rec.p, mixed_pdf.generate(), r.time());
            pdf_val = mixed_pdf.value(scattered.direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);

            color sample_color = ray_color(scattered, depth-1, world, lights);
            color color_from_scatter = (attenuation * scattering_pdf * sample_color) / pdf_val;

            return color_from_emission + color_from_scatter;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-mixture]: <kbd>[camera.h]</kbd> ray_color函数，使用混合PDF]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Camera {
            ...

            fn ray_color(&self, r: &Ray, depth: usize, world: &dyn Hittable, lights: &dyn Hittable) -> Color {
                ...

                if let Some(mat) = rec.mat.clone() {
                    let mut scattered = Ray::default();
                    let mut attenuation = Color::default();
                    let mut pdf = 0.0;
                    let color_from_emission = mat.emitted(r, &rec, rec.u, rec.v, rec.p);
                    if !mat.scatter(r, &rec, &mut attenuation, &mut scattered, &mut pdf) {
                        return color_from_emission;
                    }

        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                    let p0 = HittablePdf::new(lights, rec.p);
                    let p1 = CosinePdf::new(rec.normal);
                    let mixed_pdf = MixturePdf::new(&p0, &p1);

                    let scattered = Ray::new_with_time(rec.p, mixed_pdf.generate(), r.time());
                    let pdf = mixed_pdf.value(scattered.direction());
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

                    let scattering_pdf = mat.scattering_pdf(r, &rec, &scattered);

                    let sample_color = self.ray_color(&scattered, depth - 1, world, lights);
                    let color_from_scatter = (attenuation * scattering_pdf * sample_color) / pdf;

                    color_from_emission + color_from_scatter
                } else {
                    Color::default()
                }
            }
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    ---

</div>

<div class='together'>
每个像素1000个样本产生的结果如下：

  ![<span class='num'>图像 11：</span> Cornell 盒子，余弦采样和光源采样的混合密度
  ](../images/img-3.11-cosine-and-light.jpg class='pixel')

</div>



一些架构决策
====================================================================================================
在本章中，我们不会编写任何代码。我们正处于一个十字路口，需要做出一些架构决策。

混合密度方法是传统阴影射线的一种替代方法。传统的阴影射线是检查从交点到给定光源的路径是否被阻挡。
如果射线与某个物体相交，则表示该交点处于该特定光源的阴影中。我个人更喜欢混合密度方法，因为除了光源，
你还可以采样窗户、门下的亮缝或其他你认为可能很亮或很重要的地方。但在大多数专业路径追踪器中，你仍然会看到阴影射线。
通常情况下，它们会有预定义数量的阴影射线（例如1、4、8、16），在渲染过程中，每当路径追踪射线与物体相交时，
它们会将这些终端阴影射线发送到场景中的随机光源，以确定交点是否被该随机光源照亮。
交点要么被该光源照亮，要么完全处于阴影中，更多的阴影射线会导致更准确的照明。
在所有阴影射线终止（无论是在光源上还是在遮挡表面上）之后，初始路径追踪射线继续前进，并在下一个交点处发送更多的阴影射线。
你无法告诉阴影射线什么是重要的，你只能告诉它们什么是发光的，因此阴影射线在没有过于复杂的光子分布的简单场景中效果最好。
也就是说，阴影射线会在遇到的第一个物体上终止，并且不会反弹，因此一个阴影射线比一个路径追踪射线更便宜，
这就是为什么你通常会看到比路径追踪射线更多的阴影射线（例如1、4、8、16）的原因。
在一个更受限制的场景中，你可以选择阴影射线而不是混合密度方法；这是个人设计偏好。
对于粗糙结果来说，阴影射线比混合密度方法更便宜，并且在实时渲染中越来越常见。

代码中还存在一些其他问题。

PDF构建在`ray_color()`函数中是硬编码的。我们应该对此进行清理。

我们不小心破坏了镜面反射射线（玻璃和金属），它们不再受支持。
如果我们将它们的散射函数设置为一个delta函数，数学上仍然是成立的，但会导致各种浮点数灾难。
我们可以将镜面反射作为一个特殊情况，跳过$f()/p()$的计算，或者将表面粗糙度设置为一个非常小但非零的值，
从而得到几乎是镜面的表面，看起来非常光滑，但不会产生NaN值。我对如何处理没有意见（我尝试过两种方法，它们都有各自的优势），
但我们已经有了平滑的金属和玻璃代码，所以我们将添加完美的镜面表面，跳过显式的$f()/p()$计算。

此外，我们缺乏真正的背景函数基础设施，以防我们想要添加环境贴图或更有趣的功能背景。
一些环境贴图是HDR格式（RGB分量是归一化浮点数，而不是0-255的字节）。我们的输出一直都是HDR的；
我们只是截断了它。

最后，我们的渲染器是RGB的。一个更基于物理的渲染器，比如汽车制造商可能会使用的渲染器，可能需要使用光谱颜色，
甚至可能需要使用偏振。对于电影渲染器，大多数工作室仍然使用RGB。你可以创建一个混合渲染器，同时具有这两种模式，
但这当然更难。我现在将继续使用RGB，但我会在本书的最后谈到这个问题。



简化PDF管理
====================================================================================================
到目前为止，`ray_color()`函数创建了两个硬编码的PDF：

1. `p0()`与光源的形状相关
2. `p1()`与法向量和表面类型相关

我们可以将关于光源（或者我们想要采样的任何`hittable`）的信息传递给`ray_color()`函数，
并且我们可以向`material`函数请求一个PDF（我们需要添加一些机制来实现这一点）。
我们还需要知道散射光线是否是镜面反射，我们可以通过询问`hit()`函数或`material`类来实现这一点。

漫反射与镜面反射
------------------------
我们希望允许材质（例如上光木材）部分是理想的镜面反射（光泽部分），部分是漫反射（木材部分）。
一些渲染器会生成两条光线：一条是镜面反射，一条是漫反射。我不喜欢使用分支，所以我更愿意让材质随机决定是漫反射还是镜面反射。
但是这种方法的问题在于，当我们请求PDF值时需要小心，而且`ray_color()`函数需要知道这条光线是漫反射还是镜面反射。
幸运的是，我们已经决定只有在漫反射时才调用`pdf_value()`，所以我们可以隐式处理这个问题。

<div class='together'>
我们可以重新设计`material`类，并将所有新的参数都放入一个类中，就像我们为`hittable`做的那样：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
    class scatter_record {
      public:
        color attenuation;
        shared_ptr<pdf> pdf_ptr;
        bool skip_pdf;
        ray skip_pdf_ray;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

    class material {
      public:
        ...

        virtual bool scatter(
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            const ray& r_in, const hit_record& rec, scatter_record& srec
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        ) const {
            return false;
        }
        ...
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [material-refactor]: <kbd>[material.h]</kbd> 重构material类]

</div>

<div class='together'>
`lambertian`材质变得更简单：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class lambertian : public material {
      public:
        lambertian(const color& a) : albedo(make_shared<solid_color>(a)) {}
        lambertian(shared_ptr<texture> a) : albedo(a) {}


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        bool scatter(const ray& r_in, const hit_record& rec, scatter_record& srec) const override {
            srec.attenuation = albedo->value(rec.u, rec.v, rec.p);
            srec.pdf_ptr = make_shared<cosine_pdf>(rec.normal);
            srec.skip_pdf = false;
            return true;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered) const {
            auto cosine = dot(rec.normal, unit_vector(scattered.direction()));
            return cosine < 0 ? 0 : cosine/pi;
        }

      private:
        shared_ptr<texture> albedo;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [lambertian-scatter]: <kbd>[material.h]</kbd> 新的lambertian scatter()方法]

</div>

<div class='together'>
`isotropic`材质也变得简单：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class isotropic : public material {
      public:
        isotropic(const color& c) : albedo(make_shared<solid_color>(c)) {}
        isotropic(shared_ptr<texture> a) : albedo(a) {}


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        bool scatter(const ray& r_in, const hit_record& rec, scatter_record& srec) const override {
            srec.attenuation = albedo->value(rec.u, rec.v, rec.p);
            srec.pdf_ptr = make_shared<sphere_pdf>();
            srec.skip_pdf = false;
            return true;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++


        double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered)
        const override {
            return 1 / (4 * pi);
        }

      private:
        shared_ptr<texture> albedo;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [isotropic-scatter]: <kbd>[material.h]</kbd> 新的isotropic scatter()方法]

</div>

<div class='together'>
`ray_color()`的变化很小：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world, const hittable& lights)
        const {
            hit_record rec;

            // 如果超过了光线反射次数的限制，不再收集光线。
            if (depth <= 0)
                return color(0,0,0);

            // 如果光线没有击中任何物体，返回背景颜色。
            if (!world.hit(r, interval(0.001, infinity), rec))
                return background;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            scatter_record srec;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            color color_from_emission = rec.mat->emitted(r, rec, rec.u, rec.v, rec.p);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            if (!rec.mat->scatter(r, rec, srec))
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto light_ptr = make_shared<hittable_pdf>(lights, rec.p);
            mixture_pdf p(light_ptr, srec.pdf_ptr);

            ray scattered = ray(rec.p, p.generate(), r.time());
            auto pdf_val = p.value(scattered.direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);

            color sample_color = ray_color(scattered, depth-1, world, lights);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            color color_from_scatter = (srec.attenuation * scattering_pdf * sample_color) / pdf_val;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            return color_from_emission + color_from_scatter;
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-mixture]: <kbd>[camera.h]</kbd> 使用混合PDF的ray_color函数]

</div>


处理镜面反射
------------------
我们还没有处理镜面表面，也没有处理会影响表面法线的情况。但是总体上，这个设计是干净的，而且所有这些问题都是可以解决的。
现在，我将修复`specular`。金属和介质材料很容易修复。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class metal : public material {
      public:
        metal(const color& a, double f) : albedo(a), fuzz(f < 1 ? f : 1) {}


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        bool scatter(const ray& r_in, const hit_record& rec, scatter_record& srec) const override {
            srec.attenuation = albedo;
            srec.pdf_ptr = nullptr;
            srec.skip_pdf = true;
            vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);
            srec.skip_pdf_ray =
                ray(rec.p, reflected + fuzz*random_in_unit_sphere(), r_in.time());
            return true;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

      private:
        color albedo;
        double fuzz;
    };

    ...

    class dielectric : public material {
      public:
        dielectric(double index_of_refraction) : ir(index_of_refraction) {}


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        bool scatter(const ray& r_in, const hit_record& rec, scatter_record& srec) const override {
            srec.attenuation = color(1.0, 1.0, 1.0);
            srec.pdf_ptr = nullptr;
            srec.skip_pdf = true;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            double refraction_ratio = rec.front_face ? (1.0/ir) : ir;

            vec3 unit_direction = unit_vector(r_in.direction());
            double cos_theta = fmin(dot(-unit_direction, rec.normal), 1.0);
            double sin_theta = sqrt(1.0 - cos_theta*cos_theta);

            bool cannot_refract = refraction_ratio * sin_theta > 1.0;
            vec3 direction;

            if (cannot_refract || reflectance(cos_theta, refraction_ratio) > random_double())
                direction = reflect(unit_direction, rec.normal);
            else
                direction = refract(unit_direction, rec.normal, refraction_ratio);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            srec.skip_pdf_ray = ray(rec.p, direction, r_in.time());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            return true;
        }

      ...
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [material-scatter]: <kbd>[material.h]</kbd> metal和dielectric的scatter方法]

请注意，如果模糊度不为零，这个表面实际上并不是理想的镜面反射，但隐式采样的工作方式与之前相同。
对于我们将镜面处理的材料，我们实际上跳过了所有的PDF计算。

<div class='together'>
`ray_color()`只需要一个新的情况来生成隐式采样的光线：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world, const hittable& lights)
        const {
            ...

            if (!rec.mat->scatter(r, rec, srec))
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            if (srec.skip_pdf) {
                return srec.attenuation * ray_color(srec.skip_pdf_ray, depth-1, world, lights);
            }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            auto light_ptr = make_shared<hittable_pdf>(lights, rec.p);
            mixture_pdf p(light_ptr, srec.pdf_ptr);

            ...
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-implicit]: <kbd>[camera.h]</kbd>
    使用隐式采样光线的Ray color函数]

</div>

我们将通过将一个盒子更改为金属来检查我们的工作。我们还想将其中一个盒子替换为玻璃对象，但我们将在下一节中完成。
玻璃对象很难渲染得很好，所以我们想为它们创建一个PDF，但在能够这样做之前，我们还有一些工作要做。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    int main() {
        ...
        // 光源
        world.add(make_shared<quad>(point3(213,554,227), vec3(130,0,0), vec3(0,0,105), light));

        // 盒子1
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        shared_ptr<material> aluminum = make_shared<metal>(color(0.8, 0.85, 0.88), 0.0);
        shared_ptr<hittable> box1 = box(point3(0,0,0), point3(165,330,165), aluminum);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        box1 = make_shared<rotate_y>(box1, 15);
        box1 = make_shared<translate>(box1, vec3(265,0,295));
        world.add(box1);

        // 盒子2
        shared_ptr<hittable> box2 = box(point3(0,0,0), point3(165,165,165), white);
        box2 = make_shared<rotate_y>(box2, -18);
        box2 = make_shared<translate>(box2, vec3(130,0,65));
        world.add(box2);

        // 光源
        hittable_list lights;
        auto m = shared_ptr<material>();
        lights.add(make_shared<quad>(point3(343,554,332), vec3(-130,0,0), vec3(0,0,-105), m));

        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [scene-cornell-al]: <kbd>[main.cc]</kbd> 使用铝材料的Cornell盒子场景]

<div class='together'>
结果图像在天花板上有嘈杂的反射，因为朝向盒子的方向没有更密集的采样。

  ![<span class='num'>图像 12：</span>带有任意PDF函数的Cornell盒子](../images/img-3.12-arbitrary-pdf.jpg class='pixel')

</div>


采样一个球体对象
-------------------------
通过为金属盒子创建一个概率密度函数（PDF），可以减少天花板上的噪点。如果我们将其制作成玻璃材质，我们也会希望为盒子创建一个PDF。
但是为盒子创建一个PDF需要相当多的工作，而且并不是非常有趣，所以我们来为一个玻璃球创建一个PDF。这样更快，也能产生更有趣的渲染效果。
我们需要找出如何采样一个球体以确定适当的PDF分布。如果我们想从球体外部采样一个球体，我们不能只是在其表面上随机选择一个点就结束了。
如果我们这样做，我们经常会选择到球体的另一侧，而这一侧会被球体的前面遮挡。我们需要一种方法来均匀采样从任意点可见的球体的一侧。
当我们从球体外部均匀采样球体的立体角时，实际上是在均匀采样一个圆锥体。圆锥体的轴从射线起点通过球体中心，圆锥体的侧面与球体相切--见下图。
假设代码中有`theta_max`。回想一下，在生成随机方向的章节中，要采样$\theta$，我们有：

  $$ r_2 = \int_{0}^{\theta} 2 \pi f(\theta') \sin(\theta') d\theta' $$

这里的$f(\theta')$是一个尚未计算的常数$C$，所以：

  $$ r_2 = \int_{0}^{\theta} 2 \pi C \sin(\theta') d\theta' $$

如果我们通过微积分解决：

  $$ r_2 = 2\pi \cdot C \cdot (1-\cos(\theta)) $$

所以

  $$ cos(\theta) = 1 - \frac{r_2}{2 \pi \cdot C} $$

我们限制我们的分布，使得随机方向必须小于$\theta_{max}$。这意味着从0到$\theta_{max}$的积分必须为1，因此$r_2 = 1$。我们可以用这个来解$C$：

  $$ r_2 = 2\pi \cdot C \cdot (1-\cos(\theta)) $$
  $$ 1 = 2\pi \cdot C \cdot (1-\cos(\theta_{max})) $$
  $$ C = \frac{1}{2\pi \cdot (1-\cos(\theta_{max})} $$

这给出了$\theta$、$\theta_{max}$和$r_2$之间的等式：

  $$ \cos(\theta) = 1 + r_2 \cdot (\cos(\theta_{max})-1) $$

我们像以前一样采样$\phi$，所以：

  $$ z = \cos(\theta) = 1 + r_2 \cdot (\cos(\theta_{max}) - 1) $$
  $$ x = \cos(\phi) \cdot \sin(\theta) = \cos(2\pi \cdot r_1) \cdot \sqrt{1-z^2} $$
  $$ y = \sin(\phi) \cdot \sin(\theta) = \sin(2\pi \cdot r_1) \cdot \sqrt{1-z^2} $$

那么$\theta_{max}$是多少呢？

  ![Figure [sphere-enclosing-cone]: A sphere-enclosing cone
  ](../images/fig-3.12-sphere-enclosing-cone.jpg)

从图中可以看出，$\sin(\theta_{max}) = R / length(\mathbf{c} - \mathbf{p})$。所以：

  $$ \cos(\theta_{max}) = \sqrt{1 - \frac{R^2}{length^2(\mathbf{c} - \mathbf{p})}} $$

我们还需要计算方向的概率密度函数（PDF）。对于朝向球体的均匀分布，PDF为$1/\mathit{solid\_angle}$。球体的立体角是多少呢？
它与上面的$C$有关。根据定义，它是单位球体上的面积，所以积分是

  $$ \mathit{solid angle} = \int_{0}^{2\pi} \int_{0}^{\theta_{max}} \sin(\theta)
     = 2 \pi \cdot (1-\cos(\theta_{max})) $$

对于所有这样的计算，最好检查一下数学计算是否正确。我通常会将极端情况代入（感谢我的高中物理老师霍顿先生提出的概念）。
对于半径为零的球体，$\cos(\theta_{max}) = 0$，这是正确的。对于与$\mathbf{p}$相切的球体，$\cos(\theta_{max}) = 0$，$2\pi$是半球的面积，所以也是正确的。


更新球体代码
-------------------------
球体类需要两个与概率密度函数（PDF）相关的函数：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class sphere : public hittable {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double pdf_value(const point3& origin, const vec3& direction) const override {
            // 这个方法只适用于静止的球体。

            hit_record rec;
            if (!this->hit(ray(origin, direction), interval(0.001, infinity), rec))
                return 0;

            auto cos_theta_max = sqrt(1 - radius*radius/(center1 - origin).length_squared());
            auto solid_angle = 2*pi*(1-cos_theta_max);

            return  1 / solid_angle;
        }

        vec3 random(const point3& origin) const override {
            vec3 direction = center1 - origin;
            auto distance_squared = direction.length_squared();
            onb uvw;
            uvw.build_from_w(direction);
            return uvw.local(random_to_sphere(radius, distance_squared));
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

      private:
        ...

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        static vec3 random_to_sphere(double radius, double distance_squared) {
            auto r1 = random_double();
            auto r2 = random_double();
            auto z = 1 + r2*(sqrt(1-radius*radius/distance_squared) - 1);

            auto phi = 2*pi*r1;
            auto x = cos(phi)*sqrt(1-z*z);
            auto y = sin(phi)*sqrt(1-z*z);

            return vec3(x, y, z);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [sphere-pdf]: <kbd>[sphere.h]</kbd> 带有概率密度函数的球体]

<div class='together'>
我们首先尝试对球体进行采样，而不是光源：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    int main() {
        ...

        // 光源
        world.add(make_shared<quad>(point3(213,554,227), vec3(130,0,0), vec3(0,0,105), light));


        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        // 盒子
        shared_ptr<hittable> box1 = box(point3(0,0,0), point3(165,330,165), white);
        box1 = make_shared<rotate_y>(box1, 15);
        box1 = make_shared<translate>(box1, vec3(265,0,295));
        world.add(box1);

        // 玻璃球体
        auto glass = make_shared<dielectric>(1.5);
        world.add(make_shared<sphere>(point3(190,90,190), 90, glass));
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        // 光源列表
        hittable_list lights;
        auto m = shared_ptr<material>();
        lights.add(make_shared<quad>(point3(343,554,332), vec3(-130,0,0), vec3(0,0,-105), m));

        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [sampling-sphere]: <kbd>[main.cc]</kbd> 仅对球体进行采样]

</div>

<div class='together'>
这样会得到一个嘈杂的房间，但是球体下的焦散效果很好。我的代码运行时间是采样光源的5倍。这可能是因为击中玻璃的光线比较昂贵！

  ![<span class='num'>图像 13:</span> 带有玻璃球体的康奈尔盒子，使用新的概率密度函数
  ](../images/img-3.13-cornell-glass-sphere.jpg class='pixel')

</div>


向Hittable列表添加PDF函数
---------------------------------------
我们可能需要对球体和光源进行采样。我们可以通过创建两个分布的混合密度来实现。
我们可以在`ray_color()`函数中通过传递一个hittable列表并构建混合PDF来实现，或者我们可以向`hittable_list`添加PDF函数。
我认为这两种策略都可以很好地工作，但我选择对`hittable_list`进行修改。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class hittable_list : public hittable {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double pdf_value(const point3& origin, const vec3& direction) const override {
            auto weight = 1.0 / objects.size();
            auto sum = 0.0;

            for (const auto& object : objects)
                sum += weight * object->pdf_value(origin, direction);

            return sum;
        }

        vec3 random(const point3& origin) const override {
            auto int_size = int(objects.size());
            return objects[random_int(0, int_size-1)]->random(origin);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        ...
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [density-mixture]: <kbd>[hittable_list.h]</kbd> 创建密度的混合]

<div class='together'>
我们从`main()`函数中组装一个列表传递给`render()`：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    int main() {
        ...

        // 光源列表
        hittable_list lights;
        auto m = shared_ptr<material>();
        lights.add(make_shared<quad>(point3(343,554,332), vec3(-130,0,0), vec3(0,0,-105), m));
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        lights.add(make_shared<sphere>(point3(190, 90, 190), 90, m));
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [scene-density-mixture]: <kbd>[main.cc]</kbd> 更新场景]

</div>

<div class='together'>
我们使用1000个样本得到了一个不错的图像：

  ![<span class='num'>图像 14:</span> 康奈尔盒子使用玻璃和光源的混合PDF
  ](../images/img-3.14-glass-and-light.jpg class='pixel')

</div>


处理表面痤疮
----------------------
一个敏锐的读者指出上面的图像中有一些黑色斑点。所有的蒙特卡洛光线追踪器都有一个主循环：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    pixel_color = average(many many samples)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果你在渲染中遇到了某种形式的痤疮，而这些痤疮是白色或黑色的——其中一个“坏”样本似乎会破坏整个像素——那么该样本可能是一个巨大的数或者是`NaN`（不是一个数字）。
这种特定的痤疮可能是`NaN`。我的渲染中大约每1亿到1千万条光线中会出现一次这样的情况。

<div class='together'>
所以我们面临一个重要的决策：是将这个错误掩盖起来并检查`NaN`，还是直接将`NaN`置为零并希望这不会在后面给我们带来麻烦。
我总是倾向于采取懒惰的策略，特别是当我知道使用浮点数很困难时。首先，我们如何检查`NaN`？我永远记得一个关于`NaN`的特性，
那就是`NaN`不等于它自己。利用这个技巧，我们更新`write_color()`函数，将任何`NaN`组件替换为零：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    void write_color(std::ostream& out, const color& pixel_color, int samples_per_pixel) {
        auto r = pixel_color.x();
        auto g = pixel_color.y();
        auto b = pixel_color.z();


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        // 将NaN组件替换为零。
        if (r != r) r = 0.0;
        if (g != g) g = 0.0;
        if (b != b) b = 0.0;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        // 将颜色除以样本数，并进行gamma校正（gamma=2.0）。
        auto scale = 1.0 / samples_per_pixel;
        r = sqrt(scale * r);
        g = sqrt(scale * g);
        b = sqrt(scale * b);

        // 将每个颜色分量的[0,255]范围内的值写入输出流。
        static const interval intensity(0.000, 0.999);
        out << int(256 * intensity.clamp(r)) << ' '
            << int(256 * intensity.clamp(g)) << ' '
            << int(256 * intensity.clamp(b)) << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [write-color-nan]: <kbd>[color.h]</kbd> 可处理NaN的write_color函数]

</div>

<div class='together'>
令人高兴的是，黑色斑点消失了：

  ![<span class='num'>图像 15：</span>带有抗痤疮颜色函数的康奈尔盒子](../images/img-3.15-book3-final.jpg class='pixel')

</div>



你的余生
====================================================================================================
本书的目的是详细介绍开发基于物理的渲染器采样方法时所需的所有细节（dotting all the i's and crossing all of the t's）。
现在，你应该能够将所有这些细节应用到不同的潜在路径中。

如果你想探索蒙特卡洛方法，可以研究双向和路径空间方法，如Metropolis算法。你的概率空间不再是固体角度，
而是路径空间，其中路径是高维空间中的多维点。不要被吓到——如果你可以用一组数字描述一个对象，
数学家称之为所有可能数组的空间中的一个点。这不仅仅是为了好看。一旦你得到了这样一个清晰的抽象，
你的代码也可以变得清晰起来。清晰的抽象是编程的核心！

如果你想做电影渲染器，看看工作室和Solid Angle的论文。他们对自己的工作非常开放。

如果你想做高性能光线追踪，首先看看Intel和NVIDIA的论文。他们也非常开放。

如果你想做硬核基于物理的渲染器，将你的渲染器从RGB转换为光谱。我非常喜欢每条光线都有一个随机波长，
而且程序中几乎所有的RGB都变成浮点数。听起来效率低下，但实际上并不是！

无论你选择哪个方向，都要添加一个光泽的BRDF模型。有很多选择，每个模型都有其优势。

玩得开心！

[Peter Shirley][]<br>
Salt Lake City, March, 2016



                               (insert acknowledgments.md.html here)



Citing This Book
====================================================================================================
Consistent citations make it easier to identify the source, location and versions of this work. If
you are citing this book, we ask that you try to use one of the following forms if possible.

Basic Data
-----------
  - **Title (series)**: “Ray Tracing in One Weekend Series”
  - **Title (book)**: “Ray Tracing: The Rest of Your Life”
  - **Author**: Peter Shirley, Trevor David Black, Steve Hollasch
  - **Version/Edition**: v4.0.0-alpha.2
  - **Date**: 2023-XX-XX
  - **URL (series)**: https://raytracing.github.io/
  - **URL (book)**: https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html

Snippets
---------

  ### Markdown
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [_Ray Tracing: The Rest of Your Life_](https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ### HTML
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    <a href='https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html'>
        <cite>Ray Tracing: The Rest of Your Life</cite>
    </a>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ### LaTeX and BibTex
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~\cite{Shirley2023RTW3}

    @misc{Shirley2023RTW3,
       title = {Ray Tracing: The Rest of Your Life},
       author = {Peter Shirley, Trevor David Black, Steve Hollasch},
       year = {2023},
       month = {XXX},
       note = {\small \texttt{https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html}},
       url = {https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html}
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ### BibLaTeX
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    \usepackage{biblatex}

    ~\cite{Shirley2023RTW3}

    @online{Shirley2023RTW3,
       title = {Ray Tracing: The Rest of Your Life},
       author = {Peter Shirley, Trevor David Black, Steve Hollasch},
       year = {2023},
       month = {XXX},
       url = {https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html}
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ### IEEE
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    “Ray Tracing: The Rest of Your Life.”
    raytracing.github.io/books/RayTracingTheRestOfYourLife.html
    (accessed MMM. DD, YYYY)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ### MLA:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ray Tracing: The Rest of Your Life. raytracing.github.io/books/RayTracingTheRestOfYourLife.html
    Accessed DD MMM. YYYY.
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


[Peter Shirley]:      https://github.com/petershirley
[Steve Hollasch]:     https://github.com/hollasch
[Trevor David Black]: https://github.com/trevordblack



<!-- Markdeep: https://casual-effects.com/markdeep/ -->
<link rel='stylesheet' href='../style/book.css'>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep.min.js"></script>
<script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
