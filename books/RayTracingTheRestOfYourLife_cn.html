<meta charset="utf-8">
<link rel="icon" type="image/png" href="../favicon.png">
<!-- Markdeep: https://casual-effects.com/markdeep/ -->



                               **Ray Tracing: The Rest of Your Life**
                   [Peter Shirley][], [Trevor David Black][], [Steve Hollasch][]
                                                <br>
                                     Version 4.0.0-alpha.2, 2023-XX-XX
                                                <br>
                      Copyright 2018-2023 Peter Shirley. All rights reserved.



概述
====================================================================================================
在《一周末光线追踪》和《一周末光线追踪》中，你构建了一个“真实”的光线追踪器。

如果你有动力，你可以利用这些书中的源代码和信息来实现任何你想要的视觉效果。
这些源代码为你构建一个小型爱好项目的光线追踪器提供了有意义且稳定的基础。
商业光线追踪器中的大多数视觉效果都依赖于这两本书中描述的技术。然而，如果缺乏数学基础，
你将无法添加越来越复杂的视觉效果，如次表面散射或嵌套介质。在本书中，我假设你要么是一个非常感兴趣的学生，
要么是一个从事与光线追踪相关职业的人。我们将深入探讨创建一个非常严肃的光线追踪器的数学知识。完成后，
你将具备使用和修改许多流行领域中的商业光线追踪器的能力，如电影、电视、产品设计和建筑行业。

在这本简短的书中，我没有涵盖很多内容。例如，有很多种编写蒙特卡洛渲染程序的方法，我只深入介绍了其中一种。
我没有涵盖阴影射线（而是让射线更有可能朝向光源），也没有涵盖双向方法、Metropolis方法或光子映射。
你会在所谓的“严肃光线追踪器”中找到许多这些技术，但它们在这里没有涵盖，因为更重要的是涵盖领域的概念、数学和术语。
我认为这本书是一个深入了解的开始，它将为你提供一些概念、数学和术语，以便你学习这些和其他有趣的技术。

希望你会像我一样对数学感到着迷。

与以前一样，https://in1weekend.blogspot.com/ 上会有进一步的阅读和参考资料。

这些书已经经过格式化，可以直接从浏览器中打印。我们还在“资产”部分包含了每本书的PDF版本。

感谢所有在这个项目中帮助过的人。你可以在本书末尾的致谢部分找到他们的名字。

---

另：从本章的中文化版本开始，Rust代码将不再放入单独的文件，而是直接整合到C++代码片段之下。并像此段文字一样前后用分割线分开。

使用`cargo`创建工程

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    cargo new --name the_test_of_your_life TheRestOfYourLife
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---



一个简单的蒙特卡洛程序
====================================================================================================
让我们从最简单的蒙特卡洛程序开始。如果你对蒙特卡洛程序不熟悉，那么停下来让我给你介绍一下。随机化算法分为两种：
蒙特卡洛算法和拉斯维加斯算法。随机化算法在计算机图形学中随处可见，所以建立一个良好的基础是个不错的主意。
随机化算法在计算过程中使用了一定程度的随机性。拉斯维加斯（LV）随机算法总是能够产生正确的结果，
而蒙特卡洛（MC）算法**可能**会产生正确的结果，但经常会出错！但是对于像光线追踪这样特别复杂的问题，
我们可能并不是非常追求完全准确，而是希望在合理的时间内得到一个答案。拉斯维加斯算法最经典的例子就是**快速排序**算法。
快速排序算法总是能够完成排序，但完成所需的时间是随机的。
另一个很好的拉斯维加斯算法的例子是我们用来选择单位球中随机点的代码：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    inline vec3 random_in_unit_sphere() {
        while (true) {
            auto p = vec3::random(-1,1);
            if (p.length_squared() < 1)
                return p;
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [las-vegas-algo]: <kbd>[vec3.h]</kbd> 一个拉斯维加斯算法]

这段代码最终总会得到一个单位球中的随机点，但我们无法预先知道需要多长时间。可能只需要1次迭代，也可能需要2次、
3次、4次甚至更多次。而蒙特卡洛程序将给出一个统计估计的答案，随着运行时间的增加，这个估计将变得越来越准确。
这意味着在某个时刻，我们可以决定答案已经足够准确，然后停止计算。
简单程序产生嘈杂但越来越好的答案的这种基本特性就是蒙特卡洛的全部内容，
对于像图形学这样不需要极高精度的应用特别有效。


估算π
--------------
蒙特卡洛算法的经典例子就是估算π，所以我们来做这个。有很多方法可以估算π，其中包括了著名的Buffon Needle问题。
我们将进行一个受此方法启发的变体。假设你有一个内切于正方形的圆：

  ![Figure [circ-square]: 用一个圆内切于一个正方形来估算π
  ](../images/fig-3.01-circ-square.jpg)

现在，假设你在正方形内随机选择点。最终落在圆内的随机点的比例应该与圆的面积成比例。
实际上，这个比例应该等于圆的面积与正方形的面积的比值：

  $ \frac{\pi r^2}{(2r)^2} = \frac{\pi}{4} $

<div class='together'>
由于$r$相互抵消，我们可以选择计算上方便的值。让我们选择$r=1$，以原点为中心：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <stdlib.h>

    int main() {
        int N = 100000;
        int inside_circle = 0;
        for (int i = 0; i < N; i++) {
            auto x = random_double(-1,1);
            auto y = random_double(-1,1);
            if (x*x + y*y < 1)
                inside_circle++;
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "Estimate of Pi = " << (4.0 * inside_circle) / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [estpi-1]: <kbd>[pi.cc]</kbd> 估算π]

---
Rust实现

本章开始由于需要编译多个不同的案例，因此先需修改Cargo.toml文件。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ toml
    [package]
    name = "the_rest_of_your_life"
    version = "0.1.0"
    edition = "2021"

    [[bin]]
    name = "pi"
    path = "src/bin/pi.rs"
    test = false

    [dependencies]
    rand = "0"
    stb_image = "0.2"
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

通过`[[bin]]`的方式加入不同的案例，同时为了让不同的案例能共享代码。添加src/lib.rs文件。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub mod vec3;
    pub mod color;
    pub mod ray;
    pub mod hittable;
    pub mod sphere;
    pub mod hittable_list;
    pub mod rtweekend;
    pub mod interval;
    pub mod camera;
    pub mod material;
    pub mod aabb;
    pub mod bvh;
    pub mod texture;
    pub mod rtw_stb_image;
    pub mod perlin;
    pub mod quad;
    pub mod constant_medium;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

现在开始实现pi的计算：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double_range;

    fn main() {
        const N: usize = 100000;
        let mut inside_circle = 0;
        (0..N).for_each(|_| {
            let x = random_double_range(-1.0, 1.0);
            let y = random_double_range(-1.0, 1.0);
            if x * x + y * y < 1.0 {
            inside_circle += 1;
            }
        });
        println!("Estimate of pi: {:.12}", 4.0 * inside_circle as f64 / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

得到的π的答案会因为初始随机种子的不同而在不同的计算机上有所变化。在我的计算机上，
这给出的答案是`Estimate of Pi = 3.143760000000`。

</div>


显示收敛性
--------------------
如果我们将程序修改为无限运行，并且只打印出一个运行时的估计值：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <stdlib.h>

    int main() {
        int inside_circle = 0;
        int runs = 0;
        std::cout << std::fixed << std::setprecision(12);
        while (true) {
            runs++;
            auto x = random_double(-1,1);
            auto y = random_double(-1,1);
            if (x*x + y*y < 1)
                inside_circle++;

            if (runs % 100000 == 0)
                std::cout << "Estimate of Pi = "
                          << (4.0 * inside_circle) / runs
                          << '\n';
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [estpi-2]: <kbd>[pi.cc]</kbd> 估算π，版本2]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double_range;

    fn main() {
        let mut inside_circle = 0;
        let mut runs = 0;
        loop {
            runs += 1;
            let x = random_double_range(-1.0, 1.0);
            let y = random_double_range(-1.0, 1.0);
            if x * x + y * y < 1.0 {
                inside_circle += 1;
            }

            if runs % 100000 == 0 {
                println!("Estimate of pi: {:.12}", 4.0 * inside_circle as f64 / runs as f64);
            }
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---


分层采样（抖动）
-------------------------------
我们很快接近$\pi$，然后慢慢逼近它。这是“收益递减定律”的一个例子，每个样本的帮助都比上一个样本少。
这是蒙特卡洛的最糟糕的部分。我们可以通过对样本进行“分层采样”（通常称为“抖动”）来减轻这种收益递减，
即不再随机采样，而是在一个网格中每个位置取一个样本：

  ![图 [jitter]: 使用抖动点进行采样](../images/fig-3.02-jitter.jpg)

<div class='together'>
这改变了样本生成的方式，但我们需要事先知道要采样多少个样本，因为我们需要知道网格的大小。让我们取一百万个样本，
然后用两种方式进行尝试：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>

    int main() {
        int inside_circle = 0;
        int inside_circle_stratified = 0;
        int sqrt_N = 1000;
        for (int i = 0; i < sqrt_N; i++) {
            for (int j = 0; j < sqrt_N; j++) {
                auto x = random_double(-1,1);
                auto y = random_double(-1,1);
                if (x*x + y*y < 1)
                    inside_circle++;
                x = 2*((i + random_double()) / sqrt_N) - 1;
                y = 2*((j + random_double()) / sqrt_N) - 1;
                if (x*x + y*y < 1)
                    inside_circle_stratified++;
            }
        }

        std::cout << std::fixed << std::setprecision(12);
        std::cout
            << "Regular    Estimate of Pi = "
            << (4.0 * inside_circle) / (sqrt_N*sqrt_N) << '\n'
            << "Stratified Estimate of Pi = "
            << (4.0 * inside_circle_stratified) / (sqrt_N*sqrt_N) << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [estpi-3]: <kbd>[pi.cc]</kbd> 估算π，版本3]

</div>

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::{
        random_double,
        random_double_range,
    };

    fn main() {
        let mut inside_circle = 0;
        let mut inside_circle_stratified = 0;
        const SQRT_N: usize = 1000;
        (0..SQRT_N).for_each(|i| {
            (0..SQRT_N).for_each(|j| {
                let x = random_double_range(-1.0, 1.0);
                let y = random_double_range(-1.0, 1.0);
                if x * x + y * y < 1.0 {
                    inside_circle += 1;
                }
                let x = 2.0 * (i as f64 + random_double()) / SQRT_N as f64 - 1.0;
                let y = 2.0 * (j as f64 + random_double()) / SQRT_N as f64 - 1.0;
                if x * x + y * y < 1.0 {
                    inside_circle_stratified += 1;
                }
            })
        });

        println!("Regular    Estimate of Pi = {:.12}", 4.0 * inside_circle as f64 / (SQRT_N * SQRT_N) as f64);
        println!("Stratified Estimate of Pi = {:.12}", 4.0 * inside_circle_stratified as f64 / (SQRT_N * SQRT_N) as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

<div class='together'>
在我的电脑上，结果如下：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Regular    Estimate of Pi = 3.141184000000
    Stratified Estimate of Pi = 3.141460000000
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

其中π的前12位小数为：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    3.141592653589
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

有趣的是，分层方法不仅更好，而且收敛速度更快！不幸的是，这个优势随着问题的维度增加而减小（例如，
对于3D球体体积版本，差距会更小）。这被称为“维度诅咒”。光线追踪是一个非常高维的算法，每次反射都会增加两个新的维度：
$\phi_o$和$\theta_o$。在本书中，我们不会对输出的反射角进行分层，因为这有点复杂，但目前在这个领域有很多有趣的研究正在进行中。

作为中间步骤，我们将对每个像素位置周围的采样位置进行分层。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include "camera.h"
    #include "color.h"
    #include "hittable_list.h"
    #include "material.h"
    #include "quad.h"
    #include "sphere.h"

    int main() {
        hittable_list world;

        auto red   = make_shared<lambertian>(color(.65, .05, .05));
        auto white = make_shared<lambertian>(color(.73, .73, .73));
        auto green = make_shared<lambertian>(color(.12, .45, .15));
        auto light = make_shared<diffuse_light>(color(15, 15, 15));

        // Cornell box sides
        world.add(make_shared<quad>(point3(555,0,0), vec3(0,0,555), vec3(0,555,0), green));
        world.add(make_shared<quad>(point3(0,0,555), vec3(0,0,-555), vec3(0,555,0), red));
        world.add(make_shared<quad>(point3(0,555,0), vec3(555,0,0), vec3(0,0,555), white));
        world.add(make_shared<quad>(point3(0,0,555), vec3(555,0,0), vec3(0,0,-555), white));
        world.add(make_shared<quad>(point3(555,0,555), vec3(-555,0,0), vec3(0,555,0), white));

        // Light
        world.add(make_shared<quad>(point3(213,554,227), vec3(130,0,0), vec3(0,0,105), light));

        // Box 1
        shared_ptr<hittable> box1 = box(point3(0,0,0), point3(165,330,165), white);
        box1 = make_shared<rotate_y>(box1, 15);
        box1 = make_shared<translate>(box1, vec3(265,0,295));
        world.add(box1);

        // Box 2
        shared_ptr<hittable> box2 = box(point3(0,0,0), point3(165,165,165), white);
        box2 = make_shared<rotate_y>(box2, -18);
        box2 = make_shared<translate>(box2, vec3(130,0,65));
        world.add(box2);

        camera cam;

        cam.aspect_ratio      = 1.0;
        cam.image_width       = 600;
        cam.samples_per_pixel = 64;
        cam.max_depth         = 50;
        cam.background        = color(0,0,0);

        cam.vfov     = 40;
        cam.lookfrom = point3(278, 278, -800);
        cam.lookat   = point3(278, 278, 0);
        cam.vup      = vec3(0, 1, 0);

        cam.defocus_angle = 0;

        cam.render(world, lights);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [estpi-3]: <kbd>[main.cc]</kbd> 在像素内部进行样本分层]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub mod vec3;
    pub mod color;
    pub mod ray;
    pub mod hittable;
    pub mod sphere;
    pub mod hittable_list;
    pub mod rtweekend;
    pub mod interval;
    pub mod camera;
    pub mod material;
    pub mod aabb;
    pub mod bvh;
    pub mod texture;
    pub mod rtw_stb_image;
    pub mod perlin;
    pub mod quad;
    pub mod constant_medium;

    use std::rc::Rc;

    use vec3::{Vec3, Point3};
    use color::Color;
    use hittable_list::HittableList;
    use camera::Camera;
    use material::{
        Material,
        Lambertian,
        DiffuseLight,
    };
    use quad::{
        Quad,
        make_box,
    };
    use hittable::{
        Translate,
        RotateY,
    };

    fn cornell_box() {
        let mut world = HittableList::default();

        let red: Rc<dyn Material> = Rc::new(Lambertian::new(Color::new(0.65, 0.05, 0.05)));
        let white: Rc<dyn Material> = Rc::new(Lambertian::new(Color::new(0.73, 0.73, 0.73)));
        let green: Rc<dyn Material> = Rc::new(Lambertian::new(Color::new(0.12, 0.45, 0.15)));
        let light: Rc<dyn Material> = Rc::new(DiffuseLight::new_with_color(Color::new(15.0, 15.0, 15.0)));

        world.add(Rc::new(
            Quad::new(
                Point3::new(555.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 555.0, 0.0),
                vec3::Vec3::new(0.0, 0.0, 555.0),
                green
            )
        ));
        world.add(Rc::new(
            Quad::new(
                Point3::new(0.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 555.0, 0.0),
                vec3::Vec3::new(0.0, 0.0, 555.0),
                red
            )
        ));
        world.add(Rc::new(
            Quad::new(
                Point3::new(343.0, 554.0, 332.0),
                vec3::Vec3::new(-130.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 0.0, -105.0),
                light
            )
        ));
        world.add(Rc::new(
            Quad::new(
                Point3::new(0.0, 0.0, 0.0),
                vec3::Vec3::new(555.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 0.0, 555.0),
                Rc::clone(&white)
            )
        ));
        world.add(Rc::new(
            Quad::new(
                Point3::new(555.0, 555.0, 555.0),
                vec3::Vec3::new(-555.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 0.0, -555.0),
                Rc::clone(&white)
            )
        ));
        world.add(Rc::new(
            Quad::new(
                Point3::new(0.0, 0.0, 555.0),
                vec3::Vec3::new(555.0, 0.0, 0.0),
                vec3::Vec3::new(0.0, 555.0, 0.0),
                Rc::clone(&white)
            )
        ));

        let box1 = make_box(
            Point3::new(0.0, 0.0, 0.0),
            Vec3::new(165.0, 330.0, 165.0),
            Rc::clone(&white)
        );
        let box1 = Rc::new(RotateY::new(box1, 15.0));
        let box1 = Rc::new(Translate::new(box1, vec3::Vec3::new(265.0, 0.0, 295.0)));
        world.add(box1);

        let box2 = make_box(
            Point3::new(0.0, 0.0, 0.0),
            Vec3::new(165.0, 165.0, 165.0),
            Rc::clone(&white)
        );
        let box2 = Rc::new(RotateY::new(box2, -18.0));
        let box2 = Rc::new(Translate::new(box2, vec3::Vec3::new(130.0, 0.0, 65.0)));
        world.add(box2);

        let mut cam = Camera::default();

        cam.aspect_ratio = 1.0;
        cam.image_width = 400;
        cam.samples_per_pixel = 50;
        cam.max_depth = 10;
        cam.background = Color::default();

        cam.vfov = 40.0;
        cam.lookfrom = Point3::new(278.0, 278.0, -800.0);
        cam.lookat = Point3::new(278.0, 278.0, 0.0);
        cam.vup = vec3::Vec3::new(0.0, 1.0, 0.0);

        cam.defocus_angle = 0.0;

        cam.render(&world);
    }

    fn main() {
        cornell_box();
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      public:
        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        void initialize() {
            ...
            sqrt_spp = int(sqrt(samples_per_pixel));
            recip_sqrt_spp = 1.0 / sqrt_spp;
            ...
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        void render(const hittable& world) {
            initialize();

            std::cout << "P3\n" << image_width << ' ' << image_height << "\n255\n";

            for (int j = 0; j < image_height; j++) {
                std::clog << "\rScanlines remaining: " << (image_height - j) << ' ' << std::flush;
                for (int i = 0; i < image_width; i++) {
                    color pixel_color(0,0,0);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
                    for (int s_j = 0; s_j < sqrt_spp; s_j++) {
                        for (int s_i = 0; s_i < sqrt_spp; s_i++) {
                            ray r = get_ray(i, j, s_i, s_j);
                            pixel_color += ray_color(r, max_depth, world);
                        }
                    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
                    write_color(std::cout, pixel_color, samples_per_pixel);
                }
            }

            std::clog << "\rDone.                 \n";
        }
        ...
      private:
        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        ray get_ray(int i, int j, int s_i, int s_j) const {
            // 从相机散焦盘发出一个随机采样的相机光线，该光线经过像素位置附近的随机采样。
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            auto pixel_center = pixel00_loc + (i * pixel_delta_u) + (j * pixel_delta_v);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto pixel_sample = pixel_center + pixel_sample_square(s_i, s_j);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            auto ray_origin = (defocus_angle <= 0) ? center : defocus_disk_sample();
            auto ray_direction = pixel_sample - ray_origin;
            auto ray_time = random_double();

            return ray(ray_origin, ray_direction, ray_time);
        }


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        vec3 pixel_sample_square(int s_i, int s_j) const {
            // 返回位于原点周围的像素正方形内的随机点，给定两个子像素索引。
            auto px = -0.5 + recip_sqrt_spp * (s_i + random_double());
            auto py = -0.5 + recip_sqrt_spp * (s_j + random_double());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            return (px * pixel_delta_u) + (py * pixel_delta_v);
        }

        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        int sqrt_spp;
        double recip_sqrt_spp;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [render-estpi-3]: <kbd>[camera.h]</kbd> 在像素内部进行样本分层（渲染）]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub struct Camera {
        ...
        image_height: usize,    // Rendered image height
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        sqrt_spp: usize,        // Square root of samples per pixel
        recip_sqrt_spp: f64,    // Reciprocal of square root of samples per pixel
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
        center: Point3,         // Camera center
        ...
    }

    impl Default for Camera {
        fn default() -> Self {
            Self {
                ...
                image_height: 0,
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                sqrt_spp: 10.0_f64.sqrt() as usize,
                recip_sqrt_spp: 1.0 / (10.0_f64.sqrt()),
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
                center: Point3::default(),
                ...
            }
        }
    }

    impl Camera {
        pub fn render(&mut self, world: &dyn Hittable) {
            self.initialize();

            println!("P3\n{} {}\n255", self.image_width, self.image_height);
            let stdout = std::io::stdout();

            for j in 0..self.image_height {
                eprintln!("\rScanlines remaining: {}", self.image_height - j);
                for i in 0..self.image_width {
                    let mut pixel_color = Color::default();
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                    for s_j in 0..self.sqrt_spp {
                        for s_i in 0..self.sqrt_spp {
                            let r = self.get_ray(i as i32, j as i32, s_i as i32, s_j as i32);
                            pixel_color += self.ray_color(&r, self.max_depth, world);
                        }
                    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
                    pixel_color.write_color(&mut stdout.lock(), self.samples_per_pixel).unwrap();
                }
            }

            eprintln!("\nDone.");
        }

        fn initialize(&mut self) {
            self.image_height = (self.image_width as f64 / self.aspect_ratio) as usize;
            self.image_height = if self.image_height < 1 { 1 } else { self.image_height };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
            self.sqrt_spp = (self.samples_per_pixel as f64).sqrt() as usize;
            self.recip_sqrt_spp = 1.0 / (self.sqrt_spp as f64);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

            self.center = self.lookfrom;
            ...
        }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn get_ray(&self, i: i32, j: i32, s_i: i32, s_j: i32) -> Ray {
            // Get a randomly sampled camera ray for the pixel at location i,j.
            let pixel_center = self.pixel00_loc + i as f64 * self.pixel_delta_u + j as f64 * self.pixel_delta_v;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
            let pixel_sample = pixel_center + self.pixel_sample_square(s_i, s_j);
            ...
        }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn pixel_sample_square(&self, s_i: i32, s_j: i32) -> Vec3 {
            // Returns a random point in the square surrounding a pixel at the origin.
            let px = -0.5 + self.recip_sqrt_spp * (s_i as f64 + rtweekend::random_double());
            let py = -0.5 + self.recip_sqrt_spp * (s_j as f64 + rtweekend::random_double());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
            px * self.pixel_delta_u + py * self.pixel_delta_v
        }
        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

<div class='together'>
如果我们将没有分层的结果与分层后的结果进行比较：

  ![<span class='num'>图像1：</span> 康奈尔盒，无分层
  ](../images/img-3.01-cornell-no-strat.png class='pixel')

</div>

<div class='together'>
然后，使用分层后的结果：

  ![<span class='num'>图像2：</span> 康奈尔盒，分层
  ](../images/img-3.02-cornell-strat.png class='pixel')

如果你眯起眼睛看，应该能够看到平面边缘和盒子边缘的更清晰的对比度。这种效果在具有更高变化频率的位置更为明显。
高频变化也可以被视为高信息密度。对于我们的康奈尔盒场景，所有的材质都是哑光的，顶部有一个柔和的面光源，
因此只有在物体边缘才有高信息密度的位置。在具有纹理和反射材质的情况下，效果将更加明显。

如果你正在进行单次反射、阴影或某些严格的2D问题，你肯定需要进行分层采样。

</div>


一维蒙特卡洛积分
====================================================================================================
我们的Buffon Needle示例是通过求解圆的面积与内接正方形面积的比值来计算$\pi$的一种方法：

    $$ \frac{\operatorname{area}(\mathit{circle})}{\operatorname{area}(\mathit{square})}
       = \frac{\pi}{4}
    $$

我们在内接正方形中选择了一堆随机点，并计算其中也在单位圆内的点的比例。随着添加更多的点，这个比例会趋近于$\frac{\pi}{4}$。
如果我们不知道圆的面积，仍然可以使用上述比值来求解。我们知道单位圆和内接正方形的面积比是$\frac{\pi}{4}$，
并且我们知道内接正方形的面积是$4r^2$，因此我们可以使用这两个量来得到圆的面积：

    $$ \frac{\operatorname{area}(\mathit{circle})}{\operatorname{area}(\mathit{square})}
       = \frac{\pi}{4}
    $$

    $$ \frac{\operatorname{area}(\mathit{circle})}{(2r)^2} = \frac{\pi}{4} $$

    $$ \operatorname{area}(\mathit{circle}) = \frac{\pi}{4} 4r^2 $$

    $$ \operatorname{area}(\mathit{circle}) = \pi r^2 $$

我们选择半径为$r = 1$的圆，得到：

    $$ \operatorname{area}(\mathit{circle}) = \pi $$

<div class='together'>
我们上面的工作既可以用来求解$\pi$，也可以用来求解圆的面积：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <stdlib.h>

    int main() {
        int N = 100000;
        int inside_circle = 0;
        for (int i = 0; i < N; i++) {
            auto x = random_double(-1,1);
            auto y = random_double(-1,1);
            if (x*x + y*y < 1)
                inside_circle++;
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "Estimated area of unit circle = " << (4.0 * inside_circle) / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [estunitcircle]: <kbd>[pi.cc]</kbd> 估算单位圆的面积]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double_range;

    fn main() {
        const N: usize = 100000;
        let mut inside_circle = 0;
        (0..N).for_each(|_| {
            let x = random_double_range(-1.0, 1.0);
            let y = random_double_range(-1.0, 1.0);
            if x * x + y * y < 1.0 {
                inside_circle += 1;
            }
        });
        println!("Estimated area of unit circle: {:.12}", 4.0 * inside_circle as f64 / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>


期望值
--------------
让我们退后一步，更加一般地思考一下我们的蒙特卡洛算法。

假设我们有以下内容：

1. 一个包含成员 $x_i$ 的值列表 $X$：

    $$ X = (x_0, x_1, ..., x_{N-1})  $$

2. 一个连续函数 $f(x)$，它接受列表中的成员：

    $$ y_i = f(x_i) $$

3. 一个以列表 $X$ 为输入，产生列表 $Y$ 为输出的函数 $F(X)$：

    $$ Y = F(X) $$

4. 输出列表 $Y$ 的成员为 $y_i$：

    $$ Y = (y_0, y_1, ..., y_{N-1}) = (f(x_0), f(x_1), ..., f(x_{N-1})) $$

如果我们假设上述所有条件成立，那么我们可以通过以下方式求解列表 $Y$ 的算术平均值，即平均值：

    $$ \operatorname{average}(Y) = E[Y] = \frac{1}{N} \sum_{i=0}^{N-1} y_i $$
    $$ = \frac{1}{N} \sum_{i=0}^{N-1} f(x_i) $$
    $$ = E[F(X)] $$

其中 $E[Y]$ 被称为 $Y$ 的**期望值**。如果 $x_i$ 的值是从连续区间 $[a,b]$ 中随机选择的，
使得对于所有的 $i$，$ a \leq x_i \leq b $，
那么 $E[F(X)]$ 将近似于连续函数 $f(x')$ 在相同区间 $ a \leq x' \leq b $ 上的平均值。

    $$ E[f(x') | a \leq x' \leq b] \approx E[F(X) | X =
        \{\small x_i | a \leq x_i \leq b \normalsize \} ] $$
    $$ \approx E[Y = \{\small y_i = f(x_i) | a \leq x_i \leq b \normalsize \} ] $$

    $$ \approx \frac{1}{N} \sum_{i=0}^{N-1} f(x_i) $$

如果我们取样本数 $N$ 并将 $N$ 趋近于无穷大，那么我们得到以下结果：

    $$ E[f(x') | a \leq x' \leq b]  = \lim_{N \to \infty} \frac{1}{N} \sum_{i=0}^{N-1} f(x_i) $$

在连续区间 $[a,b]$ 内，连续函数 $f(x')$ 的期望值可以通过在该区间内求和无限多个随机点来完全表示。
随着这些点的数量趋近于无穷大，输出的平均值趋近于准确答案。这就是蒙特卡洛算法。

随机取样并不是求解区间上的期望值的唯一方法。我们还可以选择采样点的位置。如果我们在区间 $[a,b]$ 上有 $N$ 个样本点，
我们可以选择等间距地分布这些点：

    $$ x_i = a + i \Delta x $$
    $$ \Delta x = \frac{b - a}{N} $$

然后求解它们的期望值：

    $$ E[f(x') | a \leq x' \leq b] \approx \frac{1}{N} \sum_{i=0}^{N-1} f(x_i)
        \Big|_{x_i = a + i \Delta x} $$
    $$ E[f(x') | a \leq x' \leq b] \approx \frac{\Delta x}{b - a} \sum_{i=0}^{N-1} f(x_i)
        \Big|_{x_i = a + i \Delta x} $$
    $$ E[f(x') | a \leq x' \leq b] \approx \frac{1}{b - a} \sum_{i=0}^{N-1} f(x_i) \Delta x
        \Big|_{x_i = a + i \Delta x} $$

将 $N$ 趋近于无穷大：

    $$ E[f(x') | a \leq x' \leq b] = \lim_{N \to \infty} \frac{1}{b - a} \sum_{i=0}^{N-1}
        f(x_i) \Delta x \Big|_{x_i = a + i \Delta x} $$

这当然就是一个常规的积分：

    $$ E[f(x') | a \leq x' \leq b] = \frac{1}{b - a} \int_{a}^{b} f(x) dx $$

如果你还记得你的微积分课程，函数的积分就是该区间下曲线下的面积：

    $$ \operatorname{area}(f(x), a, b) = \int_{a}^{b} f(x) dx $$

因此，区间上的平均值与该区间中曲线下的面积密切相关。

    $$  E[f(x) | a \leq x \leq b] = \frac{1}{b - a} \cdot \operatorname{area}(f(x), a, b) $$

函数的积分和蒙特卡洛采样都可以用来求解特定区间上的平均值。虽然积分通过对区间的无限多个无穷小切片求和来求解平均值，
但蒙特卡洛算法通过求解区间内不断增加的随机采样点的总和来近似相同的平均值。
计算落在对象内部的点的数量并不是衡量其平均值或面积的唯一方法。积分也是一种常用的数学工具。
如果问题存在闭合形式，积分通常是最自然和清晰的表达方式。

我认为一些例子会有所帮助。


积分 x²
---------------
让我们来看一个经典的积分：

    $$ I = \int_{0}^{2} x^2 dx $$

我们可以使用积分来求解：

    $$ I = \frac{1}{3} x^3 \Big|_{0}^{2} $$
    $$ I = \frac{1}{3} (2^3 - 0^3) $$
    $$ I = \frac{8}{3} $$

或者，我们可以使用蒙特卡洛方法来求解积分。在计算机科学的符号表示中，我们可以写成：

    $$ I = \operatorname{area}( x^2, 0, 2 ) $$

我们还可以写成：

    $$  E[f(x) | a \leq x \leq b] = \frac{1}{b - a} \cdot \operatorname{area}(f(x), a, b) $$
    $$ \operatorname{average}(x^2, 0, 2) = \frac{1}{2 - 0} \cdot \operatorname{area}( x^2, 0, 2 ) $$
    $$ \operatorname{average}(x^2, 0, 2) = \frac{1}{2 - 0} \cdot I $$
    $$ I = 2 \cdot \operatorname{average}(x^2, 0, 2) $$

<div class='together'>
蒙特卡洛方法的实现：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <stdlib.h>

    int main() {
        int a = 0;
        int b = 2;
        int N = 1000000;
        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            auto x = random_double(a, b);
            sum += x*x;
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "I = " << (b - a) * (sum / N) << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-xsq-1]: <kbd>[integrate_x_sq.cc]</kbd> 积分 x^2]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double_range;

    fn main() {
        const A: f64 = 0.0;
        const B: f64 = 2.0;
        const N: usize = 1000000;
        let mut sum = 0.0;
        (0..N).for_each(|_| {
            let x = random_double_range(A, B);
            sum += x * x;
        });
        println!("I = {:.12}", (B - A) * sum / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
正如预期的那样，这个方法得到的结果与积分得到的准确答案大致相同，即 $I = 8/3$。你可能会指出这个例子并说，
实际上积分比蒙特卡洛方法要简单得多。对于函数 $f(x) = x^2$ 来说，这可能是正确的，但存在许多函数，
对于这些函数来说，使用蒙特卡洛方法求解可能比积分更简单，比如 $f(x) = sin^5(x)$。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        for (int i = 0; i < N; i++) {
            auto x = random_double(a, b);
            sum += pow(sin(x), 5.0);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-sin5]: 积分 sin^5]

</div>

<div class='together'>
我们还可以使用蒙特卡洛算法来处理无法进行解析积分的函数，比如 $f(x) = \ln(\sin(x))$。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    for (int i = 0; i < N; i++) {
        auto x = random_double(a, b);
        sum += log(sin(x));
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-ln-sin]: 积分 ln(sin)]

</div>

在图形学中，我们经常遇到一些可以明确写出但具有复杂解析积分的函数，或者经常遇到一些可以进行计算但无法明确写出的函数，
而且我们经常会遇到一些只能以概率方式进行评估的函数。第一、二本书中的 `ray_color` 函数就是一个只能以概率方式确定的函数的例子。
我们无法知道从任意给定位置在所有方向上能看到什么颜色，但我们可以统计估计从一个特定位置、一个特定方向上能看到的颜色。


密度函数
------------------
我们在前两本书中编写的`ray_color`函数，虽然简洁优雅，但存在一个相当**严重**的问题。小的光源会产生太多的噪点。
这是因为我们的均匀采样，而没有足够频繁地对这些光源进行采样。只有当光线向它们散射时，才会对光源进行采样，
但对于小的光源或远离的光源，这种情况可能不太可能发生。如果背景颜色是黑色，那么场景中真正的光源只来自于实际放置在场景中的灯光。
在表面上，可能有两条相交的光线，一条随机反射到光源，一条没有。反射到光源的光线将呈现出非常明亮的颜色。
反射到其他地方的光线将呈现出非常暗的颜色。这两种强度应该位于中间某处。如果我们将这两条光线都引导向光源，
我们可以减轻这个问题，但这将导致场景过于明亮。

对于给定的光线，我们通常从相机开始，穿过场景，最终到达光源。但是想象一下，如果我们从光源开始追踪同样的光线，
穿过场景，最终到达相机。这条光线将以较高的强度开始，并且在场景中的每次反弹中逐渐失去能量。
最终，它将到达相机，经过各种表面的反射后变暗并着色。现在，想象一下，如果这条光线被迫尽快朝相机反弹，
它将显得过于明亮，因为它没有经过连续的反弹而变暗。这类似于向光源发送更多的随机样本。
这将在很大程度上解决我们在亮像素旁边有暗像素的问题，但这将使得**所有**像素都变亮。

我们可以通过降低这些样本的权重来消除这种不准确性，以调整过采样的影响。我们如何进行这种调整呢？
首先，我们需要了解**概率密度函数**的概念。但要理解**概率密度函数**的概念，我们首先需要知道什么是**密度函数**。

**密度函数**只是直方图的连续版本。下面是来自维基百科直方图页面的一个示例直方图：

  ![Figure [histogram]: 直方图示例](../images/fig-3.03-histogram.jpg)

如果我们的数据源中有更多的项，那么每个项的频率会增加，但每个箱子的数量保持不变。
如果我们将数据分成更多的箱子，我们将有更多的箱子，但每个箱子中的每个项的频率会降低。
如果我们将箱子的数量提高到无穷大，我们将有无限多个零频率的箱子。为了解决这个问题，
我们将用**离散密度函数**替换我们的直方图，**离散密度函数**与**离散函数**的区别在于，
它将y轴归一化为总数的分数或百分比，即密度，而不是每个箱子的总计数。从**离散函数**转换为**离散密度函数**非常简单：

    $$ \text{第i个箱子的密度} = \frac{\text{第i个箱子中的项数}}
                                      {\text{总项数}} $$

一旦我们有了**离散密度函数**，我们就可以通过将离散值转换为连续值来将其转换为**密度函数**。

    $$ \text{箱子密度} = \frac{(\text{高度在}H\text{和}H'\text{之间的树的比例})}
                            {(H-H')} $$

因此，**密度函数**是一个连续的直方图，其中所有的值都相对于总数进行了归一化。
如果我们想要知道特定树的高度，我们可以创建一个**概率函数**，告诉我们我们的树在特定箱子中的可能性有多大。

    $$ \text{第i个箱子的概率} = \frac{\text{第i个箱子中的项数}}
                                          {\text{总项数}} $$

如果我们将我们的**概率函数**和（连续的）**密度函数**结合起来，我们可以将其解释为树高度的统计预测器：

    $$ \text{随机树的高度在} H \text{和} H' \text{之间的概率} =
        \text{箱子密度}\cdot(H-H') $$

事实上，通过这个连续的概率函数，我们现在可以说任何给定的树的高度有多大可能落在任意跨越多个箱子的范围内。
这就是**概率密度函数**（以下简称**PDF**）。简而言之，**PDF**是一个连续函数，可以进行积分，以确定一个积分上的结果有多大可能性。


构建一个概率密度函数（PDF）
-------------------
让我们创建一个PDF并通过实例来建立直觉。我们将使用以下函数：

  ![Figure [linear-pdf]: A linear PDF](../images/fig-3.04-linear-pdf.jpg)

这个函数是做什么的呢？我们知道，PDF只是一个连续函数，用于定义任意值范围的可能性。这个函数$p(r)$在0到2之间受限，
并且在该区间上线性增加。
因此，如果我们将这个函数作为PDF来生成一个随机数，那么接近零的数字出现的概率将小于接近二的数字出现的概率。

PDF $p(r)$是一个线性函数，从$r=0$开始，单调递增到$r=2$时达到最高点$p(2)$。$p(2)$的值是多少？$p(r)$的值是多少？
也许$p(2)$等于2？PDF从0线性增加到2，所以猜测$p(2)$的值为2似乎是合理的。至少看起来它不可能是0。

请记住，PDF是一个概率函数。我们将PDF限制在范围[0,2]内。PDF表示概率密度函数，用于表示概率列表的连续密度函数。
如果我们知道列表中的所有内容都包含在0和2之间，我们可以说在0和2之间获得值的概率为100%。因此，曲线下的面积必须等于1：

    $$ \operatorname{area}(p(r), 0, 2) = 1 $$

所有线性函数都可以表示为一个常数项乘以一个变量。

    $$ p(r) = C \cdot r $$

我们需要解出$C$的值。我们可以使用积分来逆推。

    $$ 1 = \operatorname{area}(p(r), 0, 2) $$
    $$ = \int_{0}^{2} C \cdot r dr $$
    $$ = C \cdot \int_{0}^{2} r dr $$
    $$ = C \cdot \frac{r^2}{2} \Big|_{0}^{2} $$
    $$ = C ( \frac{2^2}{2} - \frac{0}{2} ) $$
    $$ C = \frac{1}{2} $$

这给出了$p(r) = r/2$的PDF。就像直方图一样，我们可以对区域进行求和（积分）以确定$r$在某个区间$[x_0,x_1]$内的概率：

    $$ \operatorname{Probability} (r | x_0 \leq r \leq x_1 )
       = \operatorname{area}(p(r), x_0, x_1)
    $$

    $$ \operatorname{Probability} (r | x_0 \leq r \leq x_1 ) = \int_{x_0}^{x_1}  \frac{r}{2} dr $$

为了确认你的理解，你可以对区域$r=0$到$r=2$进行积分，你应该得到一个概率为1。

在研究了足够长时间的PDF之后，你可能会开始将PDF称为变量$r$取值为$x$的概率，即$p(r=x)$。但请不要这样做。
对于连续函数来说，变量取特定值的概率总是为零。PDF只能告诉你变量落在给定区间内的概率。
如果你检查的区间是一个单一的值，那么PDF将始终返回零概率，因为它的“bin”是无限细的（宽度为零）。
以下是这个事实的一个简单数学证明：

    $$ \operatorname{Probability} (r = x) = \int_{x}^{x}  p(r) dr $$
    $$ = P(r) \Big|_{x}^{x} $$
    $$ = P(x) - P(x) $$
    $$ = 0 $$

计算围绕$x$的区域的概率可能不为零：

    $$ \operatorname{Probability} (r | x - \Delta x < r < x + \Delta x ) =
         \operatorname{area}(p(r), x - \Delta x, x + \Delta x) $$
    $$ = P(x + \Delta x) - P(x - \Delta x) $$


选择样本
--------------------
如果我们有一个关心的函数的概率密度函数（PDF），那么我们就知道函数返回一个值落在任意区间内的概率。
我们可以利用这一点来确定我们应该采样的位置。记住，我们最初的目标是确定如何采样场景，以避免在非常亮的像素旁边出现非常暗的像素。
如果我们有场景的概率密度函数，我们可以在不使图像过度亮的情况下，通过概率地将样本导向光源。
我们已经说过，如果我们将样本导向光源，那么图像将变得不准确地过亮。
我们需要找出如何在不引入这种不准确性的情况下导向样本，稍后会解释这一点，但现在我们将专注于在有PDF的情况下生成样本。
我们如何使用PDF生成随机数？为此，我们需要一些更多的工具。不要担心，这不会无休止地进行下去！

<div class='together'>
我们的随机数生成器`random_double()`生成一个介于0和1之间的随机双精度数。该数生成器在0和1之间均匀分布，因此0和1之间的任何数的概率相等。
如果我们的PDF在一个区域上是均匀的，比如$[0,10]$，那么我们可以通过以下方式轻松地生成这个均匀PDF的完美样本：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    10.0 * random_double()
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

这是一个简单的情况，但我们关心的绝大多数情况都是非均匀的。我们需要找到一种方法将均匀随机数生成器转换为非均匀随机数生成器，其中分布由PDF定义。
我们假设存在一个函数$f(d)$，它接受均匀输入并产生由PDF加权的非均匀分布。我们只需要找到一种方法来解出$f(d)$。

对于上面给定的PDF，其中$p(r) = \frac{r}{2}$，随机样本的概率在2附近要高于0。在1.8和2.0之间获得一个数字的概率要比在0.0和0.2之间获得一个数字的概率大。
如果我们暂时放下数学帽子，戴上计算机科学帽子，也许我们可以找到一种巧妙的方法来划分PDF。
我们知道在2附近的概率要高于0附近的概率，但是哪个值将概率分成一半？
哪个值使得随机数有50%的概率高于它，有50%的概率低于它？哪个$x$满足以下方程：

    $$ 50\% = \int_{0}^{x}  \frac{r}{2} dr  = \int_{x}^{2}  \frac{r}{2} dr $$

解得：

    $$ 0.5 = \frac{r^2}{4} \Big|_{0}^{x} $$
    $$ 0.5 = \frac{x^2}{4} $$
    $$ x^2 = 2 $$
    $$ x = \sqrt{2} $$

作为一个粗略的近似，我们可以创建一个函数`f(d)`，它以`double d = random_double()`作为输入。如果`d`小于（或等于）0.5，
它会在$[0,\sqrt{2}]$范围内生成一个均匀数，如果`d`大于0.5，它会在$[\sqrt{2}, 2]$范围内生成一个均匀数。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    double f(double d)
    {
        if (d <= 0.5)
            return sqrt(2.0) * random_double();
        else
            return sqrt(2.0) + (2 - sqrt(2.0)) * random_double();
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [crude-approx]: 一个粗略的、一阶近似的非均匀PDF]

<div class='together'>
虽然我们最初的随机数生成器是从0到1均匀分布的：

   ![图 [uniform-dist]: 均匀分布](../images/fig-3.05-uniform-dist.jpg)

</div>

<div class='together'>
我们的新的、粗略的$\frac{r}{2}$的近似是非均匀的（但只是近似）：

    ![图 [approx-f]: r/2的非均匀分布](../images/fig-3.06-nonuniform-dist.jpg)

</div>

我们已经对上面的积分有了解析解，所以我们可以很容易地解出50%的值。但我们也可以通过实验解出这个50%的值。
对于那些我们无法或不想解析求解积分的函数，我们可以得到一个接近真实值的实验结果。让我们来看一个函数：

    $$ p(x) = e^{\frac{-x}{2 \pi}} sin^2(x) $$

<div class='together'>
它看起来有点像这样：

    ![图 [exp-sin2]: 我们不想解析求解的函数](../images/fig-3.07-exp-sin2.jpg)

</div>

<div class='together'>
此时，您应该熟悉如何实验性地求解曲线下的面积。我们将使用现有的代码，并稍作修改，以获得50%值的估计。我们想要解决的是给出半个总面积的$x$值。
当我们沿着解决N个样本的总和时，我们还将每个单独的样本与其`p(x)`值一起存储。在解决了总和之后，我们将对样本进行排序，并将它们相加，直到达到总和的一半。
例如，从$0$到$2\pi$：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <algorithm>
    #include <vector>
    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <cmath>
    #include <stdlib.h>

    struct sample {
        double x;
        double p_x;
    };

    bool compare_by_x(const sample& a, const sample& b) {
        return a.x < b.x;
    }

    int main() {
        unsigned int N = 10000;
        double sum = 0.0;

        // iterate through all of our samples
        std::vector<sample> samples;
        for (unsigned int i = 0; i < N; i++) {
            // Get the area under the curve
            auto x = random_double(0, 2*pi);
            auto sin_x = sin(x);
            auto p_x = exp(-x / (2*pi)) * sin_x * sin_x;
            sum += p_x;
            // store this sample
            sample this_sample = {x, p_x};
            samples.push_back(this_sample);
        }

        // Sort the samples by x
        std::sort(samples.begin(), samples.end(), compare_by_x);

        // Find out the sample at which we have half of our area
        double half_sum = sum / 2.0;
        double halfway_point = 0.0;
        double accum = 0.0;
        for (unsigned int i = 0; i < N; i++){
            accum += samples[i].p_x;
            if (accum >= half_sum) {
                halfway_point = samples[i].x;
                break;
            }
        }

        std::cout << std::fixed << std::setprecision(12);
        std::cout << "Average = " << sum / N << '\n';
        std::cout << "Area under curve = " << 2 * pi * sum / N << '\n';
        std::cout << "Halfway = " << halfway_point << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [est-halfway]: <kbd>[estimate_halfway.cc]</kbd> 估计函数的50%点]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::{
        random_double_range, self,
    };

    struct Sample {
        pub x: f64,
        pub p_x: f64,
    }

    fn compare_by_x(a: &Sample, b: &Sample) -> std::cmp::Ordering {
        a.x.partial_cmp(&b.x).unwrap()
    }

    fn main() {
        const N: usize = 10000;
        let mut sum = 0.0;

        // iterate through all of our samples
        let mut samples = Vec::new();
        (0..N).for_each(|_| {
            // Get the area under the curve
            let x = random_double_range(0.0, 2.0 * rtweekend::PI);
            let sin_x = x.sin();
            let p_x = (-x / (2.0 * rtweekend::PI)).exp() * sin_x * sin_x;
            sum += p_x;
            // store this sample
            samples.push(Sample { x, p_x });
        });

        // Sort the samples by x
        samples.sort_by(compare_by_x);

        // Find out the sample at which we have half of our area
        let half_sum = sum / 2.0;
        let mut halfway_point = 0.0;
        let mut accum = 0.0;
        for sample in samples.iter() {
            accum += sample.p_x;
            if accum >= half_sum {
                halfway_point = sample.x;
                break;
            }
        }

        println!("Average = {:.12}", sum / N as f64);
        println!("Area under curve = {:.12}", 2.0 * rtweekend::PI * sum / N as f64);
        println!("Halfway = {:.12}", halfway_point);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
这段代码片段与之前的代码相比并没有太大的不同。我们仍然解决了一个区间（从0到$2\pi$）上的总和。
只是这一次，我们还通过输入和输出将所有样本存储和排序。
我们使用这些样本来确定它们在整个区间上的子总和达到总和的一半的点。一旦我们知道前$j$个样本的总和达到总和的一半，
我们就知道第$j$个$x$大致对应于我们的中点：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Average = 0.314686555791
    Area under curve = 1.977233943713
    Halfway = 2.016002314977
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

如果您解出从$0$到$2.016$和从$2.016$到$2\pi$的积分，您应该得到几乎完全相同的结果。

我们有一种方法来解决将PDF分成一半的中点。如果我们愿意，我们可以使用这个方法创建一个嵌套的二进制分区的PDF：

  1. 解决PDF的中点
  2. 递归进入较小的一半，重复步骤1
  3. 递归进入较大的一半，重复步骤1

在一个合理的深度停止，比如6-10。正如您可以想象的那样，这可能非常耗费计算资源。上面的代码的计算瓶颈可能是对样本进行排序。
一个朴素的排序算法的算法复杂度可能是$\mathcal{O}(\mathbf{n^2})$时间，这是非常昂贵的。
幸运的是，标准库中包含的排序算法通常更接近$\mathcal{O}(\mathbf{n\log{}n})$时间，但这仍然可能非常昂贵，特别是对于数百万或数十亿个样本。
但这将产生相当不错的非均匀分布的非均匀数。这种分而治之的方法用于生成非均匀分布在实践中相当常见，尽管有比简单的二进制分区更高效的方法。
如果您有一个任意函数作为分布的PDF，您将需要研究_梅特罗波利斯-哈斯廷斯算法_。


近似分布
---------------------------
在建立一些概念的过程中，我们进行了大量的数学推导和工作。现在让我们回到最初的概率密度函数（PDF）。
对于没有明确概率的区间，我们假设概率密度函数为零。因此，对于本章开头的例子，$p(r) = 0$，对于 $r \notin [0,2]$。
我们可以将 $p(r)$ 用分段函数的形式重新表示：

    $$ p(r)=\begin{cases}
            0           & r < 0           \\
            \frac{r}{2} & 0 \leq r \leq 2 \\
            0           & 2 < r           \\
       \end{cases}
    $$

如果你考虑一下我们在前一节中要做的事情，很多数学都围绕着从零开始的**累积**面积（或**累积**概率）展开。
对于函数

    $$ f(x) = e^{\frac{-x}{2 \pi}} sin^2(x)  $$

我们关心的是从 $0$ 到 $2\pi$（100%）的累积概率和从 $0$ 到 $2.016$（50%）的累积概率。
我们可以将这个概念推广到一个重要的术语，即**累积分布函数**（CDF），定义如下：

    $$ P(x) =  \int_{-\infty}^{x}  p(x') dx' $$

或者，

    $$ P(x) = \operatorname{area}(p(x'), -\infty, x) $$

它表示从$-\infty$开始的**累积**概率量。我们将积分中的变量从 $x$ 改为 $x'$，是因为根据微积分规则，
如果你不确定它的含义，不用担心，你可以将它视为相同的。如果我们对上述积分进行计算，我们得到分段函数 $P(r)$：

    $$ P(r)=\begin{cases}
           0             & r < 0           \\
           \frac{r^2}{4} & 0 \leq r \leq 2 \\
           1             & 2 < r           \\
       \end{cases}
    $$

**概率密度函数**（PDF）是解释一个数字区间被选择的可能性的概率函数。
**累积分布函数**（CDF）是解释比其输入更小的所有数字被选择的分布函数。
要从 PDF 得到 CDF，你需要从 $-\infty$ 积分到 $x$，但要从 CDF 得到 PDF，你只需要取导数：

    $$ p(x) = \frac{d}{dx}P(x) $$

如果我们在 $r = 1.0$ 处评估 CDF $P(r)$，我们得到：

    $$ P(1.0) = \frac{1}{4} $$

这表示**从我们的 PDF 中随机选择的变量有 25% 的概率小于等于 1.0**。
我们想要一个函数 $f(d)$，它接受一个介于 0 和 1 之间的均匀分布（即 `f(random_double())`），
并根据具有 CDF $P(x) = \frac{x^2}{4}$ 的分布返回一个随机值。
我们还不知道函数 $f(d)$ 的解析形式，但我们知道它返回的结果中有 25% 应该小于 1.0，75% 应该大于 1.0。
同样地，我们知道其中 50% 应该小于 $\sqrt{2}$，50% 应该大于 $\sqrt{2}$。
如果 $f(d)$ 单调递增，那么我们期望 $f(0.25) = 1.0$，$f(0.5) = \sqrt{2}$。
这可以推广到找出每个可能输入的 $f(d)$：

    $$ f(P(x)) = x $$

让我们取一些更多的样本：

    $$ P(0.0) = 0 $$
    $$ P(0.5) = \frac{1}{16} $$
    $$ P(1.0) = \frac{1}{4} $$
    $$ P(1.5) = \frac{9}{16} $$
    $$ P(2.0) = 1 $$

因此，函数 $f()$ 的取值为

    $$ f(P(0.0)) = f(0) = 0 $$
    $$ f(P(0.5)) = f(\frac{1}{16}) = 0.5 $$
    $$ f(P(1.0)) = f(\frac{1}{4}) = 1.0 $$
    $$ f(P(1.5)) = f(\frac{9}{16}) = 1.5 $$
    $$ f(P(2.0)) = f(1) = 2.0 $$

我们可以使用这些中间值并在它们之间进行插值来近似 $f(d)$：

    ![Figure [approx f]: 近似非均匀分布 f()](../images/fig-3.08-approx-f.jpg)

如果你无法解析求解 PDF，那么你也无法解析求解 CDF。毕竟，CDF 只是 PDF 的积分。
然而，你仍然可以创建一个近似 PDF 的分布。如果你从你想要得到 PDF 的随机函数中取一堆样本，
你可以通过获取样本的直方图然后转换为 PDF 来近似 PDF。或者，你可以像上面那样对所有样本进行排序。

仔细观察等式：

    $$ f(P(x)) = x $$

这意味着 $f()$ 只是撤销了 $P()$ 的操作。因此，$f()$ 是反函数：

    $$ f(d) = P^{-1}(x) $$

对于我们的目的，如果我们有 PDF $p()$ 和累积分布函数 $P()$，我们可以使用这个"反函数"和一个随机数来得到我们想要的结果：

    $$ f(d) = P^{-1} (\operatorname{random_double}()) $$

对于我们的 PDF $p(r) = \frac{r}{2}$ 和相应的 $P(r)$，我们需要计算 $P(r)$ 的反函数。如果我们有

    $$ y = \frac{r^2}{4} $$

我们通过解关于 $y$ 的方程来得到反函数：

    $$ r = \sqrt{4y} $$

这意味着我们的 CDF 的反函数定义为

    $$ P^{-1}(r) = \sqrt{4y} $$

因此，我们的具有密度 $p(r)$ 的随机数生成器可以使用以下公式创建：

    $$ f(d) = \sqrt{4\cdot\operatorname{random_double}()} $$

请注意，这个公式的取值范围是从 0 到 2，与我们的期望一致，如果我们检查我们的工作，
我们将 `random_double()` 替换为 $1/4$ 得到 1，也将其替换为 $1/2$ 得到 $\sqrt{2}$，正如我们所期望的那样。


重要性采样
--------------------
现在你应该对如何使用分析概率密度函数（PDF）生成具有该分布的随机数有了相当好的理解。
我们回到最初的积分问题，并尝试使用几个不同的PDF来更好地理解：

    $$ I = \int_{0}^{2} x^2 dx $$

<div class='together'>
上次我们尝试解决这个积分时，我们使用了蒙特卡洛方法，从区间$[0, 2]$均匀采样。当时我们并不知道，
但我们隐式地使用了一个在$[0, 2]$范围内均匀分布的PDF。这意味着我们使用的PDF是$1/2$，
对应的累积分布函数（CDF）是$P(x) = x/2$，因此$f(d) = 2d$。有了这个信息，我们可以将这个均匀分布的PDF显式地表示出来：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>
    #include <stdlib.h>


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
    double f(double d) {
        return 2.0 * d;
    }

    double pdf(double x) {
        return 0.5;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

    int main() {
        int N = 1000000;
        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto x = f(random_double());
            sum += x*x / pdf(x);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        }
        std::cout << std::fixed << std::setprecision(12);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        std::cout << "I = " << sum / N << '\n';
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-xsq-2]: <kbd>[integrate_x_sq.cc]</kbd> $x^2$的显式均匀分布PDF]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double;

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
    fn f(d: f64) -> f64 {
        2.0 * d
    }

    fn pdf(_x: f64) -> f64 {
        0.5
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

    fn main() {
        const N: usize = 1000000;
        let mut sum = 0.0;
        (0..N).for_each(|_| {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
            let x = f(random_double());
            sum += x * x / pdf(x);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
        });
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        println!("I = {:.12}", sum / N as f64);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

有几个重要的事情需要强调。每个$x$的值代表分布$[0, 2]$中的一个样本点。我们使用函数$f$从该分布中随机选择样本。
以前，我们将区间上的平均值（`sum / N`）乘以区间的长度（`b - a`）来得到最终答案。但在这里，我们不需要乘以区间长度，
也就是说，我们不再需要将平均值乘以2。

我们需要考虑到$x$的PDF的非均匀性。如果不考虑这种非均匀性，将会在场景中引入偏差。事实上，
这种偏差是我们图像过亮的原因——如果我们考虑到非均匀性，我们将得到准确的结果。PDF会将样本“引导”到分布的特定部分，
这将使我们更快地收敛，但代价是引入偏差。为了消除这种偏差，我们需要在采样频率较高的地方降低权重，在采样频率较低的地方增加权重。
对于我们的新的非均匀随机数生成器，PDF定义了我们在特定部分采样的多少。因此，权重函数应该与$1/\mathit{pdf}$成比例。
实际上，它确切地等于$1/\mathit{pdf}$。这就是为什么我们将`x*x`除以`pdf(x)`的原因。

我们可以尝试使用线性PDF $p(r) = \frac{r}{2}$ 来解决这个积分问题，我们已经能够求解其CDF和逆函数。
为此，我们只需要将函数$f = \sqrt{4d}$和PDF $pdf = \frac{x}{2}$ 替换掉。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
    double f(double d) {
        return sqrt(4.0 * d);
    }

    double pdf(double x) {
        return x / 2.0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

    int main() {
        int N = 1000000;
        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            auto x = f(random_double());
            sum += x*x / pdf(x);
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "I = " << sum / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-xsq-3]: <kbd>[integrate_x_sq.cc]</kbd> 使用线性PDF积分$x^2$]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double;

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
    fn f(d: f64) -> f64 {
        (4.0 * d).sqrt()
    }

    fn pdf(x: f64) -> f64 {
        x / 2.0
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

    fn main() {
        const N: usize = 1000000;
        let mut sum = 0.0;
        (0..N).for_each(|_| {
            let x = f(random_double());
            sum += x * x / pdf(x);
        });
        println!("I = {:.12}", sum / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果你比较了均匀PDF和线性PDF的运行结果，你可能会发现线性PDF收敛得更快。如果你仔细思考一下，线性PDF可能更好地逼近了二次函数，
所以你会期望它收敛得更快。如果是这样的话，那么我们应该尝试使PDF与被积函数匹配，将PDF变成一个二次函数：

    $$ p(r)=\begin{cases}
            0           & r < 0           \\
            C \cdot r^2 & 0 \leq r \leq 2 \\
            0           & 2 < r           \\
       \end{cases}
    $$

像线性PDF一样，我们通过在区间上积分使得常数$C$等于1：

    $$ 1 = \int_{0}^{2} C \cdot r^2 dr $$
    $$ = C \cdot \int_{0}^{2} r^2 dr $$
    $$ = C \cdot \frac{r^3}{3} \Big|_{0}^{2} $$
    $$ = C ( \frac{2^3}{3} - \frac{0}{3} ) $$
    $$ C = \frac{3}{8} $$

这给出了：

    $$ p(r)=\begin{cases}
            0           & r < 0           \\
            \frac{3}{8} r^2 & 0 \leq r \leq 2 \\
            0           & 2 < r           \\
       \end{cases}
    $$

并且我们得到相应的CDF：

    $$ P(r) = \frac{r^3}{8} $$

以及

    $$ P^{-1}(x) = f(d) = 8d^\frac{1}{3} $$

<div class='together'>
对于只有一个样本的情况，我们有：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
    double f(double d) {
        return 8.0 * pow(d, 1.0/3.0);
    }

    double pdf(double x) {
        return (3.0/8.0) * x*x;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

    int main() {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        int N = 1;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            auto x = f(random_double()));
            sum += x*x / pdf(x);
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "I = " << sum / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [integ-xsq-5]: <kbd>[integrate_x_sq.cc]</kbd> 积分$x^2$，最终版本]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend::random_double;

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
    fn f(d: f64) -> f64 {
        8.0 * d.powf(1.0 / 3.0)
    }

    fn pdf(x: f64) -> f64 {
        3.0 / 8.0 * x * x
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

    fn main() {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        const N: usize = 1;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
        let mut sum = 0.0;
        (0..N).for_each(|_| {
            let x = f(random_double());
            sum += x * x / pdf(x);
        });
        println!("I = {:.12}", sum / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

这总是返回精确的答案。说实话，这感觉有点像魔法。

</div>

非均匀PDF会将更多的样本引导到PDF较大的部分，而较少的样本引导到PDF较小的部分。通过这种采样，我们预期在PDF较大的部分噪声较少，
在PDF较小的部分噪声较多。如果我们选择一个在场景中噪声较大的部分具有较高PDF值的PDF，并且在场景中噪声较小的部分具有较低PDF值的PDF，
我们将能够用较少的样本减少场景的总噪声。这意味着我们将能够比使用均匀PDF更快地收敛到正确的场景。
实际上，我们将样本引导到更重要的分布部分。这就是为什么通常将使用精心选择的非均匀PDF称为**重要性采样**。

在所有给定的示例中，我们始终收敛到了正确的答案$8/3$。当使用均匀PDF和“正确”的PDF（即$f(d)=8d^{\frac{1}{3}}$）时，我们得到了相同的答案。
虽然它们都收敛到了相同的答案，但均匀PDF需要更长的时间。毕竟，我们只需要从与积分完全匹配的PDF中获得一个样本。
这是有道理的，因为我们选择更频繁地采样分布的重要部分，而均匀PDF只是均匀地采样整个分布，没有考虑到重要性。

实际上，你创建的任何PDF都将最终收敛到正确的答案。这只是蒙特卡洛算法的又一个强大之处。
即使是我们通过求解50%的值并将分布分为两半的朴素PDF：$[0, \sqrt{2}]$和$[\sqrt{2}, 2]$。那个PDF也会收敛。
希望你对为什么这个PDF会比纯均匀PDF收敛得更快有直观的理解，但比线性PDF（即$f(d) = \sqrt{4d}$）收敛得更慢。

完美的重要性采样只有在我们已经知道答案时才可能实现（我们通过解析地积分$p$得到了$P$），但这是一个很好的练习，以确保我们的代码工作正常。

让我们回顾一下蒙特卡洛光线追踪器的主要概念：

  1. 你有一个在某个区域$[a,b]$上的$f(x)$的积分
  2. 你选择一个在$[a,b]$上非零且非负的PDF $p$
  3. 你对大量的$\frac{f(r)}{p(r)}$取平均值，其中$r$是具有PDF $p$的随机数。

任何选择的PDF $p$都将最终收敛到正确的答案，但$P$越接近$f$，收敛速度就越快。



在球面上的蒙特卡洛积分
====================================================================================================
在一维蒙特卡洛积分章节中，我们从均匀随机数开始，然后逐渐在整个章节中构建了更加复杂的产生随机数的方法，
最终形成了概率密度函数（PDF）的直觉，并学会如何使用PDF生成任意分布的随机数。

在扩展到多个维度时，所有在该章节中介绍的概念仍然适用。在接下来的内容中，我们可能需要从二维、三维甚至更高维空间中选择一个点，
然后通过一个任意的PDF对该选择进行加权。在光线追踪中，一个重要的情况是生成一个随机方向。
在前两本书中，我们通过创建一个随机向量，并在其超出单位球时将其拒绝，来生成一个随机方向。
我们重复这个过程，直到找到一个落在单位球内的随机向量。对该向量进行归一化，就得到了落在单位球上的点，从而表示一个随机方向。
这个生成样本在不符合所需空间的情况下拒绝它们的过程被称为**拒绝方法**，在文献中随处可见。
上一章介绍的方法被称为**反演方法**，因为我们反演了一个PDF。

3D空间中的每个方向都有一个与之关联的单位球上的点，并且可以通过求解从原点到该关联点的向量来生成它。
你可以将选择一个随机方向看作是选择一个受限制的二维平面上的随机点：通过将单位球映射到笛卡尔坐标系而创建的平面。
之前的方法仍然适用，但现在我们可能会在两个维度上定义一个PDF。假设我们想要在单位球的表面上进行积分：

  $$ f(\theta, \phi) = cos^2(\theta) $$

使用蒙特卡洛积分，我们只需要对 $\cos^2(\theta) / p(r)$ 进行采样，其中 $p(r)$ 现在只是 $p(direction)$。
但在这种情况下，什么是“direction”呢？我们可以基于极坐标来定义它，因此 $p$ 将是关于 $\theta$ 和 $\phi$ 的函数 $p(\theta, \phi)$。
你选择使用哪种坐标系并不重要。无论你选择哪种方式，记住PDF必须在整个表面上积分为1，并且PDF表示了被采样方向的**相对概率**。
回想一下，我们有一个用于在单位球上生成均匀随机样本的 `vec3` 函数（`random_unit_vector()`）。这些均匀样本的PDF是什么？
作为单位球上的均匀密度，它是球体的 $1/\mathit{area}$，即 $1/(4\pi)$。
如果被积函数是 $\cos^2(\theta)$，其中 $\theta$ 是与 $z$ 轴的夹角：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    double f(const vec3& d) {
        auto cosine_squared = d.z()*d.z();
        return cosine_squared;
    }

    double pdf(const vec3& d) {
        return 1 / (4*pi);
    }

    int main() {
        int N = 1000000;
        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            vec3 d = random_unit_vector();
            auto f_d = f(d);
            sum += f_d / pdf(d);
        }
        std::cout << std::fixed << std::setprecision(12);
        std::cout << "I = " << sum / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [main-sphereimp]: <kbd>[sphere_importance.cc]</kbd>
    在单位球上生成重要采样点]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    use the_rest_of_your_life::rtweekend;
    use the_rest_of_your_life::vec3::{self, Vec3};

    fn f(d: Vec3) -> f64 {
        d.z() * d.z()
    }

    fn pdf(_d: Vec3) -> f64 {
        1.0 / (4.0 * rtweekend::PI)
    }

    fn main() {
        const N: usize = 1000000;
        let mut sum = 0.0;
        (0..N).for_each(|_| {
            let d = vec3::random_unit_vector();
            let f_d = f(d);
            sum += f_d / pdf(d);
        });
        println!("I = {:.12}", sum / N as f64);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

解析解是 $\frac{4}{3} \pi$ -- 如果你还记得足够的高级数学知识，可以验证一下！上面的代码就得到了这个结果。
关键点在于所有的积分、概率和其他一切都是在单位球上进行的。在3D中表示单个方向的方式是它在单位球上的关联点。
在3D中表示一系列方向的方式是这些方向穿过的单位球上的面积。无论你称之为方向、面积还是**立体角**，它们都是同一个东西。
立体角通常是文献中使用的术语。你在一维中有弧度（r）中的 $\theta$，在二维中有立体弧度（sr）中的 $\theta$ 和 $\phi$
（单位球是一个三维对象，但其表面只有两个维度）。立体角只是角度的二维扩展。如果你对二维角度感到熟悉，那太好了！
如果不熟悉，就像我一样，想象一下一组方向在单位球上经过的区域。立体角 $\omega$ 和单位球上的投影面积 $A$ 是相同的。

  ![图 [solid-angle]: 球体的立体角/投影面积
  ](../images/fig-3.09-solid-angle.jpg)

现在让我们继续解决我们要解决的光传输方程。



光散射
====================================================================================================
在本章中，我们不会实际编写任何代码。我们只是为下一章中的大型光照变化做准备。
我们前两本书中的光线追踪程序在与表面或体积相互作用时会散射光线。光线散射是模拟光在场景中传播的最常用模型。
这可以自然地以概率方式建模。在建模光线的概率散射时有许多要考虑的因素。

反射率
-------
首先，光是否被吸收？

光被散射的概率：$A$

光被吸收的概率：$1-A$

这里的$A$代表**反射率**，在拉丁语中意为**白度**。反射率在某些学科中是一个精确的技术术语，但在所有情况下，它被用来定义某种形式的**分数反射率**。
这个**分数反射率**（或反射率）会随着颜色的变化而变化，而且（如我们为玻璃材质实现的那样）还可以随着入射方向（入射光线的方向）的变化而变化。
停下来回想一下，当我们模拟光的传播时，我们所做的就是模拟光子在空间中的运动。
如果你还记得高中物理，你应该记得每个光子都有一个与普朗克常数相关联的唯一能量和波长：

$$ E = \frac{hc}{\lambda} $$

每个单独的光子都有一点点能量，但当你把足够多的光子加在一起时，你就得到了渲染中的所有照明效果。
光子与表面或体积（或实际上与光子可以相互作用的任何东西）的吸收或散射是由物体的反射率在概率上决定的。
反射率可能会因为某些物体更有可能吸收某些波长而与颜色有关。

在大多数基于物理的渲染器中，我们会使用预定义的特定波长集合来表示光的颜色，而不是RGB。
例如，我们会用在300nm、350nm、400nm、...、700nm处进行采样的方式来替代我们的三刺激值RGB渲染器。
通过将R、G和B视为波长的特定代数混合物，其中R主要是红色波长，G主要是绿色波长，B主要是蓝色波长，我们可以扩展我们的直觉。
这是人类视觉系统的近似表示，人类视觉系统具有3组独特的色感受器，称为**锥体**，每个色感受器对不同的波长代数混合物敏感，
大致对应于RGB，但被称为长、中、短锥体（名称是根据每个锥体敏感的波长而命名的，而不是锥体的长度）。
就像颜色可以在RGB颜色空间中通过它们的强度来表示一样，颜色也可以在_LMS颜色空间_（长、中、短）中通过每组锥体的兴奋程度来表示（长、中、短）。

散射
-----------
如果光线发生散射，它将具有我们可以描述为固定角度上的概率密度函数（PDF）的方向分布。我将其称为**散射PDF**：$\operatorname{pScatter}()$。
散射PDF将随着出射方向的变化而变化：$\operatorname{pScatter}(\omega_o)$。散射PDF也可以随着**入射方向**的变化而变化：
$\operatorname{pScatter}(\omega_i, \omega_o)$。当你观察道路上的反射时，你会看到它随着观察角度（入射角）接近接近时变得像镜子一样。
散射PDF可以随着光的波长变化：$\operatorname{pScatter}(\omega_i, \omega_o, \lambda)$。一个很好的例子是棱镜将白光折射成彩虹。
最后，散射PDF还可以依赖于散射位置：$\operatorname{pScatter}(\mathbf{x}, \omega_i, \omega_o, \lambda)$。
$\mathbf{x}$只是散射位置的数学表示：$\mathbf{x} = (x, y, z)$。
物体的反射率也可以依赖于这些量：$A(\mathbf{x}, \omega_i, \omega_o, \lambda)$。

表面的颜色是通过在入射方向上对这些项进行单位半球积分来确定的：

$$ \operatorname{Color}_o(\mathbf{x}, \omega_o, \lambda) = \int_{\omega_i}
    A(\mathbf{x}, \omega_i, \omega_o, \lambda) \cdot
    \operatorname{pScatter}(\mathbf{x}, \omega_i, \omega_o, \lambda) \cdot
    \operatorname{Color}_i(\mathbf{x}, \omega_i, \lambda) $$

我们添加了一个$\operatorname{Color}_i$项。散射PDF和物体表面的反射率充当了对照点上的光的滤波器。因此，我们需要解决照射在该点上的光。
这是一个递归算法，也是我们的`ray_color`函数返回当前对象的颜色乘以下一条光线的颜色的原因。

散射PDF
-------------------
如果我们应用蒙特卡洛的基本公式，我们得到以下的统计估计：

$$ \operatorname{Color}_o(\mathbf{x}, \omega_o, \lambda) \approx \sum
    \frac{A(\, \ldots \,) \cdot
    \operatorname{pScatter}(\, \ldots \,) \cdot
    \operatorname{Color}_i(\, \ldots \,)}
    {p(\mathbf{x}, \omega_i, \omega_o, \lambda)} $$

其中$p(\mathbf{x}, \omega_i, \omega_o, \lambda)$是我们随机生成的任何出射方向的PDF。

对于Lambertian表面，我们已经隐式地为$pScatter(\, \ldots \,)$是余弦密度的特殊情况实现了这个公式。
Lambertian表面的$\operatorname{pScatter}(\, \ldots \,)$与$\cos(\theta_o)$成正比，其中$\theta_o$是相对于表面法线的角度。
让我们再次解决$C$：

$$ \operatorname{pScatter}(\mathbf{x}, \omega_i, \omega_o, \lambda) = C \cdot \cos(\theta_o) $$

所有二维PDF在整个表面上都需要积分为1（记住$\operatorname{pScatter}$是一个PDF）。
我们设置$\operatorname{pScatter}(\theta_o < 0) = 0$，这样我们就不会在地平线以下进行散射。

$$ 1 = \int_{0}^{2 \pi} \int_{0}^{\pi / 2} C \cdot cos(\theta) dA $$

要在半球上进行积分，记住在球坐标中：

$$ dA = \sin(\theta) d\theta d\phi $$

所以：

$$ 1 = C \cdot \int_{0}^{2 \pi} \int_{0}^{\pi / 2} cos(\theta) sin(\theta) d\theta d\phi $$
$$ 1 = C \cdot 2 \pi \frac{1}{2} $$
$$ 1 = C \cdot \pi $$
$$ C = \frac{1}{\pi} $$

$\cos(\theta_o)$在半球上的积分是$\pi$，所以我们需要通过$\frac{1}{\pi}$进行归一化。
散射PDF $\operatorname{pScatter}$ 只依赖于出射方向（$\omega_o$），所以我们将简化其表示为$\operatorname{pScatter}(\omega_o)$。
将所有这些放在一起，我们得到Lambertian表面的散射PDF：

$$ \operatorname{pScatter}(\omega_o) = \frac{\cos(\theta_o)}{\pi} $$

我们将假设$p(\mathbf{x}, \omega_i, \omega_o, \lambda)$等于散射PDF：

$$ p(\omega_o) = \operatorname{pScatter}(\omega_o) = \frac{\cos(\theta_o)}{\pi} $$

分子和分母相互抵消，我们得到：

$$ \operatorname{Color}_o(\mathbf{x}, \omega_o, \lambda) \approx \sum
    A(\, \ldots \,) \cdot
    \operatorname{Color}_i(\, \ldots \,) $$

<div class='together'>
这正是我们最初的`ray_color()`函数中的内容！

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        return attenuation * ray_color(scattered, depth-1, world);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

上面的处理稍微有些非标准，因为我希望相同的数学方法适用于表面和体积。如果你阅读文献，你会看到反射由**双向反射分布函数**（BRDF）定义。
它与我们的术语非常简单地相关：

$$ BRDF(\omega_i, \omega_o, \lambda) = \frac{A(\mathbf{x}, \omega_i, \omega_o, \lambda) \cdot
    \operatorname{pScatter}(\mathbf{x}, \omega_i, \omega_o, \lambda)}{\cos(\theta_o)} $$

因此，例如对于Lambertian表面，$BRDF = A / \pi$。我们的术语和BRDF之间的转换很容易。对于参与介质（体积），
我们的反射率通常称为**散射反射率**，我们的散射PDF通常称为**相位函数**。

我们在这里所做的一切只是概述了材质的Lambertian散射的PDF。然而，我们需要进行泛化，
以便我们可以在重要的方向上发送额外的光线，例如朝向光源的方向。



重要性采样的实验
====================================================================================================
在接下来的几章中，我们的目标是通过向光源发送大量额外的光线来减少图像的噪点。
假设我们可以使用一个概率密度函数（PDF）$\operatorname{pLight}(\omega_o)$向光源发送大量光线。
同时，假设我们有一个与$\operatorname{pScatter}$相关的PDF，记作$\operatorname{pSurface}(\omega_o)$。
关于PDF的一个很好的特性是，你可以使用它们的线性组合形成混合密度，这些混合密度也是PDF。例如，最简单的情况是：

$$ p(\omega_o) = \frac{1}{2} \operatorname{pSurface}(\omega_o) +  \frac{1}{2} \operatorname{pLight}(\omega_o) $$

只要权重是正的并且加起来等于一，任何这样的PDF混合都是一个PDF。请记住，我们可以使用任何PDF：**所有的PDF最终都会收敛到正确的答案**。
因此，我们的目标是找出如何使得乘积

$$ \operatorname{pScatter}(\mathbf{x}, \omega_i, \omega_o) \cdot \operatorname{Color}_i(\mathbf{x}, \omega_i) $$

最大的地方，对应的PDF也会更大。对于漫反射表面来说，这主要是猜测$\operatorname{Color}_i(\mathbf{x}, \omega_i)$最大的位置，
也就是猜测光线来自哪个方向。

对于镜面材质，$\operatorname{pScatter}()$只在一个方向附近非常大，所以$\operatorname{pScatter}()$更重要。
事实上，大多数渲染器都将镜面作为一种特殊情况处理，并将$\operatorname{pScatter}()/p()$隐含在内——我们的代码目前也是这样做的。


回到康奈尔盒
-----------------------------
让我们调整一些康奈尔盒的参数：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    int main() {
        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        cam.samples_per_pixel = 100;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [cornell-box]: <kbd>[main.cc]</kbd> 康奈尔盒，重构]

<div class='together'>
在我的Macbook的一个核心上，我的代码在600×600的分辨率下在15分钟内生成了以下图像：

  ![<span class='num'>图像 3:</span> 康奈尔盒，重构
  ](../images/img-3.03-cornell-refactor1.jpg class='pixel')

</div>

我们的目标是减少噪点。我们将通过构建一个PDF来实现这一目标，该PDF会向光源发送更多的光线。

首先，让我们修改代码，以便明确地对某个PDF进行采样，然后进行归一化。
记住蒙特卡洛的基本原理：$\int f(x) \approx \sum f(r)/p(r)$。对于Lambertian材质，
让我们像现在一样进行采样：$p(\omega_o) = \cos(\theta_o) / \pi$。

<div class='together'>
我们修改基类`material`以启用这种重要性采样：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class material {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        virtual double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered)
        const {
            return 0;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-material]: <kbd>[material.h]</kbd>
    material类，添加重要性采样]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    pub trait Material {
        fn scatter(&self, r_in: &Ray, rec: &HitRecord, attenuation: &mut Color, scattered: &mut Ray) -> bool;
        fn emitted(&self, _u: f64, _v: f64, _p: vec3::Point3) -> Color {
            Color::new(0.0, 0.0, 0.0)
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn scattering_pdf(&self, _r_in: &Ray, _rec: &HitRecord, _scattered: &Ray) -> f64 {
            0.0
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
Lambertian材质变为：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class lambertian : public material {
      public:
        lambertian(const color& a) : albedo(make_shared<solid_color>(a)) {}
        lambertian(shared_ptr<texture> a) : albedo(a) {}

        bool scatter(const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered)
        const override {
            auto scatter_direction = rec.normal + random_unit_vector();

            // Catch degenerate scatter direction
            if (scatter_direction.near_zero())
                scatter_direction = rec.normal;

            scattered = ray(rec.p, scatter_direction, r_in.time());
            attenuation = albedo->value(rec.u, rec.v, rec.p);
            return true;
        }


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered) const {
            auto cos_theta = dot(rec.normal, unit_vector(scattered.direction()));
            return cos_theta < 0 ? 0 : cos_theta/pi;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

      private:
        shared_ptr<texture> albedo;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-lambertian-impsample]: <kbd>[material.h]</kbd>
    Lambertian材质，修改为重要性采样]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Material for Lambertian {
        fn scatter(&self, r_in: &Ray, rec: &HitRecord, attenuation: &mut Color, scattered: &mut Ray) -> bool {
            let mut scatter_direction = rec.normal + vec3::random_unit_vector();

            // 捕捉退化的散射方向
            if scatter_direction.near_zero() {
                scatter_direction = rec.normal;
            }

            *scattered = Ray::new_with_time(rec.p, scatter_direction, r_in.time());
            *attenuation = self.albedo.value(rec.u, rec.v, rec.p);
            true
        }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
        fn scattering_pdf(&self, _r_in: &Ray, rec: &HitRecord, scattered: &Ray) -> f64 {
            let cos_theta = vec3::dot(rec.normal, vec3::unit_vector(scattered.direction()));
            if cos_theta < 0.0 {
                0.0
            } else {
                cos_theta / rtweekend::PI
            }
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

<div class='together'>
`camera::ray_color`函数进行了一些小修改：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world) const {
            hit_record rec;

            // 如果我们超过了光线反弹限制，就不再收集光线。
            if (depth <= 0)
                return color(0,0,0);

            // 如果光线没有击中了世界中的任何东西，则返回背景颜色。
            if (!world.hit(r, interval(0.001, infinity), rec))
                return background;

            ray scattered;
            color attenuation;
            color color_from_emission = rec.mat->emitted(rec.u, rec.v, rec.p);

            if (!rec.mat->scatter(r, rec, attenuation, scattered))
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);
            double pdf = scattering_pdf;

            color color_from_scatter =
                (attenuation * scattering_pdf * ray_color(scattered, depth-1, world)) / pdf;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            return color_from_emission + color_from_scatter;
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-impsample]: <kbd>[camera.h]</kbd>
    ray_color函数，修改为重要性采样]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Camera {
        ...

        fn ray_color(&self, r: &Ray, depth: usize, world: &dyn Hittable) -> Color {
            let mut rec = HitRecord::default();

            // 如果我们超过了光线反弹限制，就不再收集光线。
            if depth == 0 {
                return Color::default();
            }

            // 如果光线没有击中了世界中的任何东西，则返回背景颜色。
            if !world.hit(r, &Interval::new(0.001, rtweekend::INFINITY), &mut rec) {
                return self.background;
            }

            if let Some(mat) = rec.mat.clone() {
                let mut scattered = Ray::default();
                let mut attenuation = Color::default();
                let color_from_emission = mat.emitted(rec.u, rec.v, rec.p);
                if !mat.scatter(r, &rec, &mut attenuation, &mut scattered) {
                    return color_from_emission;
                }

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                let scattering_pdf = mat.scattering_pdf(r, &rec, &scattered);
                let pdf = scattering_pdf;

                let color_from_scatter = (attenuation * scattering_pdf * self.ray_color(&scattered,  depth - 1, world)) / pdf;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

                color_from_emission + color_from_scatter
            } else {
                Color::default()
            }
        }

        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

</div>

你应该得到完全相同的图像。这是有道理的，因为`ray_color`的散射部分乘以了`scattering_pdf / pdf`，
而由于`pdf`等于`scattering_pdf`，所以相当于乘以了1。


使用均匀概率密度函数（PDF）而不是完美匹配
----------------------------------------------
现在，为了体验一下，让我们尝试使用不同的采样PDF。我们仍然将反射光线按照Lambertian（$\cos(\theta_o)$）进行加权，
保持散射PDF不变，但是我们将在分母中使用不同的PDF。我们将使用均匀分布的PDF来对半球进行采样，因此我们将分母设置为$1/2\pi$。
这仍然会收敛到正确的答案，因为我们只是改变了PDF，但由于PDF现在不再完全匹配真实分布，收敛所需的时间会更长。
这意味着对于相同数量的样本，图像会更加嘈杂：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world) const {
            hit_record rec;

            // 如果超过了光线反射次数的限制，不再收集光线。
            if (depth <= 0)
                return color(0,0,0);

            // 如果光线没有击中任何物体，返回背景颜色。
            if (!world.hit(r, interval(0.001, infinity), rec))
                return background;

            ray scattered;
            color attenuation;
            color color_from_emission = rec.mat->emitted(rec.u, rec.v, rec.p);

            if (!rec.mat->scatter(r, rec, attenuation, scattered))
                return color_from_emission;

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            double pdf = 1 / (2*pi);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            color color_from_scatter =
                (attenuation * scattering_pdf * ray_color(scattered, depth-1, world)) / pdf;

            return color_from_emission + color_from_scatter;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-uniform]: <kbd>[camera.h]</kbd>
    ray_color函数，现在分母中使用均匀PDF]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Camera {
        ...

        fn ray_color(&self, r: &Ray, depth: usize, world: &dyn Hittable) -> Color {
            let mut rec = HitRecord::default();

            // 如果我们超过了光线反弹限制，就不再收集光线。
            if depth == 0 {
                return Color::default();
            }

            // 如果光线没有击中了世界中的任何东西，则返回背景颜色。
            if !world.hit(r, &Interval::new(0.001, rtweekend::INFINITY), &mut rec) {
                return self.background;
            }

            if let Some(mat) = rec.mat.clone() {
                let mut scattered = Ray::default();
                let mut attenuation = Color::default();
                let color_from_emission = mat.emitted(rec.u, rec.v, rec.p);
                if !mat.scatter(r, &rec, &mut attenuation, &mut scattered) {
                    return color_from_emission;
                }

                let scattering_pdf = mat.scattering_pdf(r, &rec, &scattered);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
                let pdf = 1.0 / (2.0 * rtweekend::PI);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

                let color_from_scatter = (attenuation * scattering_pdf * self.ray_color(&scattered,  depth - 1, world)) / pdf;

                color_from_emission + color_from_scatter
            } else {
                Color::default()
            }
        }

        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

你应该得到与之前非常相似的结果，只是稍微更嘈杂一些，可能很难看清楚。

  ![<span class='num'>图像 4:</span> Cornell 盒子，使用不完美的PDF
  ](../images/img-3.04-cornell-refactor2.jpg class='pixel')

确保将PDF返回到散射PDF。

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            ...

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            double pdf = scattering_pdf;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-return]: <kbd>[camera.h]</kbd> 将PDF返回到与散射PDF相同的值]


随机半球采样
---------------------------
为了确认我们的理解，让我们尝试一种不同的散射分布。对于这个例子，我们将尝试重复第一本书中的均匀半球散射。
这种技术没有问题，但我们不再将物体视为Lambertian材质。Lambertian是一种特定类型的漫反射材质，需要一个$\cos(\theta_o)$的散射分布。
均匀半球散射是一种不同的漫反射材质。如果我们保持材质不变，但改变概率密度函数（PDF），就像在上一节中所做的那样，我们仍然会收敛到相同的答案，
但我们的收敛可能需要更多或更少的样本。然而，如果我们改变材质，我们将从根本上改变渲染结果，算法将收敛到一个不同的答案。
因此，当我们用均匀半球漫反射替换Lambertian漫反射时，我们应该期望渲染结果在**实质上**有所不同。我们将调整散射方向和散射PDF：

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class lambertian : public material {
      public:
        lambertian(const color& a) : albedo(make_shared<solid_color>(a)) {}
        lambertian(shared_ptr<texture> a) : albedo(a) {}

        bool scatter(const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered)
        const override {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto scatter_direction = random_on_hemisphere(rec.normal);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            // Catch degenerate scatter direction
            if (scatter_direction.near_zero())
                scatter_direction = rec.normal;

            scattered = ray(rec.p, scatter_direction, r_in.time());
            attenuation = albedo->value(rec.u, rec.v, rec.p);
            return true;
        }


        double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered) const {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            return 1 / (2*pi);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        }

        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [scatter-mod]: <kbd>[material.h]</kbd> 修改后的PDF和scatter函数]

---
Rust实现

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
    impl Material for Lambertian {
        fn scatter(&self, r_in: &Ray, rec: &HitRecord, attenuation: &mut Color, scattered: &mut Ray) -> bool {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
            let mut scatter_direction = vec3::random_on_hemisphere(rec.normal);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust

            // 捕捉退化的散射方向
            if scatter_direction.near_zero() {
                scatter_direction = rec.normal;
            }

            *scattered = Ray::new_with_time(rec.p, scatter_direction, r_in.time());
            *attenuation = self.albedo.value(rec.u, rec.v, rec.p);
            true
        }

        fn scattering_pdf(&self, _r_in: &Ray, _rec: &HitRecord, _scattered: &Ray) -> f64 {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust highlight
            1.0 / (2.0 * rtweekend::PI)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ rust
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---

这种新的漫反射材质实际上只是散射PDF为$p(\omega_o) = \frac{1}{2\pi}$。因此，我们的均匀PDF虽然不完全匹配Lambertian漫反射，
但却完全匹配我们的均匀半球漫反射。在渲染时，我们应该得到一个略有不同的图像。

  ![<span class='num'>图像 5:</span> Cornell盒子，使用均匀半球采样
  ](../images/img-3.04-cornell-refactor2.jpg class='pixel')

它与我们之前的图片非常接近，但存在着不仅仅是噪声的差异。高盒子的正面颜色更加均匀。如果你不确定材质的最佳采样模式是什么，
假设一个均匀的PDF是相当合理的，虽然收敛速度可能较慢，但不会破坏你的渲染。也就是说，如果你不确定材质的正确采样模式，
你选择的PDF不会是你最大的担忧，因为选择错误的散射函数将会破坏你的渲染。至少它会产生一个不正确的结果。
你可能会发现自己在蒙特卡洛程序中遇到最难找到的错误之一——产生一个看起来合理的图像的错误！你不会知道这个错误是在第一个版本的程序中，
还是在第二个版本中，或者两者都有问题！

让我们构建一些基础设施来解决这个问题。



Generating Random Directions
====================================================================================================
In this and the next two chapters, we'll harden our understanding and our tools.


Random Directions Relative to the Z Axis
-----------------------------------------
Let’s first figure out how to generate random directions. We already have a method to generate
random directions using the rejection method, so let's create one using the inversion method. To
simplify things, assume the $z$ axis is the surface normal, and $\theta$ is the angle from the
normal. We'll set everything up in terms of the $z$ axis this chapter. Next chapter we’ll get them
oriented to the surface normal vector. We will only deal with distributions that are rotationally
symmetric about $z$. So $p(\omega) = f(\theta)$.

Given a directional PDF on the sphere (where $p(\omega) = f(\theta)$), the one dimensional PDFs on
$\theta$ and $\phi$ are:

    $$ a(\phi) = \frac{1}{2\pi} $$
    $$ b(\theta) = 2\pi f(\theta)\sin(\theta) $$

For uniform random numbers $r_1$ and $r_2$, we solve for the CDF of $\theta$ and $\phi$ so that we
can invert the CDF to derive the random number generator.

    $$ r_1 = \int_{0}^{\phi} a(\phi') d\phi' $$
    $$ = \int_{0}^{\phi} \frac{1}{2\pi} d\phi' $$
    $$ = \frac{\phi}{2\pi} $$

Invert to solve for $\phi$:

    $$ \phi = 2 \pi \cdot r_1 $$

This should match with your intuition. To solve for a random $\phi$ you can take a uniform random
number in the interval [0,1] and multiply by $2\pi$ to cover the full range of all possible $\phi$
values, which is just [0,$2\pi$]. You may not have a fully formed intuition for how to solve for a
random value of $\theta$, so let's walk through the math to help you get set up. We rewrite $\phi$
as $\phi'$ and $\theta$ as $\theta'$ just like before, as a formality. For $\theta$ we have:

    $$ r_2 = \int_{0}^{\theta} b(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} 2 \pi f(\theta') \sin(\theta') d\theta' $$

Let’s try some different functions for $f()$. Let’s first try a uniform density on the sphere. The
area of the unit sphere is $4\pi$, so a uniform $p(\omega) = \frac{1}{4\pi}$ on the unit sphere.

    $$ r_2 = \int_{0}^{\theta} 2 \pi \frac{1}{4\pi} \sin(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} \frac{1}{2} \sin(\theta') d\theta' $$
    $$ = \frac{-\cos(\theta)}{2} - \frac{-\cos(0)}{2} $$
    $$ = \frac{1 - \cos(\theta)}{2} $$

Solving for $\cos(\theta)$ gives:

    $$ \cos(\theta) = 1 - 2 r_2 $$

We don’t solve for theta because we probably only need to know $\cos(\theta)$ anyway, and don’t want
needless $\arccos()$ calls running around.

To generate a unit vector direction toward $(\theta,\phi)$ we convert to Cartesian coordinates:

    $$ x = \cos(\phi) \cdot \sin(\theta) $$
    $$ y = \sin(\phi) \cdot \sin(\theta) $$
    $$ z = \cos(\theta) $$

And using the identity $\cos^2 + \sin^2 = 1$, we get the following in terms of random $(r_1,r_2)$:

    $$ x = \cos(2\pi \cdot r_1)\sqrt{1 - (1-2 r_2)^2} $$
    $$ y = \sin(2\pi \cdot r_1)\sqrt{1 - (1-2 r_2)^2} $$
    $$ z = 1 - 2  r_2 $$

Simplifying a little, $(1 - 2 r_2)^2 = 1 - 4r_2 + 4r_2^2$, so:

    $$ x = \cos(2 \pi r_1) \cdot 2 \sqrt{r_2(1 - r_2)} $$
    $$ y = \sin(2 \pi r_1) \cdot 2 \sqrt{r_2(1 - r_2)} $$
    $$ z = 1 - 2 r_2 $$

<div class='together'>
We can output some of these:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <math.h>

    int main() {
        for (int i = 0; i < 200; i++) {
            auto r1 = random_double();
            auto r2 = random_double();
            auto x = cos(2*pi*r1)*2*sqrt(r2*(1-r2));
            auto y = sin(2*pi*r1)*2*sqrt(r2*(1-r2));
            auto z = 1 - 2*r2;
            std::cout << x << " " << y << " " << z << '\n';
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [rand-unit-sphere-plot]: <kbd>[sphere_plot.cc]</kbd> Random points on the unit sphere]

</div>

<div class='together'>
And plot them for free on plot.ly (a great site with 3D scatterplot support):

  ![Figure [rand-pts-sphere]: Random points on the unit sphere
  ](../images/fig-3.10-rand-pts-sphere.jpg)

On the plot.ly website you can rotate that around and see that it appears uniform.

</div>


Uniform Sampling a Hemisphere
------------------------------
Now let’s derive uniform on the hemisphere. The density being uniform on the hemisphere means
$p(\omega) = f(\theta) = \frac{1}{2\pi}$. Just changing the constant in the theta equations yields:

    $$ r_2 = \int_{0}^{\theta} b(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} 2 \pi f(\theta') \sin(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} 2 \pi \frac{1}{2\pi} \sin(\theta') d\theta' $$
    $$ \ldots $$
    $$ \cos(\theta) = 1 - r_2 $$

This means that $\cos(\theta)$ will vary from 1 to 0, so $\theta$ will vary from 0 to $\pi/2$, which
means that nothing will go below the horizon. Rather than plot it, we'll solve for a 2D integral
with a known solution. Let’s integrate cosine cubed over the hemisphere (just picking something
arbitrary with a known solution). First we'll solve the integral by hand:

    $$ \int_\omega \cos^3(\theta) dA $$
    $$ = \int_{0}^{2 \pi} \int_{0}^{\pi /2} \cos^3(\theta) \sin(\theta) d\theta d\phi $$
    $$ = 2 \pi \int_{0}^{\pi/2} \cos^3(\theta) \sin(\theta) d\theta = \frac{\pi}{2} $$

<div class='together'>
Now for integration with importance sampling. $p(\omega) = \frac{1}{2\pi}$, so we average
$f()/p() = \cos^3(\theta) / \frac{1}{2\pi}$, and we can test this:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>

    double f(double r2) {
        // auto x = cos(2*pi*r1)*2*sqrt(r2*(1-r2));
        // auto y = sin(2*pi*r1)*2*sqrt(r2*(1-r2));
        auto z = 1 - r2;
        double cos_theta = z;
        return cos_theta*cos_theta*cos_theta;
    }

    double pdf() {
        return 1.0 / (2.0*pi);
    }

    int main() {
        int N = 1000000;

        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            auto r2 = random_double();
            sum += f(r2) / pdf();
        }

        std::cout << std::fixed << std::setprecision(12);
        std::cout << "PI/2 = " << pi / 2.0 << '\n';
        std::cout << "Estimate = " << sum / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [cos-cubed]: <kbd>[cos_cubed.cc]</kbd> Integration using $cos^3(x)$]

</div>


Cosine Sampling a Hemisphere
------------------------------
We'll now continue trying to solve for cosine cubed over the horizon, but we'll change our PDF to
generate directions with $p(\omega) =  f(\theta) = \cos(\theta) / \pi$.

    $$ r_2 = \int_{0}^{\theta} b(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} 2 \pi f(\theta') \sin(\theta') d\theta' $$
    $$ = \int_{0}^{\theta} 2 \pi \frac{\cos(\theta')}{\pi} \sin(\theta') d\theta' $$
    $$ = 1 - \cos^2(\theta) $$

So,

    $$ \cos(\theta) = \sqrt{1 - r_2} $$

We can save a little algebra on specific cases by noting

    $$ z = \cos(\theta) = \sqrt{1 - r_2} $$
    $$ x = \cos(\phi) \sin(\theta) = \cos(2 \pi r_1) \sqrt{1 - z^2} = \cos(2 \pi r_1) \sqrt{r_2} $$
    $$ y = \sin(\phi) \sin(\theta) = \sin(2 \pi r_1) \sqrt{1 - z^2} = \sin(2 \pi r_1) \sqrt{r_2} $$

<div class='together'>
Here's a function that generates random vectors weighted by this PDF:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    inline vec3 random_cosine_direction() {
        auto r1 = random_double();
        auto r2 = random_double();

        auto phi = 2*pi*r1;
        auto x = cos(phi)*sqrt(r2);
        auto y = sin(phi)*sqrt(r2);
        auto z = sqrt(1-r2);

        return vec3(x, y, z);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [random-cosine-direction]: <kbd>[vec3.h]</kbd>
    Random cosine direction utility function]

</div>

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #include "rtweekend.h"

    #include <iostream>
    #include <iomanip>
    #include <math.h>

    double f(const vec3& d) {
        auto cos_theta = d.z();
        return cos_theta*cos_theta*cos_theta;
    }

    double pdf(const vec3& d) {
        return d.z() / pi;
    }

    int main() {
        int N = 1000000;

        auto sum = 0.0;
        for (int i = 0; i < N; i++) {
            vec3 d = random_cosine_direction();
            sum += f(d) / pdf(d);
        }

        std::cout << std::fixed << std::setprecision(12);
        std::cout << "PI/2 = " << pi / 2.0 << '\n';
        std::cout << "Estimate = " << sum / N << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [cos-density]: <kbd>[cos_density.cc]</kbd> Integration with cosine density function]

We can generate other densities later as we need them. This `random_cosine_direction()` function
produces a random direction weighted by $\cos(\theta)$ where $\theta$ is the angle from the $z$
axis.



Orthonormal Bases
====================================================================================================
In the last chapter we developed methods to generate random directions relative to the $z$ axis. If
we want to be able to produce reflections off of any surface, we are going to need to make this more
general: Not all normals are going to be perfectly aligned with the $z$ axis. So in this chapter we
are going to generalize our methods so that they support arbitrary surface normal vectors.


Relative Coordinates
---------------------
An _orthonormal basis_ (ONB) is a collection of three mutually orthogonal unit vectors. It is a
strict subtype of coordinate system. The Cartesian $xyz$ axes are one example of an orthonormal
basis. All of our renders are the result of the relative positions and orientations of the objects
in a scene projected onto the image plane of the camera. The camera and objects must be described in
the same coordinate system, so that the projection onto the image plane is logically defined,
otherwise the camera has no definitive means of correctly rendering the objects. Either the camera
must be redefined in the objects' coordinate system, or the objects must be redefined in the
camera's coordinate system. It's best to start with both in the same coordinate system, so no
redefinition is necessary. So long as the camera and scene are described in the same coordinate
system, all is well. The orthonormal basis defines how distances and orientations are represented in
the space, but an orthonormal basis alone is not enough. The objects and the camera need to
described by their displacement from a mutually defined location. This is just the origin
$\mathbf{O}$ of the scene; it represents the center of the universe for everything to displace from.

Suppose we have an origin $\mathbf{O}$ and Cartesian unit vectors $\mathbf{x}$, $\mathbf{y}$, and
$\mathbf{z}$. When we say a location is (3,-2,7), we really are saying:

    $$ \text{Location is } \mathbf{O} + 3\mathbf{x} - 2\mathbf{y} + 7\mathbf{z} $$

If we want to measure coordinates in another coordinate system with origin $\mathbf{O}'$ and basis
vectors $\mathbf{u}$, $\mathbf{v}$, and $\mathbf{w}$, we can just find the numbers $(u,v,w)$ such
that:

    $$ \text{Location is } \mathbf{O}' + u\mathbf{u} + v\mathbf{v} + w\mathbf{w} $$


Generating an Orthonormal Basis
--------------------------------
If you take an intro to graphics course, there will be a lot of time spent on coordinate systems and
4×4 coordinate transformation matrices. Pay attention, it’s really important stuff! But we won’t be
needing it for this book and we'll make do without it. What we do need is to generate random
directions with a set distribution relative to the surface normal vector $\mathbf{n}$. We won’t be
needing an origin for this because a direction is relative and has no specific origin. To start off
with, we need two cotangent vectors that are each perpendicular to $\mathbf{n}$ and that are also
perpendicular to each other.

Some 3D object models will come with one or more cotangent vectors for each vertex. If our model has
only one cotangent vector, then the process of making an ONB is a nontrivial one. Suppose we have
any vector $\mathbf{a}$ that is of nonzero length and nonparallel with $\mathbf{n}$. We can get
vectors $\mathbf{s}$ and $\mathbf{t}$ perpendicular to $\mathbf{n}$ by using the property of the
cross product that $\mathbf{n} \times \mathbf{a}$ is perpendicular to both $\mathbf{n}$ and
$\mathbf{a}$:

    $$ \mathbf{s} = \operatorname{unit_vector}(\mathbf{n} \times \mathbf{a}) $$

    $$ \mathbf{t} = \mathbf{n} \times \mathbf{s} $$

<div class='together'>
This is all well and good, but the catch is that we may not be given an $\mathbf{a}$ when we load a
model, and our current program doesn't have a way to generate one. If we went ahead and picked an
arbitrary $\mathbf{a}$ to use as an initial vector we may get an $\mathbf{a}$ that is parallel to
$\mathbf{n}$. So a common method is to pick an arbitrary axis and check to see if it's parallel to
$\mathbf{n}$ (which we assume to be of unit length), if it is, just use another axis:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (fabs(n.x()) > 0.9)
        a = vec3(0, 1, 0)
    else
        a = vec3(1, 0, 0)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

<div class='together'>
We then take the cross product to get $\mathbf{s}$ and $\mathbf{t}$

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    vec3 s = unit_vector(cross(n, a));
    vec3 t = cross(n, s);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

Note that we don't need to take the unit vector for $\mathbf{t}$. Since $\mathbf{n}$ and
$\mathbf{s}$ are both unit vectors, their cross product $\mathbf{t}$ will be also. Once we have an
ONB of $\mathbf{s}$, $\mathbf{t}$, and $\mathbf{n}$, and we have a random $(x,y,z)$ relative to the
$z$ axis, we can get the vector relative to $\mathbf{n}$ with:

    $$ \mathit{Random vector} = x \mathbf{s} + y \mathbf{t} + z \mathbf{n} $$

If you remember, we used similar math to produce rays from a camera. You can think of that as a
change to the camera’s natural coordinate system.


The ONB Class
--------------
Should we make a class for ONBs, or are utility functions enough? I’m not sure, but let’s make a
class because it won't really be more complicated than utility functions:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #ifndef ONB_H
    #define ONB_H

    #include "rtweekend.h"

    class onb {
      public:
        onb() {}

        vec3 operator[](int i) const { return axis[i]; }
        vec3& operator[](int i) { return axis[i]; }

        vec3 u() const { return axis[0]; }
        vec3 v() const { return axis[1]; }
        vec3 w() const { return axis[2]; }

        vec3 local(double a, double b, double c) const {
            return a*u() + b*v() + c*w();
        }

        vec3 local(const vec3& a) const {
            return a.x()*u() + a.y()*v() + a.z()*w();
        }

        void build_from_w(const vec3& w) {
            vec3 unit_w = unit_vector(w);
            vec3 a = (fabs(unit_w.x()) > 0.9) ? vec3(0,1,0) : vec3(1,0,0);
            vec3 v = unit_vector(cross(unit_w, a));
            vec3 u = cross(unit_w, v);
            axis[0] = u;
            axis[1] = v;
            axis[2] = unit_w;
        }

      public:
        vec3 axis[3];
    };


    #endif
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-onb]: <kbd>[onb.h]</kbd> Orthonormal basis class]

<div class='together'>
We can rewrite our Lambertian material using this to get:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class lambertian : public material {
      public:
        ...

        bool scatter(
            const ray& r_in, const hit_record& rec, color& alb, ray& scattered, double& pdf
        ) const override {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            onb uvw;
            uvw.build_from_w(rec.normal);
            auto scatter_direction = uvw.local(random_cosine_direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            scattered = ray(rec.p, unit_vector(scatter_direction), r_in.time());
            alb = albedo->value(rec.u, rec.v, rec.p);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            pdf = dot(uvw.w(), scattered.direction()) / pi;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            return true;
        }

        ...
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [scatter-onb]: <kbd>[material.h]</kbd> Scatter function, with orthonormal basis]

</div>

<div class='together'>
Which produces:

  ![<span class='num'>Image 6:</span> Cornell box, with orthonormal basis scatter function
  ](../images/img-3.06-cornell-ortho.jpg class='pixel')

</div>

<div class='together'>
Let’s get rid of some of that noise.

But first, let's quickly update the `isotropic` material:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class isotropic : public material {
      public:
        isotropic(const color& c) : albedo(make_shared<solid_color>(c)) {}
        isotropic(shared_ptr<texture> a) : albedo(a) {}


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        bool scatter(
            const ray& r_in, const hit_record& rec, color& alb, ray& scattered, double& pdf
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        ) const override {
            scattered = ray(rec.p, random_unit_vector(), r_in.time());
            attenuation = albedo->value(rec.u, rec.v, rec.p);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            pdf = 1 / (4 * pi);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            return true;
        }


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered)
        const override {
            return 1 / (4 * pi);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

      private:
        shared_ptr<texture> albedo;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-isotropic-impsample]: <kbd>[material.h]</kbd>
    Isotropic material, modified for importance sampling]

</div>



Sampling Lights Directly
====================================================================================================
The problem with sampling uniformly over all directions is that lights are no more likely to be
sampled than any arbirary or unimportant direction. We could use shadow rays to solve for the direct
lighting at any given point. Instead, I’ll just use a PDF that sends more rays to the light. We can
then turn around and change that PDF to send more rays in whatever direction we want.

It’s really easy to pick a random direction toward the light; just pick a random point on the light
and send a ray in that direction. But we'll need to know the PDF, $p(\omega)$, so that we're not
biasing our render. But what is that?


Getting the PDF of a Light
---------------------------
For a light with a surface area of $A$, if we sample uniformly on that light, the PDF on the surface
is just $\frac{1}{A}$. How much area does the entire surface of the light take up if its projected
back onto the unit sphere? Fortunately, there is a simple correspondence, as outlined in this
diagram:

  ![Figure [shape-onto-pdf]: Projection of light shape onto PDF
  ](../images/fig-3.11-shape-onto-pdf.jpg)

If we look at a small area $dA$ on the light, the probability of sampling it is
$\operatorname{p_q}(q) \cdot dA$. On the sphere, the probability of sampling the small area
$d\omega$ on the sphere is $\operatorname{p}(\omega) \cdot d\omega$. There is a geometric
relationship between $d\omega$ and $dA$:

    $$ d\omega = \frac{dA \cdot \cos(\theta)}{\operatorname{distance}^2(p,q)} $$

Since the probability of sampling $d\omega$ and $dA$ must be the same, then

    $$ \operatorname{p}(\omega) \cdot d\omega = \operatorname{p_q}(q) \cdot dA $$
    $$ \operatorname{p}(\omega)
       \cdot \frac{dA \cdot \cos(\theta)}{\operatorname{distance}^2(p,q)}
       = \operatorname{p_q}(q) \cdot dA $$

We know that if we sample uniformly on the light the PDF on the surface is $\frac{1}{A}$:

    $$ \operatorname{p_q}(q) = \frac{1}{A} $$
    $$ \operatorname{p}(\omega) \cdot \frac{dA \cdot \cos(\theta)}{\operatorname{distance}^2(p,q)}
       =  \frac{dA}{A} $$

So

  $$ \operatorname{p}(\omega) = \frac{\operatorname{distance}^2(p,q)}{\cos(\theta) \cdot A} $$


Light Sampling
---------------
We can hack our `ray_color()` function to sample the light in a very hard-coded fashion just to
check that we got the math and concept right:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        color ray_color(const ray& r, int depth, const hittable& world) const {
            hit_record rec;

            // If we've exceeded the ray bounce limit, no more light is gathered.
            if (depth <= 0)
                return color(0,0,0);

            // If the ray hits nothing, return the background color.
            if (!world.hit(r, interval(0.001, infinity), rec))
                return background;

            ray scattered;
            color attenuation;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            double pdf;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            color color_from_emission = rec.mat->emitted(rec.u, rec.v, rec.p);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            if (!rec.mat->scatter(r, rec, attenuation, scattered, pdf))
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto on_light = point3(random_double(213,343), 554, random_double(227,332));
            auto to_light = on_light - rec.p;
            auto distance_squared = to_light.length_squared();
            to_light = unit_vector(to_light);

            if (dot(to_light, rec.normal) < 0)
                return color_from_emission;

            double light_area = (343-213)*(332-227);
            auto light_cosine = fabs(to_light.y());
            if (light_cosine < 0.000001)
                return color_from_emission;

            pdf = distance_squared / (light_cosine * light_area);
            scattered = ray(rec.p, to_light, r.time());

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            color color_from_scatter =
                (attenuation * scattering_pdf * ray_color(scattered, depth-1, world)) / pdf;

            return color_from_emission + color_from_scatter;
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-lights]: <kbd>[camera.h]</kbd> Ray color with light sampling]

<div class='together'>
With 10 samples per pixel this yields:

  ![<span class='num'>Image 7:</span> Cornell box, sampling only the light, 10 samples per pixel
  ](../images/img-3.07-cornell-sample-light.jpg class='pixel')

This is about what we would expect from something that samples only the light sources, so this
appears to work.

</div>


Switching to Unidirectional Light
----------------------------------
The noisy pops around the light on the ceiling are because the light is two-sided and there is a
small space between light and ceiling. We probably want to have the light just emit down. We can do
that by letting the emitted member function of hittable take extra information:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class material {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        virtual color emitted(
            const ray& r_in, const hit_record& rec, double u, double v, const point3& p
        ) const {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            return color(0,0,0);
        }
        ...
    };

    class diffuse_light : public material {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        color emitted(const ray& r_in, const hit_record& rec, double u, double v, const point3& p)
        const override {
            if (!rec.front_face)
                return color(0,0,0);
            return emit->value(u, v, p);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        ...
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [emitted-directional]: <kbd>[material.h]</kbd> Material emission, directional]

<div class='together'>
This gives us:

  ![<span class='num'>Image 8:</span> Cornell box, light emitted only in the downward direction
  ](../images/img-3.08-cornell-lightdown.jpg class='pixel')

</div>



Mixture Densities
====================================================================================================
We have used a PDF related to $\cos(\theta)$, and a PDF related to sampling the light. We would like
a PDF that combines these.


The PDF Class
-------------
We've worked with PDFs in quite a lot of code already. I think that now is a good time to figure out
how we want to standardize our usage of PDFs. We already know that we are going to have a PDF for
the surface and a PDF for the light, so let's create a `pdf` base class. So far, we've had a `pdf()`
function that took a direction and returned the PDF's distribution value for that direction. This
value has so far been one of $1/4\pi$, $1/2\pi$, and $\cos(\theta)/\pi$. In a couple of our examples
we generated the random direction using a different distribution than the distribution of the PDF.
We covered this quite a lot in the chapter Playing with Importance Sampling. In general, if we know
the distribution of our random directions, we should use a PDF with the same distribution. This will
lead to the fastest convergence. With that in mind, we'll create a `pdf` class that is responsible
for generating random directions and determining the value of the PDF.

From all of this, any `pdf` class should be responsible for

  1. returning a random direction weighted by the internal PDF distribution, and
  2. returning the corresponding PDF distribution value in that direction.

<div class='together'>
The details of how this is done under the hood varies for $\operatorname{pSurface}$ and
$\operatorname{pLight}$, but that is exactly what class hierarchies were invented for! It’s never
obvious what goes in an abstract class, so my approach is to be greedy and hope a minimal interface
works, and for `pdf` this implies:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    #ifndef PDF_H
    #define PDF_H

    #include "rtweekend.h"

    #include "onb.h"


    class pdf {
      public:
        virtual ~pdf() {}

        virtual double value(const vec3& direction) const = 0;
        virtual vec3 generate() const = 0;
    };

    #endif
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-pdf]: <kbd>[pdf.h]</kbd> The abstract pdf class]

</div>

<div class='together'>
We’ll see if we need to add anything else to `pdf` by fleshing out the subclasses. First, we'll
create a uniform density over the unit sphere:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class sphere_pdf : public pdf {
      public:
        sphere_pdf() { }

        double value(const vec3& direction) const override {
            return 1/ (4 * pi);
        }

        vec3 generate() const override {
            return random_unit_vector();
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-uni-pdf]: <kbd>[pdf.h]</kbd> The uniform_pdf class]

</div>

<div class='together'>
Next, let’s try a cosine density:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class cosine_pdf : public pdf {
      public:
        cosine_pdf(const vec3& w) { uvw.build_from_w(w); }

        double value(const vec3& direction) const override {
            auto cosine_theta = dot(unit_vector(direction), uvw.w());
            return fmax(0, cosine_theta/pi);
        }

        vec3 generate() const override {
            return uvw.local(random_cosine_direction());
        }

      private:
        onb uvw;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-cos-pdf]: <kbd>[pdf.h]</kbd> The cosine_pdf class]

</div>

<div class='together'>
We can try this cosine PDF in the `ray_color()` function:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world) const {
            hit_record rec;

            // If we've exceeded the ray bounce limit, no more light is gathered.
            if (depth <= 0)
                return color(0,0,0);

            // If the ray hits nothing, return the background color.
            if (!world.hit(r, interval(0.001, infinity), rec))
                return background;

            ray scattered;
            color attenuation;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            double pdf_val;
            color color_from_emission = rec.mat->emitted(r, rec, rec.u, rec.v, rec.p);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            if (!rec.mat->scatter(r, rec, attenuation, scattered, pdf_val))
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            cosine_pdf surface_pdf(rec.normal);
            scattered = ray(rec.p, surface_pdf.generate(), r.time());
            pdf_val = surface_pdf.value(scattered.direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);

            color color_from_scatter =
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
                (attenuation * scattering_pdf * ray_color(scattered, depth-1, world)) / pdf_val;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            return color_from_emission + color_from_scatter;
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-cos-pdf]: <kbd>[camera.h]</kbd> The ray_color function, using cosine pdf]

</div>

<div class='together'>
This yields an exactly matching result so all we’ve done so far is move some computation up into the
`cosine_pdf` class:

  ![<span class='num'>Image 9:</span> Cornell box with a cosine density PDF
  ](../images/img-3.09-cornell-cos-pdf.jpg class='pixel')

</div>


Sampling Directions towards a Hittable
---------------------------------------
Now we can try sampling directions toward a `hittable`, like the light.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    ...
    #include "hittable_list.h"
    ...
    class hittable_pdf : public pdf {
      public:
        hittable_pdf(const hittable& _objects, const point3& _origin)
          : objects(_objects), origin(_origin)
        {}

        double value(const vec3& direction) const override {
            return objects.pdf_value(origin, direction);
        }

        vec3 generate() const override {
            return objects.random(origin);
        }

      private:
        const hittable& objects;
        point3 origin;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-hittable-pdf]: <kbd>[pdf.h]</kbd> The hittable_pdf class]

If we want to sample the light, we will need `hittable` to answer some queries that it doesn’t yet
have an interface for. The above code assumes the existence of two as-of-yet unimplemented functions
in the `hittable` class: `pdf_value()` and `random()`. We need to add these functions for the
program to compile. We could go through all of the `hittable` subclasses and add these functions,
but that would be a hassle, so we’ll just add two trivial functions to the `hittable` base class.
This breaks our previously pure abstract implementation, but it saves work. Feel free to write these
functions through to subclasses if you want a purely abstract `hittable` interface class.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class hittable {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        virtual double pdf_value(const point3& origin, const vec3& direction) const {
            return 0.0;
        }

        virtual vec3 random(const point3& origin) const {
            return vec3(1, 0, 0);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [hittable-plus2]: <kbd>[hittable.h]</kbd> The hittable class, with two new methods]

<div class='together'>
And then we change `quad` to implement those functions:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class quad : public hittable {
      public:
        quad(const point3& _Q, const vec3& _u, const vec3& _v, shared_ptr<material> m)
          : Q(_Q), u(_u), v(_v), mat(m)
        {
            auto n = cross(u, v);
            normal = unit_vector(n);
            D = dot(normal, Q);
            w = n / dot(n,n);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            area = n.length();
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            set_bounding_box();
        }
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double pdf_value(const point3& origin, const vec3& direction) const override {
            hit_record rec;
            if (!this->hit(ray(origin, direction), interval(0.001, infinity), rec))
                return 0;

            auto distance_squared = rec.t * rec.t * direction.length_squared();
            auto cosine = fabs(dot(direction, rec.normal) / direction.length());

            return distance_squared / (cosine * area);
        }

        vec3 random(const point3& origin) const override {
            auto p = plane_origin + (random_double() * axis_A) + (random_double() * axis_B);
            return p - origin;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

      private:
        point3 Q;
        vec3 u, v;
        vec3 w;
        shared_ptr<material> mat;
        aabb bbox;
        vec3 normal;
        double D;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double area;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [quad-pdf]: <kbd>[quad.h]</kbd> quad with pdf]

</div>

We only need to add `pdf_value()` and `random()` to `quad` because we're using this to importance
sample the light, and the only light we have in our scene is a `quad`. if you want other light
geometries, or want to use a PDF with other objects, you'll need to implement the above functions
for the corresponding classes.

<div class='together'>
Add a `lights` parameter to the camera `render()` function:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      public:
        ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        void render(const hittable& world, const hittable& lights) {
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            initialize();

            std::cout << "P3\n" << image_width << ' ' << image_height << "\n255\n";

            int sqrt_spp = int(sqrt(samples_per_pixel));
            for (int j = 0; j < image_height; j++) {
                std::clog << "\rScanlines remaining: " << (image_height - j) << ' ' << std::flush;
                for (int i = 0; i < image_width; i++) {
                    color pixel_color(0,0,0);
                    for (int s_j = 0; s_j < sqrt_spp; s_j++) {
                        for (int s_i = 0; s_i < sqrt_spp; s_i++) {
                            ray r = get_ray(i, j, s_i, s_j);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
                            pixel_color += ray_color(r, max_depth, world, lights);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
                        }
                    }
                    write_color(std::cout, pixel_color, samples_per_pixel);
                }
            }

            std::clog << "\rDone.                 \n";
        }

        ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world, const hittable& lights)
        const {
            ...

            ray scattered;
            color attenuation;
            double pdf_val;
            color color_from_emission = rec.mat->emitted(r, rec, rec.u, rec.v, rec.p);

            if (!rec.mat->scatter(r, rec, attenuation, scattered, pdf_val))
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            hittable_pdf light_pdf(light_ptr, rec.p);
            scattered = ray(rec.p, light_pdf.generate(), r.time());
            pdf_val = light_pdf.value(scattered.direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            color sample_color = ray_color(scattered, depth-1, world, lights);
            color color_from_scatter = (attenuation * scattering_pdf * sample_color) / pdf_val;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            return color_from_emission + color_from_scatter;
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-lights]: <kbd>[camera.h]</kbd> ray_color function with light PDF]

</div>

<div class='together'>
Create a light in the middle of the ceiling:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    int main() {
        ...

        // Box 2
        shared_ptr<hittable> box2 = box(point3(0,0,0), point3(165,165,165), white);
        box2 = make_shared<rotate_y>(box2, -18);
        box2 = make_shared<translate>(box2, vec3(130,0,65));
        world.add(box2);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        // Light Sources
        hittable_list lights;
        auto m = shared_ptr<material>();
        lights.add(make_shared<quad>(point3(343,554,332), vec3(-130,0,0), vec3(0,0,-105), m));
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        camera cam;
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        cam.render(world, lights);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-hittable-pdf]: <kbd>[main.cc]</kbd> Adding a light to the Cornell box]

</div>

<div class='together'>
At 10 samples per pixel we get:

  ![<span class='num'>Image 10:</span> Cornell box, sampling a hittable light, 10 samples per pixel
  ](../images/img-3.10-hittable-light.jpg class='pixel')

</div>


The Mixture PDF Class
----------------------
As was briefly mentioned in the chapter Playing with Importance Sampling, we can create linear
mixtures of any PDFs to form mixture densities that are also PDFs. Any weighted average of PDFs is
also a PDF. As long as the weights are positive and add up to any one, we have a new PDF.

  $$ \operatorname{pMixture}() = w_0 p_0() + w_1 p_1() + w_2 p_2() + \ldots + w_{n-1} p_{n-1}() $$

  $$ 1 = w_0 + w_1 + w_2 + \ldots + w_{n-1} $$

For example, we could just average the two densities:

  $$ \operatorname{pMixture}(\omega_o)
     = \frac{1}{2} \operatorname{pSurface}(\omega_o) + \frac{1}{2} \operatorname{pLight}(\omega_o)
  $$

<div class='together'>
How would we instrument our code to do that? There is a very important detail that makes this not
quite as easy as one might expect. Generating the random direction for a mixture PDF is simple:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (random_double() < 0.5)
        pick direction according to pSurface
    else
        pick direction according to pLight
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

But solving for the PDF value of $\operatorname{pMixture}$ is slightly more subtle. We can't just

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (direction is from pSurface)
        get PDF value of pSurface
    else
        get PDF value of pLight
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</div>

<div class='together'>
For one, figuring out which PDF the random direction came from is probably not trivial. We don't
have any plumbing for `generate()` to tell `value()` what the original `random_double()` was, so we
can't trivially say which PDF the random direction comes from. If we thought that the above was
correct, we would have to solve backwards to figure which PDF the direction could come from. Which
honestly sounds like a nightmare, but fortunately we don't need to do that. There are some
directions that both PDFs could have generated. For example, a direction toward the light could have
been generated by either $\operatorname{pLight}$ _or_ $\operatorname{pSurface}$. It is sufficient
for us to solve for the pdf value of $\operatorname{pSurface}$ and of $\operatorname{pLight}$ for a
random direction and then take the PDF mixture weights to solve for the total PDF value for that
direction. The mixture density class is actually pretty straightforward:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class mixture_pdf : public pdf {
      public:
        mixture_pdf(shared_ptr<pdf> p0, shared_ptr<pdf> p1) {
            p[0] = p0;
            p[1] = p1;
        }

        double value(const vec3& direction) const override {
            return 0.5 * p[0]->value(direction) + 0.5 *p[1]->value(direction);
        }

        vec3 generate() const override {
            if (random_double() < 0.5)
                return p[0]->generate();
            else
                return p[1]->generate();
        }

      private:
        shared_ptr<pdf> p[2];
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [class-mixturep-df]: <kbd>[pdf.h]</kbd> The mixture_pdf class]

</div>

<div class='together'>
Now we would like to do a mixture density of the cosine sampling and of the light sampling. We can
plug it into `ray_color()`:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world, const hittable& lights)
        const {
            ...

            if (!rec.mat->scatter(r, rec, attenuation, scattered, pdf_val))
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto p0 = make_shared<hittable_pdf>(light_ptr, rec.p);
            auto p1 = make_shared<cosine_pdf>(rec.normal);
            mixture_pdf mixed_pdf(p0, p1);

            scattered = ray(rec.p, mixed_pdf.generate(), r.time());
            pdf_val = mixed_pdf.value(scattered.direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);

            color sample_color = ray_color(scattered, depth-1, world, lights);
            color color_from_scatter = (attenuation * scattering_pdf * sample_color) / pdf_val;

            return color_from_emission + color_from_scatter;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-mixture]: <kbd>[camera.h]</kbd> The ray_color function, using mixture PDF]

</div>

<div class='together'>
1000 samples per pixel yields:

  ![<span class='num'>Image 11:</span> Cornell box, mixture density of cosine and light sampling
  ](../images/img-3.11-cosine-and-light.jpg class='pixel')

</div>



Some Architectural Decisions
====================================================================================================
We won't write any code in this chapter. We’re at a crossroads and we need to make some
architectural decisions.

The mixture-density approach is an alternative to having more traditional shadow rays. These are
rays that check for an unobstructed path from an intersection point to a given light source. Rays
that intersect an object between a point and a given light source indicate that the intersection
point is in the shadow of that particular light source. The mixture-density approach is something
that I personally prefer, because in addition to lights, you can sample windows or bright cracks
under doors or whatever else you think might be bright -- or important. But you'll still see shadow
rays in most professional path tracers. Typically they'll have a predefined number of shadow rays
(_e.g_ 1, 4, 8, 16) where over the course of rendering, at each place where the path tracing ray
intersects, they'll send these terminal shadow rays to random lights in the scene to determine if
the intersection is lit by that random light. The intersection will either be lit by that light, or
completely in shadow, where more shadow rays lead to a more accurate illumination. After all of the
shadow rays terminate (either at a light or at an occluding surface), the inital path tracing ray
continues on and more shadow rays are sent at the next intersection. You can't tell the shadow rays
what is important, you can only tell them what is emissive, so shadow rays work best on simpler
scenes that don't have overly complicated photon distribution. That said, shadow rays terminate at
the first thing they run into and don't bounce around, so one shadow ray is cheaper than one path
tracing ray, which is the reason that you'll typically see a lot more shadow rays than path tracing
rays (_e.g_ 1, 4, 8, 16). You could choose shadow rays over mixture-density in a more restricted
scene; that’s a personal design preference. Shadow rays tend to be cheaper for a crude result than
mixture-density and is becoming increasingly common in realtime.

There are some other issues with the code.

The PDF construction is hard coded in the `ray_color()` function. We should clean that up.

We've accidentally broken the specular rays (glass and metal), and they are no longer supported. The
math would continue to work out if we just made their scattering function a delta function, but that
would lead to all kinds of floating point disasters. We could either make specular reflection a
special case that skips $f()/p()$, or we could set surface roughness to a very small -- but nonzero
-- value and have almost-mirrors that look perfectly smooth but that don’t generate NaNs. I don’t
have an opinion on which way to do it (I have tried both and they both have their advantages), but
we have smooth metal and glass code anyway, so we'll add perfect specular surfaces that just skip
over explicit $f()/p()$ calculations.

We also lack a real background function infrastructure in case we want to add an environment map or
a more interesting functional background. Some environment maps are HDR (the RGB components are
normalized floats rather than 0–255 bytes). Our output has been HDR all along; we’ve just been
truncating it.

Finally, our renderer is RGB. A more physically based one -- like an automobile manufacturer might
use -- would probably need to use spectral colors and maybe even polarization. For a movie renderer,
most studios still get away with RGB. You can make a hybrid renderer that has both modes, but that
is of course harder. I’m going to stick to RGB for now, but I will touch on this at the end of the
book.



Cleaning Up PDF Management
====================================================================================================
So far I have the `ray_color()` function create two hard-coded PDFs:

  1. `p0()` related to the shape of the light
  2. `p1()` related to the normal vector and type of surface

We can pass information about the light (or whatever `hittable` we want to sample) into the
`ray_color()` function, and we can ask the `material` function for a PDF (we would have to add
instrumentation to do that). We also need to know if the scattered ray is specular, and we can do
this either by asking the `hit()` function or the `material` class.


Diffuse Versus Specular
------------------------
One thing we would like to allow for is a material -- like varnished wood -- that is partially ideal
specular (the polish) and partially diffuse (the wood). Some renderers have the material generate
two rays: one specular and one diffuse. I am not fond of branching, so I would rather have the
material randomly decide whether it is diffuse or specular. The catch with that approach is that we
need to be careful when we ask for the PDF value, and `ray_color()` needs to be aware of whether
this ray is diffuse or specular. Fortunately, we have decided that we should only call the
`pdf_value()` if it is diffuse, so we can handle that implicitly.

<div class='together'>
We can redesign `material` and stuff all the new arguments into a class like we did for `hittable`:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
    class scatter_record {
      public:
        color attenuation;
        shared_ptr<pdf> pdf_ptr;
        bool skip_pdf;
        ray skip_pdf_ray;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

    class material {
      public:
        ...

        virtual bool scatter(
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            const ray& r_in, const hit_record& rec, scatter_record& srec
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        ) const {
            return false;
        }
        ...
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [material-refactor]: <kbd>[material.h]</kbd> Refactoring the material class]

</div>

<div class='together'>
The `lambertian` material becomes simpler:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class lambertian : public material {
      public:
        lambertian(const color& a) : albedo(make_shared<solid_color>(a)) {}
        lambertian(shared_ptr<texture> a) : albedo(a) {}


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        bool scatter(const ray& r_in, const hit_record& rec, scatter_record& srec) const override {
            srec.attenuation = albedo->value(rec.u, rec.v, rec.p);
            srec.pdf_ptr = make_shared<cosine_pdf>(rec.normal);
            srec.skip_pdf = false;
            return true;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered) const {
            auto cosine = dot(rec.normal, unit_vector(scattered.direction()));
            return cosine < 0 ? 0 : cosine/pi;
        }

      private:
        shared_ptr<texture> albedo;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [lambertian-scatter]: <kbd>[material.h]</kbd> New lambertian scatter() method]

</div>

<div class='together'>
As does the `isotropic` material:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class isotropic : public material {
      public:
        isotropic(const color& c) : albedo(make_shared<solid_color>(c)) {}
        isotropic(shared_ptr<texture> a) : albedo(a) {}


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        bool scatter(const ray& r_in, const hit_record& rec, scatter_record& srec) const override {
            srec.attenuation = albedo->value(rec.u, rec.v, rec.p);
            srec.pdf_ptr = make_shared<sphere_pdf>();
            srec.skip_pdf = false;
            return true;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++


        double scattering_pdf(const ray& r_in, const hit_record& rec, const ray& scattered)
        const override {
            return 1 / (4 * pi);
        }

      private:
        shared_ptr<texture> albedo;
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [isotropic-scatter]: <kbd>[material.h]</kbd> New isotropic scatter() method]

</div>

<div class='together'>
And `ray_color()` changes are small:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world, const hittable& lights)
        const {
            hit_record rec;

            // If we've exceeded the ray bounce limit, no more light is gathered.
            if (depth <= 0)
                return color(0,0,0);

            // If the ray hits nothing, return the background color.
            if (!world.hit(r, interval(0.001, infinity), rec))
                return background;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            scatter_record srec;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            color color_from_emission = rec.mat->emitted(r, rec, rec.u, rec.v, rec.p);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            if (!rec.mat->scatter(r, rec, srec))
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            auto light_ptr = make_shared<hittable_pdf>(lights, rec.p);
            mixture_pdf p(light_ptr, srec.pdf_ptr);

            ray scattered = ray(rec.p, p.generate(), r.time());
            auto pdf_val = p.value(scattered.direction());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            double scattering_pdf = rec.mat->scattering_pdf(r, rec, scattered);

            color sample_color = ray_color(scattered, depth-1, world, lights);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            color color_from_scatter = (srec.attenuation * scattering_pdf * sample_color) / pdf_val;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            return color_from_emission + color_from_scatter;
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-mixture]: <kbd>[camera.h]</kbd> The ray_color function, using mixture PDF]

</div>


Handling Specular
------------------
We have not yet dealt with specular surfaces, nor instances that mess with the surface normal. But
this design is clean overall, and those are all fixable. For now, I will just fix `specular`. Metal
and dielectric materials are easy to fix.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class metal : public material {
      public:
        metal(const color& a, double f) : albedo(a), fuzz(f < 1 ? f : 1) {}


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        bool scatter(const ray& r_in, const hit_record& rec, scatter_record& srec) const override {
            srec.attenuation = albedo;
            srec.pdf_ptr = nullptr;
            srec.skip_pdf = true;
            vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);
            srec.skip_pdf_ray =
                ray(rec.p, reflected + fuzz*random_in_unit_sphere(), r_in.time());
            return true;
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

      private:
        color albedo;
        double fuzz;
    };

    ...

    class dielectric : public material {
      public:
        dielectric(double index_of_refraction) : ir(index_of_refraction) {}


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        bool scatter(const ray& r_in, const hit_record& rec, scatter_record& srec) const override {
            srec.attenuation = color(1.0, 1.0, 1.0);
            srec.pdf_ptr = nullptr;
            srec.skip_pdf = true;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            double refraction_ratio = rec.front_face ? (1.0/ir) : ir;

            vec3 unit_direction = unit_vector(r_in.direction());
            double cos_theta = fmin(dot(-unit_direction, rec.normal), 1.0);
            double sin_theta = sqrt(1.0 - cos_theta*cos_theta);

            bool cannot_refract = refraction_ratio * sin_theta > 1.0;
            vec3 direction;

            if (cannot_refract || reflectance(cos_theta, refraction_ratio) > random_double())
                direction = reflect(unit_direction, rec.normal);
            else
                direction = refract(unit_direction, rec.normal, refraction_ratio);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            srec.skip_pdf_ray = ray(rec.p, direction, r_in.time());
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
            return true;
        }

      ...
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [material-scatter]: <kbd>[material.h]</kbd> The metal and dielectric scatter methods]

Note that if the fuzziness is nonzero, this surface isn’t really ideally specular, but the implicit
sampling works just like it did before. We're effectively skipping all of our PDF work for the
materials that we're treating specularly.

<div class='together'>
`ray_color()` just needs a new case to generate an implicitly sampled ray:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class camera {
      ...
      private:
        ...
        color ray_color(const ray& r, int depth, const hittable& world, const hittable& lights)
        const {
            ...

            if (!rec.mat->scatter(r, rec, srec))
                return color_from_emission;


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
            if (srec.skip_pdf) {
                return srec.attenuation * ray_color(srec.skip_pdf_ray, depth-1, world, lights);
            }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

            auto light_ptr = make_shared<hittable_pdf>(lights, rec.p);
            mixture_pdf p(light_ptr, srec.pdf_ptr);

            ...
        }
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ray-color-implicit]: <kbd>[camera.h]</kbd>
    Ray color function with implicitly-sampled rays]

</div>

We'll check our work by changing a block to metal. We'd also like to swap out one of the blocks for
a glass object, but we'll push that off for the next section. Glass objects are difficult to render
well, so we'd like to make a PDF for them, but we have some more work to do before we're able to do
that.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    int main() {
        ...
        // Light
        world.add(make_shared<quad>(point3(213,554,227), vec3(130,0,0), vec3(0,0,105), light));

        // Box 1
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        shared_ptr<material> aluminum = make_shared<metal>(color(0.8, 0.85, 0.88), 0.0);
        shared_ptr<hittable> box1 = box(point3(0,0,0), point3(165,330,165), aluminum);
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
        box1 = make_shared<rotate_y>(box1, 15);
        box1 = make_shared<translate>(box1, vec3(265,0,295));
        world.add(box1);

        // Box 2
        shared_ptr<hittable> box2 = box(point3(0,0,0), point3(165,165,165), white);
        box2 = make_shared<rotate_y>(box2, -18);
        box2 = make_shared<translate>(box2, vec3(130,0,65));
        world.add(box2);

        // Light Sources
        hittable_list lights;
        auto m = shared_ptr<material>();
        lights.add(make_shared<quad>(point3(343,554,332), vec3(-130,0,0), vec3(0,0,-105), m));

        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [scene-cornell-al]: <kbd>[main.cc]</kbd> Cornell box scene with aluminum material]

<div class='together'>
The resulting image has a noisy reflection on the ceiling because the directions toward the box are
not sampled with more density.

  ![<span class='num'>Image 12:</span> Cornell box with arbitrary PDF functions
  ](../images/img-3.12-arbitrary-pdf.jpg class='pixel')

</div>


Sampling a Sphere Object
-------------------------
The noisiness on the ceiling could be reduced by making a PDF of the metal block. We would also want
a PDF for the block if we made it glass. But making a PDF for a block is quite a bit of work and
isn't terribly interesting, so let’s create a PDF for a glass sphere instead. It's quicker and makes
for a more interesting render. We need to figure out how to sample a sphere to determine an
appropriate PDF distribution. If we want to sample a sphere from a point outside of the sphere, we
can't just pick a random point on its surface and be done. If we did that, we would frequently pick
a point on the far side of the sphere, which would be occluded by the front side of the sphere. We
need a way to uniformly sample the side of the sphere that is visible from an arbitrary point. When
we sample a sphere’s solid angle uniformly from a point outside the sphere, we are really just
sampling a cone uniformly. The cone axis goes from the ray origin through the sphere center, with
the sides of the cone tangent to the sphere -- see illustration below. Let’s say the code has
`theta_max`. Recall from the Generating Random Directions chapter that to sample $\theta$ we have:

  $$ r_2 = \int_{0}^{\theta} 2 \pi f(\theta') \sin(\theta') d\theta' $$

Here $f(\theta')$ is an as-of-yet uncalculated constant $C$, so:

  $$ r_2 = \int_{0}^{\theta} 2 \pi C \sin(\theta') d\theta' $$

If we solve through the calculus:

  $$ r_2 = 2\pi \cdot C \cdot (1-\cos(\theta)) $$

So

  $$ cos(\theta) = 1 - \frac{r_2}{2 \pi \cdot C} $$

We are constraining our distribution so that the random direction must be less than $\theta_{max}$.
This means that the integral from 0 to $\theta_{max}$ must be one, and therefore $r_2 = 1$. We can
use this to solve for $C$:

  $$ r_2 = 2\pi \cdot C \cdot (1-\cos(\theta)) $$
  $$ 1 = 2\pi \cdot C \cdot (1-\cos(\theta_{max})) $$
  $$ C = \frac{1}{2\pi \cdot (1-\cos(\theta_{max})} $$

Which gives us an equality between $\theta$, $\theta_{max}$, and $r_2$:

  $$ \cos(\theta) = 1 + r_2 \cdot (\cos(\theta_{max})-1) $$

We sample $\phi$ like before, so:

  $$ z = \cos(\theta) = 1 + r_2 \cdot (\cos(\theta_{max}) - 1) $$
  $$ x = \cos(\phi) \cdot \sin(\theta) = \cos(2\pi \cdot r_1) \cdot \sqrt{1-z^2} $$
  $$ y = \sin(\phi) \cdot \sin(\theta) = \sin(2\pi \cdot r_1) \cdot \sqrt{1-z^2} $$

Now what is $\theta_{max}$?

  ![Figure [sphere-enclosing-cone]: A sphere-enclosing cone
  ](../images/fig-3.12-sphere-enclosing-cone.jpg)

We can see from the figure that $\sin(\theta_{max}) = R / length(\mathbf{c} - \mathbf{p})$. So:

  $$ \cos(\theta_{max}) = \sqrt{1 - \frac{R^2}{length^2(\mathbf{c} - \mathbf{p})}} $$

We also need to evaluate the PDF of directions. For a uniform distribution toward the sphere the PDF
is $1/\mathit{solid_angle}$. What is the solid angle of the sphere? It has something to do with the
$C$ above. It is -- by definition -- the area on the unit sphere, so the integral is

  $$ \mathit{solid angle} = \int_{0}^{2\pi} \int_{0}^{\theta_{max}} \sin(\theta)
       = 2 \pi \cdot (1-\cos(\theta_{max})) $$

It’s good to check the math on all such calculations. I usually plug in the extreme cases (thank you
for that concept, Mr. Horton -- my high school physics teacher). For a zero radius sphere
$\cos(\theta_{max}) = 0$, and that works. For a sphere tangent at $\mathbf{p}$,
$\cos(\theta_{max}) = 0$, and $2\pi$ is the area of a hemisphere, so that works too.


Updating the Sphere Code
-------------------------
The sphere class needs the two PDF-related functions:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class sphere : public hittable {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double pdf_value(const point3& origin, const vec3& direction) const override {
            // This method only works for stationary spheres.

            hit_record rec;
            if (!this->hit(ray(origin, direction), interval(0.001, infinity), rec))
                return 0;

            auto cos_theta_max = sqrt(1 - radius*radius/(center1 - origin).length_squared());
            auto solid_angle = 2*pi*(1-cos_theta_max);

            return  1 / solid_angle;
        }

        vec3 random(const point3& origin) const override {
            vec3 direction = center1 - origin;
            auto distance_squared = direction.length_squared();
            onb uvw;
            uvw.build_from_w(direction);
            return uvw.local(random_to_sphere(radius, distance_squared));
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

      private:
        ...

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        static vec3 random_to_sphere(double radius, double distance_squared) {
            auto r1 = random_double();
            auto r2 = random_double();
            auto z = 1 + r2*(sqrt(1-radius*radius/distance_squared) - 1);

            auto phi = 2*pi*r1;
            auto x = cos(phi)*sqrt(1-z*z);
            auto y = sin(phi)*sqrt(1-z*z);

            return vec3(x, y, z);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [sphere-pdf]: <kbd>[sphere.h]</kbd> Sphere with PDF]

<div class='together'>
We can first try just sampling the sphere rather than the light:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    int main() {
        ...

        // Light
        world.add(make_shared<quad>(point3(213,554,227), vec3(130,0,0), vec3(0,0,105), light));


        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        // Box
        shared_ptr<hittable> box1 = box(point3(0,0,0), point3(165,330,165), white);
        box1 = make_shared<rotate_y>(box1, 15);
        box1 = make_shared<translate>(box1, vec3(265,0,295));
        world.add(box1);

        // Glass Sphere
        auto glass = make_shared<dielectric>(1.5);
        world.add(make_shared<sphere>(point3(190,90,190), 90, glass));
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        // Light Sources
        hittable_list lights;
        auto m = shared_ptr<material>();
        lights.add(make_shared<quad>(point3(343,554,332), vec3(-130,0,0), vec3(0,0,-105), m));

        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [sampling-sphere]: <kbd>[main.cc]</kbd> Sampling just the sphere]

</div>

<div class='together'>
This yields a noisy room, but the caustic under the sphere is good. It took five times as long as
sampling the light did for my code. This is probably because those rays that hit the glass are
expensive!

  ![<span class='num'>Image 13:</span> Cornell box with glass sphere, using new PDF functions
  ](../images/img-3.13-cornell-glass-sphere.jpg class='pixel')

</div>


Adding PDF Functions to Hittable Lists
---------------------------------------
We should probably just sample both the sphere and the light. We can do that by creating a mixture
density of their two distributions. We could do that in the `ray_color()` function by passing a list
of hittables in and building a mixture PDF, or we could add PDF functions to `hittable_list`. I
think both tactics would work fine, but I will go with instrumenting `hittable_list`.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    class hittable_list : public hittable {
      public:
        ...


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        double pdf_value(const point3& origin, const vec3& direction) const override {
            auto weight = 1.0 / objects.size();
            auto sum = 0.0;

            for (const auto& object : objects)
                sum += weight * object->pdf_value(origin, direction);

            return sum;
        }

        vec3 random(const point3& origin) const override {
            auto int_size = int(objects.size());
            return objects[random_int(0, int_size-1)]->random(origin);
        }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        ...
    };
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [density-mixture]: <kbd>[hittable_list.h]</kbd> Creating a mixture of densities]

<div class='together'>
We assemble a list to pass to `render()` from `main()`:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    int main() {
        ...

        // Light Sources
        hittable_list lights;
        auto m = shared_ptr<material>();
        lights.add(make_shared<quad>(point3(343,554,332), vec3(-130,0,0), vec3(0,0,-105), m));
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        lights.add(make_shared<sphere>(point3(190, 90, 190), 90, m));
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        ...
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [scene-density-mixture]: <kbd>[main.cc]</kbd> Updating the scene]

</div>

<div class='together'>
And we get a decent image with 1000 samples as before:

  ![<span class='num'>Image 14:</span> Cornell box using a mixture of glass & light PDFs
  ](../images/img-3.14-glass-and-light.jpg class='pixel')

</div>


Handling Surface Acne
----------------------
An astute reader pointed out there are some black specks in the image above. All Monte Carlo Ray
Tracers have this as a main loop:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    pixel_color = average(many many samples)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you find yourself getting some form of acne in your renders, and this acne is white or black --
where one "bad" sample seems to kill the whole pixel -- then that sample is probably a huge number
or a `NaN` (Not A Number). This particular acne is probably a `NaN`. Mine seems to come up once in
every 10–100 million rays or so.

<div class='together'>
So big decision: sweep this bug under the rug and check for `NaN`s, or just kill `NaN`s and hope
this doesn't come back to bite us later. I will always opt for the lazy strategy, especially when I
know that working with floating point is hard. First, how do we check for a `NaN`? The one thing I
always remember for `NaN`s is that a `NaN` does not equal itself. Using this trick, we update the
`write_color()` function to replace any `NaN` components with zero:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
    void write_color(std::ostream& out, const color& pixel_color, int samples_per_pixel) {
        auto r = pixel_color.x();
        auto g = pixel_color.y();
        auto b = pixel_color.z();


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ highlight
        // Replace NaN components with zero.
        if (r != r) r = 0.0;
        if (g != g) g = 0.0;
        if (b != b) b = 0.0;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++

        // Divide the color by the number of samples and gamma-correct for gamma=2.0.
        auto scale = 1.0 / samples_per_pixel;
        r = sqrt(scale * r);
        g = sqrt(scale * g);
        b = sqrt(scale * b);

        // Write the translated [0,255] value of each color component.
        static const interval intensity(0.000, 0.999);
        out << int(256 * intensity.clamp(r)) << ' '
            << int(256 * intensity.clamp(g)) << ' '
            << int(256 * intensity.clamp(b)) << '\n';
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [write-color-nan]: <kbd>[color.h]</kbd> NaN-tolerant write_color function]

</div>

<div class='together'>
Happily, the black specks are gone:

  ![<span class='num'>Image 15:</span> Cornell box with anti-acne color function
  ](../images/img-3.15-book3-final.jpg class='pixel')

</div>



The Rest of Your Life
====================================================================================================
The purpose of this book was to walk through all of the little details (dotting all the i's and
crossing all of the t's) necessary when organizing a physically based renderer’s sampling approach.
You should now be able to take all of this detail and explore a lot of different potential paths.

If you want to explore Monte Carlo methods, look into bidirectional and path spaced approaches such
as Metropolis. Your probability space won't be over solid angle, but will instead be over path
space, where a path is a multidimensional point in a high-dimensional space. Don’t let that scare
you -- if you can describe an object with an array of numbers, mathematicians call it a point in the
space of all possible arrays of such points. That’s not just for show. Once you get a clean
abstraction like that, your code can get clean too. Clean abstractions are what programming is all
about!

If you want to do movie renderers, look at the papers out of studios and Solid Angle. They are
surprisingly open about their craft.

If you want to do high-performance ray tracing, look first at papers from Intel and NVIDIA. They are
also surprisingly open.

If you want to do hard-core physically based renderers, convert your renderer from RGB to spectral.
I am a big fan of each ray having a random wavelength and almost all the RGBs in your program
turning into floats. It sounds inefficient, but it isn’t!

Regardless of what direction you take, add a glossy BRDF model. There are many to choose from, and
each has its advantages.

Have fun!

[Peter Shirley][]<br>
Salt Lake City, March, 2016



                               (insert acknowledgments.md.html here)



Citing This Book
====================================================================================================
Consistent citations make it easier to identify the source, location and versions of this work. If
you are citing this book, we ask that you try to use one of the following forms if possible.

Basic Data
-----------
  - **Title (series)**: “Ray Tracing in One Weekend Series”
  - **Title (book)**: “Ray Tracing: The Rest of Your Life”
  - **Author**: Peter Shirley, Trevor David Black, Steve Hollasch
  - **Version/Edition**: v4.0.0-alpha.2
  - **Date**: 2023-XX-XX
  - **URL (series)**: https://raytracing.github.io/
  - **URL (book)**: https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html

Snippets
---------

  ### Markdown
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [_Ray Tracing: The Rest of Your Life_](https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ### HTML
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    <a href='https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html'>
        <cite>Ray Tracing: The Rest of Your Life</cite>
    </a>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ### LaTeX and BibTex
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~\cite{Shirley2023RTW3}

    @misc{Shirley2023RTW3,
       title = {Ray Tracing: The Rest of Your Life},
       author = {Peter Shirley, Trevor David Black, Steve Hollasch},
       year = {2023},
       month = {XXX},
       note = {\small \texttt{https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html}},
       url = {https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html}
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ### BibLaTeX
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    \usepackage{biblatex}

    ~\cite{Shirley2023RTW3}

    @online{Shirley2023RTW3,
       title = {Ray Tracing: The Rest of Your Life},
       author = {Peter Shirley, Trevor David Black, Steve Hollasch},
       year = {2023},
       month = {XXX},
       url = {https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html}
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ### IEEE
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    “Ray Tracing: The Rest of Your Life.”
    raytracing.github.io/books/RayTracingTheRestOfYourLife.html
    (accessed MMM. DD, YYYY)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ### MLA:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ray Tracing: The Rest of Your Life. raytracing.github.io/books/RayTracingTheRestOfYourLife.html
    Accessed DD MMM. YYYY.
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


[Peter Shirley]:      https://github.com/petershirley
[Steve Hollasch]:     https://github.com/hollasch
[Trevor David Black]: https://github.com/trevordblack



<!-- Markdeep: https://casual-effects.com/markdeep/ -->
<link rel='stylesheet' href='../style/book.css'>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep.min.js"></script>
<script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
